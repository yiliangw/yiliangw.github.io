<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/ethdev/rte_ethdev.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">23.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_c240775eefe260f0b8b46ef0dbfa47e0.html">ethdev</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">rte_ethdev.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__cman_8h_source.html">rte_cman.h</a>&gt;</code><br />
<code>#include &lt;rte_compat.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__log_8h_source.html">rte_log.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__interrupts_8h_source.html">rte_interrupts.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__dev_8h_source.html">rte_dev.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__devargs_8h_source.html">rte_devargs.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__bitops_8h_source.html">rte_bitops.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__errno_8h_source.html">rte_errno.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__common_8h_source.html">rte_common.h</a>&gt;</code><br />
<code>#include &lt;rte_config.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__power__intrinsics_8h_source.html">rte_power_intrinsics.h</a>&gt;</code><br />
<code>#include &quot;<a class="el" href="rte__ethdev__trace__fp_8h_source.html">rte_ethdev_trace_fp.h</a>&quot;</code><br />
<code>#include &quot;rte_dev_info.h&quot;</code><br />
<code>#include &quot;<a class="el" href="rte__eth__ctrl_8h_source.html">rte_eth_ctrl.h</a>&quot;</code><br />
<code>#include &lt;<a class="el" href="rte__ethdev__core_8h_source.html">rte_ethdev_core.h</a>&gt;</code><br />
</div>
<p><a href="rte__ethdev_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__stats.html">rte_eth_stats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__link.html">rte_eth_link</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__thresh.html">rte_eth_thresh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__rxmode.html">rte_eth_rxmode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__vlan__filter__conf.html">rte_vlan_filter_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__rss__conf.html">rte_eth_rss_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__rss__reta__entry64.html">rte_eth_rss_reta_entry64</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__vmdq__dcb__conf.html">rte_eth_vmdq_dcb_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__vmdq__rx__conf.html">rte_eth_vmdq_rx_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__txmode.html">rte_eth_txmode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__rxseg__split.html">rte_eth_rxseg_split</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionrte__eth__rxseg.html">rte_eth_rxseg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__rxconf.html">rte_eth_rxconf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__txconf.html">rte_eth_txconf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__hairpin__queue__cap.html">rte_eth_hairpin_queue_cap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__hairpin__cap.html">rte_eth_hairpin_cap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__hairpin__peer.html">rte_eth_hairpin_peer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__hairpin__conf.html">rte_eth_hairpin_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__desc__lim.html">rte_eth_desc_lim</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__fc__conf.html">rte_eth_fc_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__pfc__conf.html">rte_eth_pfc_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__pfc__queue__info.html">rte_eth_pfc_queue_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__pfc__queue__conf.html">rte_eth_pfc_queue_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__udp__tunnel.html">rte_eth_udp_tunnel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__intr__conf.html">rte_eth_intr_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__conf.html">rte_eth_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__dev__portconf.html">rte_eth_dev_portconf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__switch__info.html">rte_eth_switch_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__rxseg__capa.html">rte_eth_rxseg_capa</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__dev__info.html">rte_eth_dev_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__rxq__info.html">rte_eth_rxq_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__txq__info.html">rte_eth_txq_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__recycle__rxq__info.html">rte_eth_recycle_rxq_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__burst__mode.html">rte_eth_burst_mode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__xstat.html">rte_eth_xstat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__xstat__name.html">rte_eth_xstat_name</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__dcb__tc__queue__mapping.html">rte_eth_dcb_tc_queue_mapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__dcb__info.html">rte_eth_dcb_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__dev__tx__buffer.html">rte_eth_dev_tx_buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__event__macsec__desc.html">rte_eth_event_macsec_desc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__event__ipsec__desc.html">rte_eth_event_ipsec_desc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__representor__range.html">rte_eth_representor_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__representor__info.html">rte_eth_representor_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__ip__reassembly__params.html">rte_eth_ip_reassembly_params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__ip__reassembly__dynfield__t.html">rte_eth_ip_reassembly_dynfield_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__cman__info.html">rte_eth_cman_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__cman__config.html">rte_eth_cman_config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac5779482dfcd7e4a3d774b0da3e36641"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac5779482dfcd7e4a3d774b0da3e36641">RTE_ETH_FOREACH_MATCHING_DEV</a>(id,  devargs,  iter)</td></tr>
<tr class="separator:ac5779482dfcd7e4a3d774b0da3e36641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b07cdd038086f27503c465d2ded314"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aa4b07cdd038086f27503c465d2ded314">RTE_ETH_FLOW_PORT</a>&#160;&#160;&#160;18</td></tr>
<tr class="separator:aa4b07cdd038086f27503c465d2ded314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2e24a4f3d94ec3ab65ac516b50c9fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a8c2e24a4f3d94ec3ab65ac516b50c9fb">RTE_ETH_FLOW_VXLAN</a>&#160;&#160;&#160;19</td></tr>
<tr class="separator:a8c2e24a4f3d94ec3ab65ac516b50c9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5ea2e44996c8f3aaeef61e63831e2f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a2f5ea2e44996c8f3aaeef61e63831e2f">RTE_ETH_FLOW_GENEVE</a>&#160;&#160;&#160;20</td></tr>
<tr class="separator:a2f5ea2e44996c8f3aaeef61e63831e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c44d6fe8c46c6e78102a0e629a06a3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a93c44d6fe8c46c6e78102a0e629a06a3">RTE_ETH_FLOW_NVGRE</a>&#160;&#160;&#160;21</td></tr>
<tr class="separator:a93c44d6fe8c46c6e78102a0e629a06a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0bfed621cb545270fec65e438413e8e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad0bfed621cb545270fec65e438413e8e">RTE_ETH_FLOW_VXLAN_GPE</a>&#160;&#160;&#160;22</td></tr>
<tr class="separator:ad0bfed621cb545270fec65e438413e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955f586fbbd6270877a389a5736663b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a955f586fbbd6270877a389a5736663b1">RTE_ETH_FLOW_GTPU</a>&#160;&#160;&#160;23</td></tr>
<tr class="separator:a955f586fbbd6270877a389a5736663b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8f9874848b6a43e61e855107e2cba6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a8f8f9874848b6a43e61e855107e2cba6">RTE_ETH_RSS_L4_CHKSUM</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(35)</td></tr>
<tr class="separator:a8f8f9874848b6a43e61e855107e2cba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2788ff14dafad3d2b081ee8002d9ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a5e2788ff14dafad3d2b081ee8002d9ad">RTE_ETH_RSS_LEVEL_PMD_DEFAULT</a>&#160;&#160;&#160;(UINT64_C(0) &lt;&lt; 50)</td></tr>
<tr class="separator:a5e2788ff14dafad3d2b081ee8002d9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71e4d7a2c8aae73f1dfb7eb9a2f1699"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af71e4d7a2c8aae73f1dfb7eb9a2f1699">RTE_ETH_RSS_LEVEL_OUTERMOST</a>&#160;&#160;&#160;(UINT64_C(1) &lt;&lt; 50)</td></tr>
<tr class="separator:af71e4d7a2c8aae73f1dfb7eb9a2f1699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44399c69c5bd75f8cb4f959853cac861"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a44399c69c5bd75f8cb4f959853cac861">RTE_ETH_RSS_LEVEL_INNERMOST</a>&#160;&#160;&#160;(UINT64_C(2) &lt;&lt; 50)</td></tr>
<tr class="separator:a44399c69c5bd75f8cb4f959853cac861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97296a3668c79dad63086110ad5afec2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a97296a3668c79dad63086110ad5afec2">RTE_ETH_RSS_PROTO_MASK</a></td></tr>
<tr class="separator:a97296a3668c79dad63086110ad5afec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de5da4661e215c3910bc599b265a7f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a3de5da4661e215c3910bc599b265a7f5">RTE_ETH_NUM_RECEIVE_MAC_ADDR</a>&#160;&#160;&#160;128</td></tr>
<tr class="separator:a3de5da4661e215c3910bc599b265a7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5faaf8b9c988e47f69b6434b7d3e35a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac5faaf8b9c988e47f69b6434b7d3e35a">RTE_ETH_VMDQ_NUM_UC_HASH_ARRAY</a>&#160;&#160;&#160;128</td></tr>
<tr class="separator:ac5faaf8b9c988e47f69b6434b7d3e35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5c6b6dfaf3c80239a29c94dba546d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a8e5c6b6dfaf3c80239a29c94dba546d0">RTE_ETH_RX_OFFLOAD_VLAN_STRIP</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(0)</td></tr>
<tr class="separator:a8e5c6b6dfaf3c80239a29c94dba546d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b084764f74d4dad7f6d800492f1c492"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a6b084764f74d4dad7f6d800492f1c492">RTE_ETH_RX_OFFLOAD_TIMESTAMP</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(14)</td></tr>
<tr class="separator:a6b084764f74d4dad7f6d800492f1c492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b05b665bf74a83ffeafe766cf032183"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a1b05b665bf74a83ffeafe766cf032183">RTE_ETH_TX_OFFLOAD_VLAN_INSERT</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(0)</td></tr>
<tr class="separator:a1b05b665bf74a83ffeafe766cf032183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08f92c795a300b3b89d716bd3824f26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad08f92c795a300b3b89d716bd3824f26">RTE_ETH_TX_OFFLOAD_OUTER_IPV4_CKSUM</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(7)</td></tr>
<tr class="separator:ad08f92c795a300b3b89d716bd3824f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6650d2907021c1175764d489dd356187"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a6650d2907021c1175764d489dd356187">RTE_ETH_TX_OFFLOAD_VXLAN_TNL_TSO</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(9)</td></tr>
<tr class="separator:a6650d2907021c1175764d489dd356187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5b8b65cf5b425c831fec11f8ab7549"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a1c5b8b65cf5b425c831fec11f8ab7549">RTE_ETH_TX_OFFLOAD_GRE_TNL_TSO</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(10)</td></tr>
<tr class="separator:a1c5b8b65cf5b425c831fec11f8ab7549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590ccadf43e3935e33367cfb51d4164e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a590ccadf43e3935e33367cfb51d4164e">RTE_ETH_TX_OFFLOAD_IPIP_TNL_TSO</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(11)</td></tr>
<tr class="separator:a590ccadf43e3935e33367cfb51d4164e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fd63a49d052c11e85e12e20a2af5a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af1fd63a49d052c11e85e12e20a2af5a9">RTE_ETH_TX_OFFLOAD_GENEVE_TNL_TSO</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(12)</td></tr>
<tr class="separator:af1fd63a49d052c11e85e12e20a2af5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd8e0a04a7c7d8aa96cb649499bc5d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a0cd8e0a04a7c7d8aa96cb649499bc5d8">RTE_ETH_TX_OFFLOAD_MT_LOCKFREE</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(14)</td></tr>
<tr class="separator:a0cd8e0a04a7c7d8aa96cb649499bc5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2aec9935b1040d8a03682f1adb5770e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af2aec9935b1040d8a03682f1adb5770e">RTE_ETH_TX_OFFLOAD_MULTI_SEGS</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(15)</td></tr>
<tr class="separator:af2aec9935b1040d8a03682f1adb5770e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f198c6b59d965130d56fd8f40ceac1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a43f198c6b59d965130d56fd8f40ceac1">RTE_ETH_TX_OFFLOAD_MBUF_FAST_FREE</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(16)</td></tr>
<tr class="separator:a43f198c6b59d965130d56fd8f40ceac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f33b32ed53a39c9b88940b673c9a828"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a6f33b32ed53a39c9b88940b673c9a828">RTE_ETH_TX_OFFLOAD_UDP_TNL_TSO</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(18)</td></tr>
<tr class="separator:a6f33b32ed53a39c9b88940b673c9a828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eda9f39d545d96df591c4470bbfd2c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a6eda9f39d545d96df591c4470bbfd2c7">RTE_ETH_TX_OFFLOAD_IP_TNL_TSO</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(19)</td></tr>
<tr class="separator:a6eda9f39d545d96df591c4470bbfd2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2098a9f392175b2797c14ef37f56efe9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a2098a9f392175b2797c14ef37f56efe9">RTE_ETH_TX_OFFLOAD_OUTER_UDP_CKSUM</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(20)</td></tr>
<tr class="separator:a2098a9f392175b2797c14ef37f56efe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12803b6c19b10bd0c5ee30e8f07ef56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af12803b6c19b10bd0c5ee30e8f07ef56">RTE_ETH_TX_OFFLOAD_SEND_ON_TIMESTAMP</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(21)</td></tr>
<tr class="separator:af12803b6c19b10bd0c5ee30e8f07ef56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54d566e2ae76bc015c0f7ed1fe000c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af54d566e2ae76bc015c0f7ed1fe000c9">RTE_ETH_DEV_SWITCH_DOMAIN_ID_INVALID</a>&#160;&#160;&#160;(UINT16_MAX)</td></tr>
<tr class="separator:af54d566e2ae76bc015c0f7ed1fe000c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861af3fb10a9faa1324e43c00bfa2391"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a861af3fb10a9faa1324e43c00bfa2391">RTE_ETH_BURST_FLAG_PER_QUEUE</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(0)</td></tr>
<tr class="separator:a861af3fb10a9faa1324e43c00bfa2391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6044a6301db5c64fd0b0e1b807bfd1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a2e6044a6301db5c64fd0b0e1b807bfd1">RTE_ETH_BURST_MODE_INFO_SIZE</a>&#160;&#160;&#160;1024</td></tr>
<tr class="separator:a2e6044a6301db5c64fd0b0e1b807bfd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef015c6435970820b78112eaaef14d58"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aef015c6435970820b78112eaaef14d58">RTE_ETH_XSTATS_NAME_SIZE</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:aef015c6435970820b78112eaaef14d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0251ed7f4aa8c0bd8d12e5bc3fa17e84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a0251ed7f4aa8c0bd8d12e5bc3fa17e84">RTE_ETH_FOREACH_DEV_OWNED_BY</a>(p,  o)</td></tr>
<tr class="separator:a0251ed7f4aa8c0bd8d12e5bc3fa17e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b46c67203d37fe3a34f11076d970d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad7b46c67203d37fe3a34f11076d970d6">RTE_ETH_FOREACH_DEV</a>(p)&#160;&#160;&#160;	<a class="el" href="rte__ethdev_8h.html#a0251ed7f4aa8c0bd8d12e5bc3fa17e84">RTE_ETH_FOREACH_DEV_OWNED_BY</a>(p, RTE_ETH_DEV_NO_OWNER)</td></tr>
<tr class="separator:ad7b46c67203d37fe3a34f11076d970d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4fe1205ba0a7164273457c8f36720c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a7d4fe1205ba0a7164273457c8f36720c">RTE_ETH_FOREACH_DEV_OF</a>(port_id,  parent)</td></tr>
<tr class="separator:a7d4fe1205ba0a7164273457c8f36720c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3638b7c090190701b94aef18b1369bfa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a3638b7c090190701b94aef18b1369bfa">RTE_ETH_FOREACH_DEV_SIBLING</a>(port_id,  ref_port_id)</td></tr>
<tr class="separator:a3638b7c090190701b94aef18b1369bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff24ae3f48be43275b50966c3573a7a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aff24ae3f48be43275b50966c3573a7a9">RTE_ETH_TX_BUFFER_SIZE</a>(sz)&#160;&#160;&#160;	(sizeof(struct <a class="el" href="structrte__eth__dev__tx__buffer.html">rte_eth_dev_tx_buffer</a>) + (sz) * sizeof(struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *))</td></tr>
<tr class="separator:aff24ae3f48be43275b50966c3573a7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef90b0d32dcf444b5bbf5c3b9b778c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a9ef90b0d32dcf444b5bbf5c3b9b778c4">RTE_ETH_RX_METADATA_USER_FLAG</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(0)</td></tr>
<tr class="separator:a9ef90b0d32dcf444b5bbf5c3b9b778c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afa36f3c9d4c1f66a5828e2850a9cd3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a0afa36f3c9d4c1f66a5828e2850a9cd3">RTE_ETH_RX_METADATA_USER_MARK</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(1)</td></tr>
<tr class="separator:a0afa36f3c9d4c1f66a5828e2850a9cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302ba9f7eb77bfaf00e26503ce866b44"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a302ba9f7eb77bfaf00e26503ce866b44">RTE_ETH_RX_METADATA_TUNNEL_ID</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(2)</td></tr>
<tr class="separator:a302ba9f7eb77bfaf00e26503ce866b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e2d3a2e79cf285863d23d2cf9740fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a34e2d3a2e79cf285863d23d2cf9740fd">RTE_ETH_DEV_REASSEMBLY_F_IPV4</a>&#160;&#160;&#160;(<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(0))</td></tr>
<tr class="separator:a34e2d3a2e79cf285863d23d2cf9740fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02baf1aa61b3c92ad215961db03d274b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a02baf1aa61b3c92ad215961db03d274b">RTE_ETH_DEV_REASSEMBLY_F_IPV6</a>&#160;&#160;&#160;(<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(1))</td></tr>
<tr class="separator:a02baf1aa61b3c92ad215961db03d274b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Link speed capabilities</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Device supported speeds bitmap flags </p>
</div></td></tr>
<tr class="memitem:a1016c5eb3a3e69ff6cbbcd0842e66d94"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a1016c5eb3a3e69ff6cbbcd0842e66d94">RTE_ETH_LINK_SPEED_AUTONEG</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a1016c5eb3a3e69ff6cbbcd0842e66d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c8b245eca75f1784301ca309118799"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad0c8b245eca75f1784301ca309118799">RTE_ETH_LINK_SPEED_FIXED</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(0)</td></tr>
<tr class="separator:ad0c8b245eca75f1784301ca309118799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58978c83b5797c529e1821eba0a56feb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a58978c83b5797c529e1821eba0a56feb">RTE_ETH_LINK_SPEED_10M_HD</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(1)</td></tr>
<tr class="separator:a58978c83b5797c529e1821eba0a56feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d06b2382de7110ba5e61da5bd1cc5f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a25d06b2382de7110ba5e61da5bd1cc5f">RTE_ETH_LINK_SPEED_10M</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(2)</td></tr>
<tr class="separator:a25d06b2382de7110ba5e61da5bd1cc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d828ff2e554c242e01115c0721d8fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a21d828ff2e554c242e01115c0721d8fa">RTE_ETH_LINK_SPEED_100M_HD</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(3)</td></tr>
<tr class="separator:a21d828ff2e554c242e01115c0721d8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9bc69e0715a6a94cfd03f95f0a694d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#abb9bc69e0715a6a94cfd03f95f0a694d">RTE_ETH_LINK_SPEED_100M</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(4)</td></tr>
<tr class="separator:abb9bc69e0715a6a94cfd03f95f0a694d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77442a17c299185fbae87ac01442afa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ab77442a17c299185fbae87ac01442afa">RTE_ETH_LINK_SPEED_1G</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(5)</td></tr>
<tr class="separator:ab77442a17c299185fbae87ac01442afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5beb2c2d4dfc9d2be22a028c3e3be6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a5f5beb2c2d4dfc9d2be22a028c3e3be6">RTE_ETH_LINK_SPEED_2_5G</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(6)</td></tr>
<tr class="separator:a5f5beb2c2d4dfc9d2be22a028c3e3be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e322ee653d48456eab00371838691e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a47e322ee653d48456eab00371838691e">RTE_ETH_LINK_SPEED_5G</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(7)</td></tr>
<tr class="separator:a47e322ee653d48456eab00371838691e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa934a67d656f06427696945a01295f1e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aa934a67d656f06427696945a01295f1e">RTE_ETH_LINK_SPEED_10G</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(8)</td></tr>
<tr class="separator:aa934a67d656f06427696945a01295f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe583a91d5eecbf09cb0114006cf7d4e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#abe583a91d5eecbf09cb0114006cf7d4e">RTE_ETH_LINK_SPEED_20G</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(9)</td></tr>
<tr class="separator:abe583a91d5eecbf09cb0114006cf7d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a282cfc405124977cb2503227d5c83"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a02a282cfc405124977cb2503227d5c83">RTE_ETH_LINK_SPEED_25G</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(10)</td></tr>
<tr class="separator:a02a282cfc405124977cb2503227d5c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18082b3ff6da3c599073e38233f94e80"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a18082b3ff6da3c599073e38233f94e80">RTE_ETH_LINK_SPEED_40G</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(11)</td></tr>
<tr class="separator:a18082b3ff6da3c599073e38233f94e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4800ebca83ac27cb46bbe74098206682"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a4800ebca83ac27cb46bbe74098206682">RTE_ETH_LINK_SPEED_50G</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(12)</td></tr>
<tr class="separator:a4800ebca83ac27cb46bbe74098206682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa664a99f449d71f85a116878b216561b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aa664a99f449d71f85a116878b216561b">RTE_ETH_LINK_SPEED_56G</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(13)</td></tr>
<tr class="separator:aa664a99f449d71f85a116878b216561b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183a5166614b4a20de1e09c6615f6570"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a183a5166614b4a20de1e09c6615f6570">RTE_ETH_LINK_SPEED_100G</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(14)</td></tr>
<tr class="separator:a183a5166614b4a20de1e09c6615f6570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b97fe70c3dc9cab51e48db839450af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a21b97fe70c3dc9cab51e48db839450af">RTE_ETH_LINK_SPEED_200G</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(15)</td></tr>
<tr class="separator:a21b97fe70c3dc9cab51e48db839450af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196131c6a97096a6d23e441c6852a570"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a196131c6a97096a6d23e441c6852a570">RTE_ETH_LINK_SPEED_400G</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(16)</td></tr>
<tr class="separator:a196131c6a97096a6d23e441c6852a570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Link speed</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Ethernet numeric link speeds in Mbps </p>
</div></td></tr>
<tr class="memitem:a097f6c3ec66c069623dbaafc4f21f1b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a097f6c3ec66c069623dbaafc4f21f1b6">RTE_ETH_SPEED_NUM_NONE</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a097f6c3ec66c069623dbaafc4f21f1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cc9e26fe0b2c33cf7ded660961c22c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a38cc9e26fe0b2c33cf7ded660961c22c">RTE_ETH_SPEED_NUM_10M</a>&#160;&#160;&#160;10</td></tr>
<tr class="separator:a38cc9e26fe0b2c33cf7ded660961c22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591107c9b175ff8b4b160fdb258f55fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a591107c9b175ff8b4b160fdb258f55fd">RTE_ETH_SPEED_NUM_100M</a>&#160;&#160;&#160;100</td></tr>
<tr class="separator:a591107c9b175ff8b4b160fdb258f55fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3112616e5f27ada75c527d338ab49a9d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a3112616e5f27ada75c527d338ab49a9d">RTE_ETH_SPEED_NUM_1G</a>&#160;&#160;&#160;1000</td></tr>
<tr class="separator:a3112616e5f27ada75c527d338ab49a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588aa1584f250ded024807cf1d2be85e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a588aa1584f250ded024807cf1d2be85e">RTE_ETH_SPEED_NUM_2_5G</a>&#160;&#160;&#160;2500</td></tr>
<tr class="separator:a588aa1584f250ded024807cf1d2be85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12739ac2400dd43b71317be35756e0f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a12739ac2400dd43b71317be35756e0f2">RTE_ETH_SPEED_NUM_5G</a>&#160;&#160;&#160;5000</td></tr>
<tr class="separator:a12739ac2400dd43b71317be35756e0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb91534e3e4fd48d1beb52c73c41966"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aafb91534e3e4fd48d1beb52c73c41966">RTE_ETH_SPEED_NUM_10G</a>&#160;&#160;&#160;10000</td></tr>
<tr class="separator:aafb91534e3e4fd48d1beb52c73c41966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae910660c8241d69b01b180a192d488"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#acae910660c8241d69b01b180a192d488">RTE_ETH_SPEED_NUM_20G</a>&#160;&#160;&#160;20000</td></tr>
<tr class="separator:acae910660c8241d69b01b180a192d488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd96aae4d2e1eb2bfcf60e22c0903c6a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#acd96aae4d2e1eb2bfcf60e22c0903c6a">RTE_ETH_SPEED_NUM_25G</a>&#160;&#160;&#160;25000</td></tr>
<tr class="separator:acd96aae4d2e1eb2bfcf60e22c0903c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b0369044e83603bc88aadd0070a382"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a36b0369044e83603bc88aadd0070a382">RTE_ETH_SPEED_NUM_40G</a>&#160;&#160;&#160;40000</td></tr>
<tr class="separator:a36b0369044e83603bc88aadd0070a382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c33b0f2782e591a0ab8675bd3865eb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a95c33b0f2782e591a0ab8675bd3865eb">RTE_ETH_SPEED_NUM_50G</a>&#160;&#160;&#160;50000</td></tr>
<tr class="separator:a95c33b0f2782e591a0ab8675bd3865eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8b034a24123458db37bd831c495fee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#afd8b034a24123458db37bd831c495fee">RTE_ETH_SPEED_NUM_56G</a>&#160;&#160;&#160;56000</td></tr>
<tr class="separator:afd8b034a24123458db37bd831c495fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6de23b6918f91776bcdd9c19408e35e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ae6de23b6918f91776bcdd9c19408e35e">RTE_ETH_SPEED_NUM_100G</a>&#160;&#160;&#160;100000</td></tr>
<tr class="separator:ae6de23b6918f91776bcdd9c19408e35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ac73559e9edd2ffebd3bbc3a7a5dfc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a82ac73559e9edd2ffebd3bbc3a7a5dfc">RTE_ETH_SPEED_NUM_200G</a>&#160;&#160;&#160;200000</td></tr>
<tr class="separator:a82ac73559e9edd2ffebd3bbc3a7a5dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ea70b3e476b9eb5924da0838f82f6e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a92ea70b3e476b9eb5924da0838f82f6e">RTE_ETH_SPEED_NUM_400G</a>&#160;&#160;&#160;400000</td></tr>
<tr class="separator:a92ea70b3e476b9eb5924da0838f82f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5542082799b1410125eab256b2711002"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a5542082799b1410125eab256b2711002">RTE_ETH_SPEED_NUM_UNKNOWN</a>&#160;&#160;&#160;UINT32_MAX</td></tr>
<tr class="separator:a5542082799b1410125eab256b2711002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Link negotiation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Constants used in link management. </p>
</div></td></tr>
<tr class="memitem:ac41ad0dab3e7aa7934e9c7ffa3f61bac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac41ad0dab3e7aa7934e9c7ffa3f61bac">RTE_ETH_LINK_HALF_DUPLEX</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ac41ad0dab3e7aa7934e9c7ffa3f61bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0da1e11afe4fbc233bb5454145100c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a1c0da1e11afe4fbc233bb5454145100c">RTE_ETH_LINK_FULL_DUPLEX</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a1c0da1e11afe4fbc233bb5454145100c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dcf5d88b202ce0d25d389459f0b009"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a25dcf5d88b202ce0d25d389459f0b009">RTE_ETH_LINK_DOWN</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a25dcf5d88b202ce0d25d389459f0b009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a679c23f624fdace0170488179cf8b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a47a679c23f624fdace0170488179cf8b">RTE_ETH_LINK_UP</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a47a679c23f624fdace0170488179cf8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f6e2279cf7fc9dafdea87644d3fc11"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a95f6e2279cf7fc9dafdea87644d3fc11">RTE_ETH_LINK_FIXED</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a95f6e2279cf7fc9dafdea87644d3fc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84c533bcaf2a4a03a2d013fb39c7608"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aa84c533bcaf2a4a03a2d013fb39c7608">RTE_ETH_LINK_AUTONEG</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:aa84c533bcaf2a4a03a2d013fb39c7608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a31d6736244603b6a1d7efdd32a8834"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a7a31d6736244603b6a1d7efdd32a8834">RTE_ETH_LINK_MAX_STR_LEN</a>&#160;&#160;&#160;40</td></tr>
<tr class="separator:a7a31d6736244603b6a1d7efdd32a8834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Multi-queue mode</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section see"><dt>See also</dt><dd>rte_eth_conf.rxmode.mq_mode. </dd></dl>
</div></td></tr>
<tr class="memitem:ab3f9dff54f4b62c055037c14192f3ac4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ab3f9dff54f4b62c055037c14192f3ac4">RTE_ETH_MQ_RX_RSS_FLAG</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(0)</td></tr>
<tr class="separator:ab3f9dff54f4b62c055037c14192f3ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94796f5cd5a38f9b087b78ef11ca2733"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a94796f5cd5a38f9b087b78ef11ca2733">RTE_ETH_MQ_RX_DCB_FLAG</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(1)</td></tr>
<tr class="separator:a94796f5cd5a38f9b087b78ef11ca2733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7665dae0141ae048fec4b2916f863c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac7665dae0141ae048fec4b2916f863c7">RTE_ETH_MQ_RX_VMDQ_FLAG</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(2)</td></tr>
<tr class="separator:ac7665dae0141ae048fec4b2916f863c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">VMDq and DCB maximums</div></td></tr>
<tr class="memitem:a6086d5152d45a531057af4521dd33b3a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a6086d5152d45a531057af4521dd33b3a">RTE_ETH_VMDQ_MAX_VLAN_FILTERS</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:a6086d5152d45a531057af4521dd33b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2604741049d2115f9e0b5f36f6a3d591"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a2604741049d2115f9e0b5f36f6a3d591">RTE_ETH_DCB_NUM_USER_PRIORITIES</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a2604741049d2115f9e0b5f36f6a3d591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae421db3efad2132e9a686e1a96e26d81"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ae421db3efad2132e9a686e1a96e26d81">RTE_ETH_VMDQ_DCB_NUM_QUEUES</a>&#160;&#160;&#160;128</td></tr>
<tr class="separator:ae421db3efad2132e9a686e1a96e26d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae449697ac0a0ad5b3770c5b3c06c3305"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ae449697ac0a0ad5b3770c5b3c06c3305">RTE_ETH_DCB_NUM_QUEUES</a>&#160;&#160;&#160;128</td></tr>
<tr class="separator:ae449697ac0a0ad5b3770c5b3c06c3305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">DCB capabilities</div></td></tr>
<tr class="memitem:a03ae4ab10a1f9a5d7e44dbf54609eb92"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a03ae4ab10a1f9a5d7e44dbf54609eb92">RTE_ETH_DCB_PG_SUPPORT</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(0)</td></tr>
<tr class="separator:a03ae4ab10a1f9a5d7e44dbf54609eb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563b1f15304c3ec5ed733fee19c79e3a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a563b1f15304c3ec5ed733fee19c79e3a">RTE_ETH_DCB_PFC_SUPPORT</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(1)</td></tr>
<tr class="separator:a563b1f15304c3ec5ed733fee19c79e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">VLAN offload bits</div></td></tr>
<tr class="memitem:af139b95af2511203a5732c64d3aaba34"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af139b95af2511203a5732c64d3aaba34">RTE_ETH_VLAN_STRIP_OFFLOAD</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="separator:af139b95af2511203a5732c64d3aaba34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6389be72892948f8d12fafdb1f7c41e2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a6389be72892948f8d12fafdb1f7c41e2">RTE_ETH_VLAN_FILTER_OFFLOAD</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="separator:a6389be72892948f8d12fafdb1f7c41e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3e8905940772cb41da75e9a09553e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#acd3e8905940772cb41da75e9a09553e6">RTE_ETH_VLAN_EXTEND_OFFLOAD</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="separator:acd3e8905940772cb41da75e9a09553e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf88fd26dba1759406f4f453e1671c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a0cf88fd26dba1759406f4f453e1671c4">RTE_ETH_QINQ_STRIP_OFFLOAD</a>&#160;&#160;&#160;0x0008</td></tr>
<tr class="separator:a0cf88fd26dba1759406f4f453e1671c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c1a65aa437374e4e1cfc8efdbad64f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a59c1a65aa437374e4e1cfc8efdbad64f">RTE_ETH_VLAN_STRIP_MASK</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="separator:a59c1a65aa437374e4e1cfc8efdbad64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff10995486199c1acec0d08561b08b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a5ff10995486199c1acec0d08561b08b0">RTE_ETH_VLAN_FILTER_MASK</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="separator:a5ff10995486199c1acec0d08561b08b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf35ff1901c4a0ea852cb70059a39c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#afcf35ff1901c4a0ea852cb70059a39c1">RTE_ETH_VLAN_EXTEND_MASK</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="separator:afcf35ff1901c4a0ea852cb70059a39c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5dad5fdc1f69a2ba55a18c5fdeb6d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a0c5dad5fdc1f69a2ba55a18c5fdeb6d2">RTE_ETH_QINQ_STRIP_MASK</a>&#160;&#160;&#160;0x0008</td></tr>
<tr class="separator:a0c5dad5fdc1f69a2ba55a18c5fdeb6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ab9023465d6295c8c92f6bbf910e03"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a70ab9023465d6295c8c92f6bbf910e03">RTE_ETH_VLAN_ID_MAX</a>&#160;&#160;&#160;0x0FFF</td></tr>
<tr class="separator:a70ab9023465d6295c8c92f6bbf910e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">VMDq Rx mode</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section see"><dt>See also</dt><dd><a class="el" href="structrte__eth__vmdq__rx__conf.html#a25189ff51ac0748d611eabd14cb1cc6a">rte_eth_vmdq_rx_conf.rx_mode</a> </dd></dl>
</div></td></tr>
<tr class="memitem:a8e4235c1b3f5e5f8095e0f5b16e565e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a8e4235c1b3f5e5f8095e0f5b16e565e9">RTE_ETH_VMDQ_ACCEPT_UNTAG</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(0)</td></tr>
<tr class="separator:a8e4235c1b3f5e5f8095e0f5b16e565e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2df94b09550b9fe0402d3afc3b1a29"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#afe2df94b09550b9fe0402d3afc3b1a29">RTE_ETH_VMDQ_ACCEPT_HASH_MC</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(1)</td></tr>
<tr class="separator:afe2df94b09550b9fe0402d3afc3b1a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e2ec2852ddd2db863da67fd39793af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aa3e2ec2852ddd2db863da67fd39793af">RTE_ETH_VMDQ_ACCEPT_HASH_UC</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(2)</td></tr>
<tr class="separator:aa3e2ec2852ddd2db863da67fd39793af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad72b961df8f1c1bd38ef02bd781b15"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#abad72b961df8f1c1bd38ef02bd781b15">RTE_ETH_VMDQ_ACCEPT_BROADCAST</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(3)</td></tr>
<tr class="separator:abad72b961df8f1c1bd38ef02bd781b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d739e7afdd47b54638d637f3a75199a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a1d739e7afdd47b54638d637f3a75199a">RTE_ETH_VMDQ_ACCEPT_MULTICAST</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(4)</td></tr>
<tr class="separator:a1d739e7afdd47b54638d637f3a75199a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Device capabilities</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Non-offload capabilities reported in <a class="el" href="structrte__eth__dev__info.html#a1fa067dcfa682322be1162a27fed43af">rte_eth_dev_info.dev_capa</a>. </p>
</div></td></tr>
<tr class="memitem:a59f716aab25560f9d074bda5e9daea78"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a59f716aab25560f9d074bda5e9daea78">RTE_ETH_DEV_CAPA_RUNTIME_RX_QUEUE_SETUP</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(0)</td></tr>
<tr class="separator:a59f716aab25560f9d074bda5e9daea78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069e4f3f971c847588f6ee53edc9b63a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a069e4f3f971c847588f6ee53edc9b63a">RTE_ETH_DEV_CAPA_RUNTIME_TX_QUEUE_SETUP</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(1)</td></tr>
<tr class="separator:a069e4f3f971c847588f6ee53edc9b63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40be0550562865a1f8299a867979832"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ab40be0550562865a1f8299a867979832">RTE_ETH_DEV_CAPA_RXQ_SHARE</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(2)</td></tr>
<tr class="separator:ab40be0550562865a1f8299a867979832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7413b162b5cec14de0291f104a77567e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a7413b162b5cec14de0291f104a77567e">RTE_ETH_DEV_CAPA_FLOW_RULE_KEEP</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(3)</td></tr>
<tr class="separator:a7413b162b5cec14de0291f104a77567e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553d459c88eb2ccf31f6ed0e5910847d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a553d459c88eb2ccf31f6ed0e5910847d">RTE_ETH_DEV_CAPA_FLOW_SHARED_OBJECT_KEEP</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(4)</td></tr>
<tr class="separator:a553d459c88eb2ccf31f6ed0e5910847d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Rx/Tx queue states</div></td></tr>
<tr class="memitem:a3abc58fe4d2e266f9e285d5f34eb3579"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a3abc58fe4d2e266f9e285d5f34eb3579">RTE_ETH_QUEUE_STATE_STOPPED</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a3abc58fe4d2e266f9e285d5f34eb3579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0753713af1e72b067884e51ce1f1782b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a0753713af1e72b067884e51ce1f1782b">RTE_ETH_QUEUE_STATE_STARTED</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a0753713af1e72b067884e51ce1f1782b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add59ad5a5a7497b381ab114f89893992"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#add59ad5a5a7497b381ab114f89893992">RTE_ETH_QUEUE_STATE_HAIRPIN</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:add59ad5a5a7497b381ab114f89893992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Device flags</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Flags internally saved in rte_eth_dev_data.dev_flags and reported in <a class="el" href="structrte__eth__dev__info.html#af4833946226c90a954a7dca3fe77a162">rte_eth_dev_info.dev_flags</a>. </p>
</div></td></tr>
<tr class="memitem:aba3aae3effe98f1567b59974f6477984"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aba3aae3effe98f1567b59974f6477984">RTE_ETH_DEV_FLOW_OPS_THREAD_SAFE</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(0)</td></tr>
<tr class="separator:aba3aae3effe98f1567b59974f6477984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c2348839c58faa378a071c09c22db6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac9c2348839c58faa378a071c09c22db6">RTE_ETH_DEV_INTR_LSC</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(1)</td></tr>
<tr class="separator:ac9c2348839c58faa378a071c09c22db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1b6a70dd6b9277d4d93fc4c0c075ca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a8e1b6a70dd6b9277d4d93fc4c0c075ca">RTE_ETH_DEV_BONDING_MEMBER</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(2)</td></tr>
<tr class="separator:a8e1b6a70dd6b9277d4d93fc4c0c075ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7ea7a84189637d9bb6bb7bc2e86ee2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a4c7ea7a84189637d9bb6bb7bc2e86ee2">RTE_ETH_DEV_INTR_RMV</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(3)</td></tr>
<tr class="separator:a4c7ea7a84189637d9bb6bb7bc2e86ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b0cf1c6bf0c5a5b175997c73aacd3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aa1b0cf1c6bf0c5a5b175997c73aacd3b">RTE_ETH_DEV_REPRESENTOR</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(4)</td></tr>
<tr class="separator:aa1b0cf1c6bf0c5a5b175997c73aacd3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f879ef19601f28f200d4293933854e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a57f879ef19601f28f200d4293933854e">RTE_ETH_DEV_NOLIVE_MAC_ADDR</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(5)</td></tr>
<tr class="separator:a57f879ef19601f28f200d4293933854e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b145edb9f8961ef6604ed508486a396"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a8b145edb9f8961ef6604ed508486a396">RTE_ETH_DEV_AUTOFILL_QUEUE_XSTATS</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(6)</td></tr>
<tr class="separator:a8b145edb9f8961ef6604ed508486a396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Rx hardware descriptor states</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__ethdev_8h.html#ad3129ac553f76fd90d7e5eea46a63398">rte_eth_rx_descriptor_status</a> </dd></dl>
</div></td></tr>
<tr class="memitem:af7bd60e9403569c36e77fa16a21ecf17"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af7bd60e9403569c36e77fa16a21ecf17">RTE_ETH_RX_DESC_AVAIL</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:af7bd60e9403569c36e77fa16a21ecf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8f3353b8a75da4604d54012c87fc10"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#abc8f3353b8a75da4604d54012c87fc10">RTE_ETH_RX_DESC_DONE</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:abc8f3353b8a75da4604d54012c87fc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57b694aa035341057c03fd9977b7f09"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aa57b694aa035341057c03fd9977b7f09">RTE_ETH_RX_DESC_UNAVAIL</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:aa57b694aa035341057c03fd9977b7f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tx hardware descriptor states</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__ethdev_8h.html#ad43765b16539f14b46926235dccd0460">rte_eth_tx_descriptor_status</a> </dd></dl>
</div></td></tr>
<tr class="memitem:a04664422a6ea44b1a7961523344e53f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a04664422a6ea44b1a7961523344e53f4">RTE_ETH_TX_DESC_FULL</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a04664422a6ea44b1a7961523344e53f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac2b8d40c588ca7677b592b267a09d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a1ac2b8d40c588ca7677b592b267a09d7">RTE_ETH_TX_DESC_DONE</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a1ac2b8d40c588ca7677b592b267a09d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bdf994261b2caae5be400abed2796d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac5bdf994261b2caae5be400abed2796d">RTE_ETH_TX_DESC_UNAVAIL</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ac5bdf994261b2caae5be400abed2796d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7400438ebc28f2343aa0453ad5a4a021"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> uint16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a7400438ebc28f2343aa0453ad5a4a021">rte_rx_callback_fn</a>) (uint16_t port_id, uint16_t queue, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *pkts[], uint16_t nb_pkts, uint16_t max_pkts, void *user_param)</td></tr>
<tr class="separator:a7400438ebc28f2343aa0453ad5a4a021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb995c6332dcda43bc0c551ea266d7fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> uint16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aeb995c6332dcda43bc0c551ea266d7fd">rte_tx_callback_fn</a>) (uint16_t port_id, uint16_t queue, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *pkts[], uint16_t nb_pkts, void *user_param)</td></tr>
<tr class="separator:aeb995c6332dcda43bc0c551ea266d7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868605d09373258672f598e8bf4dab82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a868605d09373258672f598e8bf4dab82">rte_eth_dev_cb_fn</a>) (uint16_t port_id, enum <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779d">rte_eth_event_type</a> event, void *cb_arg, void *ret_param)</td></tr>
<tr class="separator:a868605d09373258672f598e8bf4dab82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a586b8e86131b4ec0ccaf464e847ccf3e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3e">rte_eth_rx_mq_mode</a> { <br />
&#160;&#160;<a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3eac0de03aca722016af342202cf50c8b1d">RTE_ETH_MQ_RX_NONE</a> = 0
, <a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3eacbbd9761e99374702db64823901e27c9">RTE_ETH_MQ_RX_RSS</a> = RTE_ETH_MQ_RX_RSS_FLAG
, <a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3ea7a0ef8d03750d5bac7dc5d323a99ac71">RTE_ETH_MQ_RX_DCB</a> = RTE_ETH_MQ_RX_DCB_FLAG
, <a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3ea4f82f1f9657b61e204c6ea6d8e41613c">RTE_ETH_MQ_RX_DCB_RSS</a> = RTE_ETH_MQ_RX_RSS_FLAG | RTE_ETH_MQ_RX_DCB_FLAG
, <br />
&#160;&#160;<a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3eae0269cffccfa3c7b0c4486394e78f386">RTE_ETH_MQ_RX_VMDQ_ONLY</a> = RTE_ETH_MQ_RX_VMDQ_FLAG
, <a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3eac0883fb0c59e8a04b6d57d8245e6973e">RTE_ETH_MQ_RX_VMDQ_RSS</a> = RTE_ETH_MQ_RX_RSS_FLAG | RTE_ETH_MQ_RX_VMDQ_FLAG
, <a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3eabe84d1a50e212e1a8fa2df21bc6e7401">RTE_ETH_MQ_RX_VMDQ_DCB</a> = RTE_ETH_MQ_RX_VMDQ_FLAG | RTE_ETH_MQ_RX_DCB_FLAG
, <a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3ea5e4d6373c0b8b8e0d99335e4124c3889">RTE_ETH_MQ_RX_VMDQ_DCB_RSS</a>
<br />
 }</td></tr>
<tr class="separator:a586b8e86131b4ec0ccaf464e847ccf3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4834f572f4dd4e46d81ad09b7d5fffd5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a4834f572f4dd4e46d81ad09b7d5fffd5">rte_eth_tx_mq_mode</a> { <a class="el" href="rte__ethdev_8h.html#a4834f572f4dd4e46d81ad09b7d5fffd5a8b60a567503b43239d4fc7a5c3384015">RTE_ETH_MQ_TX_NONE</a> = 0
, <a class="el" href="rte__ethdev_8h.html#a4834f572f4dd4e46d81ad09b7d5fffd5a294a2e1aecaf653e0edd9a421385acb0">RTE_ETH_MQ_TX_DCB</a>
, <a class="el" href="rte__ethdev_8h.html#a4834f572f4dd4e46d81ad09b7d5fffd5a335913388afb6743bf327782c6cf5a42">RTE_ETH_MQ_TX_VMDQ_DCB</a>
, <a class="el" href="rte__ethdev_8h.html#a4834f572f4dd4e46d81ad09b7d5fffd5a523c9fd4cae5bd8d0d019dc12e9bacb2">RTE_ETH_MQ_TX_VMDQ_ONLY</a>
 }</td></tr>
<tr class="separator:a4834f572f4dd4e46d81ad09b7d5fffd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c05489ea927eb7989108bf94b4f06f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ae8c05489ea927eb7989108bf94b4f06f">rte_vlan_type</a> {  }</td></tr>
<tr class="separator:ae8c05489ea927eb7989108bf94b4f06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb895db261266fa2a85cf518d007ed9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aecb895db261266fa2a85cf518d007ed9">rte_eth_hash_function</a> { <br />
&#160;&#160;<a class="el" href="rte__ethdev_8h.html#aecb895db261266fa2a85cf518d007ed9a2e12dcdea2601d69d9e15804243427f4">RTE_ETH_HASH_FUNCTION_DEFAULT</a> = 0
, <a class="el" href="rte__ethdev_8h.html#aecb895db261266fa2a85cf518d007ed9ad9ea5197524353c07c3b913d8243d156">RTE_ETH_HASH_FUNCTION_TOEPLITZ</a>
, <a class="el" href="rte__ethdev_8h.html#aecb895db261266fa2a85cf518d007ed9a6e24a99a6463e7f6c9ca54318824c797">RTE_ETH_HASH_FUNCTION_SIMPLE_XOR</a>
, <a class="el" href="rte__ethdev_8h.html#aecb895db261266fa2a85cf518d007ed9abe2d96db40e3d1b487f6be5b4cb486e5">RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ</a>
, <br />
&#160;&#160;<a class="el" href="rte__ethdev_8h.html#aecb895db261266fa2a85cf518d007ed9a46d887a01ec93e64a1a3f8f1e7969158">RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ_SORT</a>
, <b>RTE_ETH_HASH_FUNCTION_MAX</b>
<br />
 }</td></tr>
<tr class="separator:aecb895db261266fa2a85cf518d007ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb320893bc8887d4fa065488519edeeb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#afb320893bc8887d4fa065488519edeeb">rte_eth_nb_tcs</a> { <a class="el" href="rte__ethdev_8h.html#afb320893bc8887d4fa065488519edeeba114c88e340bb61bdebd1c16176a3f206">RTE_ETH_4_TCS</a> = 4
, <a class="el" href="rte__ethdev_8h.html#afb320893bc8887d4fa065488519edeeba2969d5b0d15006a4e05e2f49cbf37efa">RTE_ETH_8_TCS</a> = 8
 }</td></tr>
<tr class="separator:afb320893bc8887d4fa065488519edeeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012a874434677984af1f026ad585dd0d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a012a874434677984af1f026ad585dd0d">rte_eth_nb_pools</a> { <a class="el" href="rte__ethdev_8h.html#a012a874434677984af1f026ad585dd0da596c7fa9c2949232314a9bfb159e917e">RTE_ETH_8_POOLS</a> = 8
, <a class="el" href="rte__ethdev_8h.html#a012a874434677984af1f026ad585dd0dad5e8faa07e7524af675cbf8f22f6871a">RTE_ETH_16_POOLS</a> = 16
, <a class="el" href="rte__ethdev_8h.html#a012a874434677984af1f026ad585dd0da551250176fb51d1eee725c82d1c21aeb">RTE_ETH_32_POOLS</a> = 32
, <a class="el" href="rte__ethdev_8h.html#a012a874434677984af1f026ad585dd0da49d2ff63295c28fbaa46f14a888b178f">RTE_ETH_64_POOLS</a> = 64
 }</td></tr>
<tr class="separator:a012a874434677984af1f026ad585dd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9caad71a6958aaf72dfce61bac897ad3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a9caad71a6958aaf72dfce61bac897ad3">rte_eth_fc_mode</a> { <a class="el" href="rte__ethdev_8h.html#a9caad71a6958aaf72dfce61bac897ad3a60637133a72b1ae14c7e61d6944831b7">RTE_ETH_FC_NONE</a> = 0
, <a class="el" href="rte__ethdev_8h.html#a9caad71a6958aaf72dfce61bac897ad3a1bc46b2606b5a7f5d5ba331e80d7a8d5">RTE_ETH_FC_RX_PAUSE</a>
, <a class="el" href="rte__ethdev_8h.html#a9caad71a6958aaf72dfce61bac897ad3a184373388db933788c0725672dd4f5df">RTE_ETH_FC_TX_PAUSE</a>
, <a class="el" href="rte__ethdev_8h.html#a9caad71a6958aaf72dfce61bac897ad3af4cb6ec62485cd703e25f31e91408657">RTE_ETH_FC_FULL</a>
 }</td></tr>
<tr class="separator:a9caad71a6958aaf72dfce61bac897ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fa0fb1bfae6afc833bb38a82186f72"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a77fa0fb1bfae6afc833bb38a82186f72">rte_eth_tunnel_type</a> </td></tr>
<tr class="separator:a77fa0fb1bfae6afc833bb38a82186f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dedc2dcd96cb76abe4d81052c3fd78f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a5dedc2dcd96cb76abe4d81052c3fd78f">rte_eth_representor_type</a> { <a class="el" href="rte__ethdev_8h.html#a5dedc2dcd96cb76abe4d81052c3fd78fafbd2eb57b3dcffe9fdb080ed35f1cb48">RTE_ETH_REPRESENTOR_NONE</a>
, <a class="el" href="rte__ethdev_8h.html#a5dedc2dcd96cb76abe4d81052c3fd78fa990985066f385f9ece190fff6d64df5a">RTE_ETH_REPRESENTOR_VF</a>
, <a class="el" href="rte__ethdev_8h.html#a5dedc2dcd96cb76abe4d81052c3fd78fa99c8f6c6751077e31444c9fcb5030a0d">RTE_ETH_REPRESENTOR_SF</a>
, <a class="el" href="rte__ethdev_8h.html#a5dedc2dcd96cb76abe4d81052c3fd78fa5b8188154513ceee15b854eb709da669">RTE_ETH_REPRESENTOR_PF</a>
 }</td></tr>
<tr class="separator:a5dedc2dcd96cb76abe4d81052c3fd78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435680ac5e5b6d7cdd569a6cad128040"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a435680ac5e5b6d7cdd569a6cad128040">rte_eth_err_handle_mode</a> { <a class="el" href="rte__ethdev_8h.html#a435680ac5e5b6d7cdd569a6cad128040ae9d6ea5b2bbc13fab6e7887a3936bfdd">RTE_ETH_ERROR_HANDLE_MODE_NONE</a>
, <a class="el" href="rte__ethdev_8h.html#a435680ac5e5b6d7cdd569a6cad128040a0dcb9d56206617105113f1ee302d3a67">RTE_ETH_ERROR_HANDLE_MODE_PASSIVE</a>
, <a class="el" href="rte__ethdev_8h.html#a435680ac5e5b6d7cdd569a6cad128040af50d4c963339a498e0e89c59e705e9fb">RTE_ETH_ERROR_HANDLE_MODE_PROACTIVE</a>
 }</td></tr>
<tr class="separator:a435680ac5e5b6d7cdd569a6cad128040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb80537ae4bbec7d12870ff4c620e96"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a3fb80537ae4bbec7d12870ff4c620e96">rte_eth_fec_mode</a> { <br />
&#160;&#160;<a class="el" href="rte__ethdev_8h.html#a3fb80537ae4bbec7d12870ff4c620e96a004244bb807fadac186695a733470351">RTE_ETH_FEC_NOFEC</a> = 0
, <a class="el" href="rte__ethdev_8h.html#a3fb80537ae4bbec7d12870ff4c620e96ad0745f1f46edb7291856c304bcc6758d">RTE_ETH_FEC_AUTO</a>
, <a class="el" href="rte__ethdev_8h.html#a3fb80537ae4bbec7d12870ff4c620e96a032ce951079353d1e99acc5eae5f25fc">RTE_ETH_FEC_BASER</a>
, <a class="el" href="rte__ethdev_8h.html#a3fb80537ae4bbec7d12870ff4c620e96add58fbd4b98a82c9cdbf8f5ae93dba04">RTE_ETH_FEC_RS</a>
, <br />
&#160;&#160;<a class="el" href="rte__ethdev_8h.html#a3fb80537ae4bbec7d12870ff4c620e96af2b3d26203d2ff26c212d7d906e40278">RTE_ETH_FEC_LLRS</a>
<br />
 }</td></tr>
<tr class="separator:a3fb80537ae4bbec7d12870ff4c620e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ff25f28872830b629b52e5e12d8efa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a32ff25f28872830b629b52e5e12d8efa">rte_eth_dev_state</a> { <a class="el" href="rte__ethdev_8h.html#a32ff25f28872830b629b52e5e12d8efaa94ffb50804f8adc38f5a97d4bebb28fd">RTE_ETH_DEV_UNUSED</a> = 0
, <a class="el" href="rte__ethdev_8h.html#a32ff25f28872830b629b52e5e12d8efaa261626b3f24873374faa78d577a8ff23">RTE_ETH_DEV_ATTACHED</a>
, <a class="el" href="rte__ethdev_8h.html#a32ff25f28872830b629b52e5e12d8efaac4606e4f318a8ed36de5be444e75ac79">RTE_ETH_DEV_REMOVED</a>
 }</td></tr>
<tr class="separator:a32ff25f28872830b629b52e5e12d8efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183b2159da654a43eee045105cb8c04e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a183b2159da654a43eee045105cb8c04e">rte_eth_event_macsec_subtype</a> { <br />
&#160;&#160;<a class="el" href="rte__ethdev_8h.html#a183b2159da654a43eee045105cb8c04ea0a8ceba7187aeb48b303620664e425b4">RTE_ETH_SUBEVENT_MACSEC_UNKNOWN</a>
, <a class="el" href="rte__ethdev_8h.html#a183b2159da654a43eee045105cb8c04eafe00490ad8c3fd46008ac8986fe1e979">RTE_ETH_SUBEVENT_MACSEC_RX_SECTAG_V_EQ1</a>
, <a class="el" href="rte__ethdev_8h.html#a183b2159da654a43eee045105cb8c04ea5073a9cf34dc6e90b8894bb5c02c99d7">RTE_ETH_SUBEVENT_MACSEC_RX_SECTAG_E_EQ0_C_EQ1</a>
, <a class="el" href="rte__ethdev_8h.html#a183b2159da654a43eee045105cb8c04ea7913a4b4356fc60a6721ffb5a7730846">RTE_ETH_SUBEVENT_MACSEC_RX_SECTAG_SL_GTE48</a>
, <br />
&#160;&#160;<a class="el" href="rte__ethdev_8h.html#a183b2159da654a43eee045105cb8c04eae79ba30d5d59c0a8bab5f0fc83f175bd">RTE_ETH_SUBEVENT_MACSEC_RX_SECTAG_ES_EQ1_SC_EQ1</a>
, <a class="el" href="rte__ethdev_8h.html#a183b2159da654a43eee045105cb8c04eab3d8bf318e2d7af1aae55fd33d58822b">RTE_ETH_SUBEVENT_MACSEC_RX_SECTAG_SC_EQ1_SCB_EQ1</a>
<br />
 }</td></tr>
<tr class="separator:a183b2159da654a43eee045105cb8c04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6ffc5327f2a4070a9430244ff6d034"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a9d6ffc5327f2a4070a9430244ff6d034">rte_eth_event_macsec_type</a> { <br />
&#160;&#160;<a class="el" href="rte__ethdev_8h.html#a9d6ffc5327f2a4070a9430244ff6d034a6b05fb240c05ddd2c7898c85ba371396">RTE_ETH_EVENT_MACSEC_UNKNOWN</a>
, <a class="el" href="rte__ethdev_8h.html#a9d6ffc5327f2a4070a9430244ff6d034ad4913ef9e3dfd4aef0fed23496757977">RTE_ETH_EVENT_MACSEC_SECTAG_VAL_ERR</a>
, <a class="el" href="rte__ethdev_8h.html#a9d6ffc5327f2a4070a9430244ff6d034a256d97486afd4254ff6e84a288eb6660">RTE_ETH_EVENT_MACSEC_RX_SA_PN_HARD_EXP</a>
, <a class="el" href="rte__ethdev_8h.html#a9d6ffc5327f2a4070a9430244ff6d034a51070fa924c2db4dd4b06f2319b526ce">RTE_ETH_EVENT_MACSEC_RX_SA_PN_SOFT_EXP</a>
, <br />
&#160;&#160;<a class="el" href="rte__ethdev_8h.html#a9d6ffc5327f2a4070a9430244ff6d034a6df48b957550d4c38dbcde20cefe831a">RTE_ETH_EVENT_MACSEC_TX_SA_PN_HARD_EXP</a>
, <a class="el" href="rte__ethdev_8h.html#a9d6ffc5327f2a4070a9430244ff6d034adcfb4d9ef6bd3201cbc3d35af765cf4f">RTE_ETH_EVENT_MACSEC_TX_SA_PN_SOFT_EXP</a>
, <a class="el" href="rte__ethdev_8h.html#a9d6ffc5327f2a4070a9430244ff6d034a327231ad92a585489669705e7a6c358d">RTE_ETH_EVENT_MACSEC_SA_NOT_VALID</a>
<br />
 }</td></tr>
<tr class="separator:a9d6ffc5327f2a4070a9430244ff6d034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0449571f8fe2d8751f35999a5508f8be"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a0449571f8fe2d8751f35999a5508f8be">rte_eth_event_ipsec_subtype</a> { <br />
&#160;&#160;<a class="el" href="rte__ethdev_8h.html#a0449571f8fe2d8751f35999a5508f8beadc27e78ea9aa035fe2b596095311d68e">RTE_ETH_EVENT_IPSEC_PMD_ERROR_START</a> = -256
, <a class="el" href="rte__ethdev_8h.html#a0449571f8fe2d8751f35999a5508f8bea303e7b902b14ba261426c9d1026d4b97">RTE_ETH_EVENT_IPSEC_PMD_ERROR_END</a> = -1
, <a class="el" href="rte__ethdev_8h.html#a0449571f8fe2d8751f35999a5508f8bea34ce8f3e4773f164d07b1b814d5faad6">RTE_ETH_EVENT_IPSEC_UNKNOWN</a> = 0
, <a class="el" href="rte__ethdev_8h.html#a0449571f8fe2d8751f35999a5508f8beaa8bb18616ef0485c9fd7e493d6d909b2">RTE_ETH_EVENT_IPSEC_ESN_OVERFLOW</a>
, <br />
&#160;&#160;<a class="el" href="rte__ethdev_8h.html#a0449571f8fe2d8751f35999a5508f8beae7d1101a85e644b6dd96e24c12f6287d">RTE_ETH_EVENT_IPSEC_SA_TIME_EXPIRY</a>
, <a class="el" href="rte__ethdev_8h.html#a0449571f8fe2d8751f35999a5508f8beae20592d15276d5257d2ff81e4965b3ee">RTE_ETH_EVENT_IPSEC_SA_BYTE_EXPIRY</a>
, <a class="el" href="rte__ethdev_8h.html#a0449571f8fe2d8751f35999a5508f8bea68ec479f524f28701bac5682e32a6571">RTE_ETH_EVENT_IPSEC_SA_PKT_EXPIRY</a>
, <a class="el" href="rte__ethdev_8h.html#a0449571f8fe2d8751f35999a5508f8beaa9fbbc7302920c2ad74333b7c710e2e8">RTE_ETH_EVENT_IPSEC_SA_BYTE_HARD_EXPIRY</a>
, <br />
&#160;&#160;<a class="el" href="rte__ethdev_8h.html#a0449571f8fe2d8751f35999a5508f8beaf01b6dc325faabfc351214c9ab7df043">RTE_ETH_EVENT_IPSEC_SA_PKT_HARD_EXPIRY</a>
, <a class="el" href="rte__ethdev_8h.html#a0449571f8fe2d8751f35999a5508f8bea66a7ea9e93381cdf133f6bd86fbd85df">RTE_ETH_EVENT_IPSEC_MAX</a>
<br />
 }</td></tr>
<tr class="separator:a0449571f8fe2d8751f35999a5508f8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6788469a92700a583d06bf079d779d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779d">rte_eth_event_type</a> { <br />
&#160;&#160;<a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779da0da770e4c0207ac9c358c974ff830716">RTE_ETH_EVENT_UNKNOWN</a>
, <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779dad4b7ae5186810a8eacba937ac45d6a73">RTE_ETH_EVENT_INTR_LSC</a>
, <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779dad3ab0b7c29797255078c3fd482d432a0">RTE_ETH_EVENT_QUEUE_STATE</a>
, <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779da80601fd3050782eab6bfb77ab6083812">RTE_ETH_EVENT_INTR_RESET</a>
, <br />
&#160;&#160;<a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779da36a9f9b974cba6943252f3ff8563e067">RTE_ETH_EVENT_VF_MBOX</a>
, <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779dab7679227d47c8aa08acaba205ef95984">RTE_ETH_EVENT_MACSEC</a>
, <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779da811ea894a83a9295eea28602d87fcb0d">RTE_ETH_EVENT_INTR_RMV</a>
, <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779dafba97d8c075ab1b0ce5cbfe6d56cb333">RTE_ETH_EVENT_NEW</a>
, <br />
&#160;&#160;<a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779dac9662ab609834d045ae6d986d0c36fe7">RTE_ETH_EVENT_DESTROY</a>
, <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779da67808fda4e4561d661020bec76a67fdd">RTE_ETH_EVENT_IPSEC</a>
, <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779dacd52a236091fd2e0481093f36cff614b">RTE_ETH_EVENT_FLOW_AGED</a>
, <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779dafb35f538a637f0eb645556accae3ea20">RTE_ETH_EVENT_RX_AVAIL_THRESH</a>
, <br />
&#160;&#160;<a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779daab3a5e82ce678c742a12b7f3a546a151">RTE_ETH_EVENT_ERR_RECOVERING</a>
, <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779dac0a3e334f303b04a5635dcbae94ae8b7">RTE_ETH_EVENT_RECOVERY_SUCCESS</a>
, <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779da0a5042aef87f298ff87b336314bf0a8b">RTE_ETH_EVENT_RECOVERY_FAILED</a>
, <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779daf036573c1c236f5780892cb4fadaa7e6">RTE_ETH_EVENT_MAX</a>
<br />
 }</td></tr>
<tr class="separator:a1e6788469a92700a583d06bf079d779d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cf5a6087d1da0d510c87fce00db46a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a24cf5a6087d1da0d510c87fce00db46a">rte_eth_cman_obj</a> { <a class="el" href="rte__ethdev_8h.html#a24cf5a6087d1da0d510c87fce00db46aa67118f387d658085ef218f46c8db6699">RTE_ETH_CMAN_OBJ_RX_QUEUE</a> = RTE_BIT32(0)
, <a class="el" href="rte__ethdev_8h.html#a24cf5a6087d1da0d510c87fce00db46aa103584ec943f07d47d5e37c13675d3ae">RTE_ETH_CMAN_OBJ_RX_QUEUE_MEMPOOL</a> = RTE_BIT32(1)
 }</td></tr>
<tr class="separator:a24cf5a6087d1da0d510c87fce00db46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aab89ef2eba4241e67212196237807077"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aab89ef2eba4241e67212196237807077">rte_eth_iterator_init</a> (struct <a class="el" href="structrte__dev__iterator.html">rte_dev_iterator</a> *iter, const char *devargs)</td></tr>
<tr class="separator:aab89ef2eba4241e67212196237807077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c79e898a7391d9eae52e4b3ba1cb79"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a67c79e898a7391d9eae52e4b3ba1cb79">rte_eth_iterator_next</a> (struct <a class="el" href="structrte__dev__iterator.html">rte_dev_iterator</a> *iter)</td></tr>
<tr class="separator:a67c79e898a7391d9eae52e4b3ba1cb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101d4a079237de694871c688c547c85e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a101d4a079237de694871c688c547c85e">rte_eth_iterator_cleanup</a> (struct <a class="el" href="structrte__dev__iterator.html">rte_dev_iterator</a> *iter)</td></tr>
<tr class="separator:a101d4a079237de694871c688c547c85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c80e6e25ce9d6e8acd4e720cc64c36"><td class="memItemLeft" align="right" valign="top">__extension__ struct <a class="el" href="structrte__eth__link.html">rte_eth_link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad9c80e6e25ce9d6e8acd4e720cc64c36">__rte_aligned</a> (8)</td></tr>
<tr class="separator:ad9c80e6e25ce9d6e8acd4e720cc64c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb6f86407ad82bfa9ba884b81e4f33e"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a0bb6f86407ad82bfa9ba884b81e4f33e">rte_eth_rss_hf_refine</a> (uint64_t rss_hf)</td></tr>
<tr class="separator:a0bb6f86407ad82bfa9ba884b81e4f33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6a29579d85e90b52e629139144aebc"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a4b6a29579d85e90b52e629139144aebc">rte_eth_find_next_owned_by</a> (uint16_t port_id, const uint64_t owner_id)</td></tr>
<tr class="separator:a4b6a29579d85e90b52e629139144aebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572cbdd554578f35c4480f1397e7dea0"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a572cbdd554578f35c4480f1397e7dea0">rte_eth_find_next</a> (uint16_t port_id)</td></tr>
<tr class="separator:a572cbdd554578f35c4480f1397e7dea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67f6b336d3cd3f90cecc41e629ebbe1"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ae67f6b336d3cd3f90cecc41e629ebbe1">rte_eth_find_next_of</a> (uint16_t port_id_start, const struct rte_device *parent)</td></tr>
<tr class="separator:ae67f6b336d3cd3f90cecc41e629ebbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967a92a5681b48c414a6496d0e134789"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a967a92a5681b48c414a6496d0e134789">rte_eth_find_next_sibling</a> (uint16_t port_id_start, uint16_t ref_port_id)</td></tr>
<tr class="separator:a967a92a5681b48c414a6496d0e134789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6817cc801bf0faa566f52d382214457"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad6817cc801bf0faa566f52d382214457">rte_eth_dev_owner_new</a> (uint64_t *owner_id)</td></tr>
<tr class="separator:ad6817cc801bf0faa566f52d382214457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee73817b1baaea6da5bb5d4c18c578f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aaee73817b1baaea6da5bb5d4c18c578f">rte_eth_dev_owner_set</a> (const uint16_t port_id, const struct rte_eth_dev_owner *owner)</td></tr>
<tr class="separator:aaee73817b1baaea6da5bb5d4c18c578f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac333918086a96a28005ec8984d86f459"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac333918086a96a28005ec8984d86f459">rte_eth_dev_owner_unset</a> (const uint16_t port_id, const uint64_t owner_id)</td></tr>
<tr class="separator:ac333918086a96a28005ec8984d86f459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f344baaff829a27a0a46b8d1be93004"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a7f344baaff829a27a0a46b8d1be93004">rte_eth_dev_owner_delete</a> (const uint64_t owner_id)</td></tr>
<tr class="separator:a7f344baaff829a27a0a46b8d1be93004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37091b7824c8cf16b1a97c8befcd84fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a37091b7824c8cf16b1a97c8befcd84fd">rte_eth_dev_owner_get</a> (const uint16_t port_id, struct rte_eth_dev_owner *owner)</td></tr>
<tr class="separator:a37091b7824c8cf16b1a97c8befcd84fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab708089665bebcd65cefe5383b24f2"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a9ab708089665bebcd65cefe5383b24f2">rte_eth_dev_count_avail</a> (void)</td></tr>
<tr class="separator:a9ab708089665bebcd65cefe5383b24f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5929c07b0f1d3cb235784a6f33010f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aee5929c07b0f1d3cb235784a6f33010f">rte_eth_dev_count_total</a> (void)</td></tr>
<tr class="separator:aee5929c07b0f1d3cb235784a6f33010f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06b3f5253aaea7fa0efdef786ff44f2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ab06b3f5253aaea7fa0efdef786ff44f2">rte_eth_speed_bitflag</a> (uint32_t speed, int duplex)</td></tr>
<tr class="separator:ab06b3f5253aaea7fa0efdef786ff44f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f96cc61e41ad50346d0096c95053b0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad4f96cc61e41ad50346d0096c95053b0">rte_eth_dev_rx_offload_name</a> (uint64_t offload)</td></tr>
<tr class="separator:ad4f96cc61e41ad50346d0096c95053b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa034be0bc72cc626ade4094c036208f4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aa034be0bc72cc626ade4094c036208f4">rte_eth_dev_tx_offload_name</a> (uint64_t offload)</td></tr>
<tr class="separator:aa034be0bc72cc626ade4094c036208f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5224e542eb1ee1cde8848519da015bd2"><td class="memItemLeft" align="right" valign="top">__rte_experimental const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a5224e542eb1ee1cde8848519da015bd2">rte_eth_dev_capability_name</a> (uint64_t capability)</td></tr>
<tr class="separator:a5224e542eb1ee1cde8848519da015bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7d3a20b102fee222541fda50fd87bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure</a> (uint16_t port_id, uint16_t nb_rx_queue, uint16_t nb_tx_queue, const struct <a class="el" href="structrte__eth__conf.html">rte_eth_conf</a> *eth_conf)</td></tr>
<tr class="separator:a1a7d3a20b102fee222541fda50fd87bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e5d23e6c13b4f23d40c6c2067c1422"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a05e5d23e6c13b4f23d40c6c2067c1422">rte_eth_dev_is_removed</a> (uint16_t port_id)</td></tr>
<tr class="separator:a05e5d23e6c13b4f23d40c6c2067c1422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ba70a5a6fce2c2c1f774828ba78f8d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a36ba70a5a6fce2c2c1f774828ba78f8d">rte_eth_rx_queue_setup</a> (uint16_t port_id, uint16_t rx_queue_id, uint16_t nb_rx_desc, unsigned int socket_id, const struct <a class="el" href="structrte__eth__rxconf.html">rte_eth_rxconf</a> *rx_conf, struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mb_pool)</td></tr>
<tr class="separator:a36ba70a5a6fce2c2c1f774828ba78f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7297b36c033fbeaaae77d31de13cc4bc"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a7297b36c033fbeaaae77d31de13cc4bc">rte_eth_rx_hairpin_queue_setup</a> (uint16_t port_id, uint16_t rx_queue_id, uint16_t nb_rx_desc, const struct <a class="el" href="structrte__eth__hairpin__conf.html">rte_eth_hairpin_conf</a> *conf)</td></tr>
<tr class="separator:a7297b36c033fbeaaae77d31de13cc4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796c2f20778984c6f41b271e36bae50e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a796c2f20778984c6f41b271e36bae50e">rte_eth_tx_queue_setup</a> (uint16_t port_id, uint16_t tx_queue_id, uint16_t nb_tx_desc, unsigned int socket_id, const struct <a class="el" href="structrte__eth__txconf.html">rte_eth_txconf</a> *tx_conf)</td></tr>
<tr class="separator:a796c2f20778984c6f41b271e36bae50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd04b893212e9b643b8762344a97cf76"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#acd04b893212e9b643b8762344a97cf76">rte_eth_tx_hairpin_queue_setup</a> (uint16_t port_id, uint16_t tx_queue_id, uint16_t nb_tx_desc, const struct <a class="el" href="structrte__eth__hairpin__conf.html">rte_eth_hairpin_conf</a> *conf)</td></tr>
<tr class="separator:acd04b893212e9b643b8762344a97cf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30a9a81670bd4a24d2251dd39e17e94"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ab30a9a81670bd4a24d2251dd39e17e94">rte_eth_hairpin_get_peer_ports</a> (uint16_t port_id, uint16_t *peer_ports, size_t len, uint32_t direction)</td></tr>
<tr class="separator:ab30a9a81670bd4a24d2251dd39e17e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ff52a373e6d9ee2918771c96c5c1a0"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac2ff52a373e6d9ee2918771c96c5c1a0">rte_eth_hairpin_bind</a> (uint16_t tx_port, uint16_t rx_port)</td></tr>
<tr class="separator:ac2ff52a373e6d9ee2918771c96c5c1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d424a4ac069442011f8e7a2eb8cef8"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ab0d424a4ac069442011f8e7a2eb8cef8">rte_eth_hairpin_unbind</a> (uint16_t tx_port, uint16_t rx_port)</td></tr>
<tr class="separator:ab0d424a4ac069442011f8e7a2eb8cef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3152a1e9a531bb905ee7089343056d"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a3a3152a1e9a531bb905ee7089343056d">rte_eth_dev_count_aggr_ports</a> (uint16_t port_id)</td></tr>
<tr class="separator:a3a3152a1e9a531bb905ee7089343056d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7315efad73b17c7d11e36c23b6c29d"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a0d7315efad73b17c7d11e36c23b6c29d">rte_eth_dev_map_aggr_tx_affinity</a> (uint16_t port_id, uint16_t tx_queue_id, uint8_t affinity)</td></tr>
<tr class="separator:a0d7315efad73b17c7d11e36c23b6c29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad032e25f712e6ffeb0c19eab1ec1fd2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad032e25f712e6ffeb0c19eab1ec1fd2e">rte_eth_dev_socket_id</a> (uint16_t port_id)</td></tr>
<tr class="separator:ad032e25f712e6ffeb0c19eab1ec1fd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22dcfd3f5f2b34f657131d66132e23a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a22dcfd3f5f2b34f657131d66132e23a7">rte_eth_dev_is_valid_port</a> (uint16_t port_id)</td></tr>
<tr class="separator:a22dcfd3f5f2b34f657131d66132e23a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a6aad1fb6a064dd8d68cc1130831fe"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a80a6aad1fb6a064dd8d68cc1130831fe">rte_eth_rx_queue_is_valid</a> (uint16_t port_id, uint16_t queue_id)</td></tr>
<tr class="separator:a80a6aad1fb6a064dd8d68cc1130831fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39535037b46be766d961d58fd337841"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad39535037b46be766d961d58fd337841">rte_eth_tx_queue_is_valid</a> (uint16_t port_id, uint16_t queue_id)</td></tr>
<tr class="separator:ad39535037b46be766d961d58fd337841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde49b964009fcfdcab149ccc81d43d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#acde49b964009fcfdcab149ccc81d43d8">rte_eth_dev_rx_queue_start</a> (uint16_t port_id, uint16_t rx_queue_id)</td></tr>
<tr class="separator:acde49b964009fcfdcab149ccc81d43d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e11cec1cbed5a1f808e745fe441d24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af3e11cec1cbed5a1f808e745fe441d24">rte_eth_dev_rx_queue_stop</a> (uint16_t port_id, uint16_t rx_queue_id)</td></tr>
<tr class="separator:af3e11cec1cbed5a1f808e745fe441d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1524c8f84330b7ae60fb0ccd91bffd9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad1524c8f84330b7ae60fb0ccd91bffd9">rte_eth_dev_tx_queue_start</a> (uint16_t port_id, uint16_t tx_queue_id)</td></tr>
<tr class="separator:ad1524c8f84330b7ae60fb0ccd91bffd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5cfa35edda89bb3480d06ae32423dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a7d5cfa35edda89bb3480d06ae32423dd">rte_eth_dev_tx_queue_stop</a> (uint16_t port_id, uint16_t tx_queue_id)</td></tr>
<tr class="separator:a7d5cfa35edda89bb3480d06ae32423dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc834c1c52e9fb512301990468ca7c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#afdc834c1c52e9fb512301990468ca7c2">rte_eth_dev_start</a> (uint16_t port_id)</td></tr>
<tr class="separator:afdc834c1c52e9fb512301990468ca7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc010cf6216331c50bc02d2fd4e614f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a6fc010cf6216331c50bc02d2fd4e614f">rte_eth_dev_stop</a> (uint16_t port_id)</td></tr>
<tr class="separator:a6fc010cf6216331c50bc02d2fd4e614f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d7a0d2bb4202f9ebf9f174ba1f6e5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a51d7a0d2bb4202f9ebf9f174ba1f6e5c">rte_eth_dev_set_link_up</a> (uint16_t port_id)</td></tr>
<tr class="separator:a51d7a0d2bb4202f9ebf9f174ba1f6e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1447019543857c113d63a0f4ac7dd7c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a1447019543857c113d63a0f4ac7dd7c0">rte_eth_dev_set_link_down</a> (uint16_t port_id)</td></tr>
<tr class="separator:a1447019543857c113d63a0f4ac7dd7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c7507787a5520e8049fff94432169e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac2c7507787a5520e8049fff94432169e">rte_eth_dev_close</a> (uint16_t port_id)</td></tr>
<tr class="separator:ac2c7507787a5520e8049fff94432169e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1e21461d6316d4378e5b530c3e0ef9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a2d1e21461d6316d4378e5b530c3e0ef9">rte_eth_dev_reset</a> (uint16_t port_id)</td></tr>
<tr class="separator:a2d1e21461d6316d4378e5b530c3e0ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd1dedaa45f05c72bcc35495e441e91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a5dd1dedaa45f05c72bcc35495e441e91">rte_eth_promiscuous_enable</a> (uint16_t port_id)</td></tr>
<tr class="separator:a5dd1dedaa45f05c72bcc35495e441e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a39728529379b48f941f5d34f04d2bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a7a39728529379b48f941f5d34f04d2bd">rte_eth_promiscuous_disable</a> (uint16_t port_id)</td></tr>
<tr class="separator:a7a39728529379b48f941f5d34f04d2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499736f02d96faf9a680686a45d87ff9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a499736f02d96faf9a680686a45d87ff9">rte_eth_promiscuous_get</a> (uint16_t port_id)</td></tr>
<tr class="separator:a499736f02d96faf9a680686a45d87ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da07e7e7f4fac5dbf46565be69626a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a5da07e7e7f4fac5dbf46565be69626a4">rte_eth_allmulticast_enable</a> (uint16_t port_id)</td></tr>
<tr class="separator:a5da07e7e7f4fac5dbf46565be69626a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe97cde3f374385ef0b12f61e7c30da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a2fe97cde3f374385ef0b12f61e7c30da">rte_eth_allmulticast_disable</a> (uint16_t port_id)</td></tr>
<tr class="separator:a2fe97cde3f374385ef0b12f61e7c30da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b46977383aa660990df9c76892ec82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a59b46977383aa660990df9c76892ec82">rte_eth_allmulticast_get</a> (uint16_t port_id)</td></tr>
<tr class="separator:a59b46977383aa660990df9c76892ec82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56200b0c25f3ecab5abe9bd2b647c215"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a56200b0c25f3ecab5abe9bd2b647c215">rte_eth_link_get</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__link.html">rte_eth_link</a> *link)</td></tr>
<tr class="separator:a56200b0c25f3ecab5abe9bd2b647c215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1263899f41301923c483c3b4ce0486f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad1263899f41301923c483c3b4ce0486f">rte_eth_link_get_nowait</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__link.html">rte_eth_link</a> *link)</td></tr>
<tr class="separator:ad1263899f41301923c483c3b4ce0486f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8a6c56c3b7c65fa4cabf1d1106fdc7"><td class="memItemLeft" align="right" valign="top">__rte_experimental const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ade8a6c56c3b7c65fa4cabf1d1106fdc7">rte_eth_link_speed_to_str</a> (uint32_t <a class="el" href="rte__ethdev_8h.html#aae24fc4f200e75aa8215f797b2561dbf">link_speed</a>)</td></tr>
<tr class="separator:ade8a6c56c3b7c65fa4cabf1d1106fdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f51139368b8d1a2c22fdecd90bc4d98"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a5f51139368b8d1a2c22fdecd90bc4d98">rte_eth_link_to_str</a> (char *str, size_t len, const struct <a class="el" href="structrte__eth__link.html">rte_eth_link</a> *eth_link)</td></tr>
<tr class="separator:a5f51139368b8d1a2c22fdecd90bc4d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec226574c53ae413252c9b15f6f4bab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#adec226574c53ae413252c9b15f6f4bab">rte_eth_stats_get</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__stats.html">rte_eth_stats</a> *stats)</td></tr>
<tr class="separator:adec226574c53ae413252c9b15f6f4bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ff61eaf3b5bd61fe10923e406298ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af3ff61eaf3b5bd61fe10923e406298ed">rte_eth_stats_reset</a> (uint16_t port_id)</td></tr>
<tr class="separator:af3ff61eaf3b5bd61fe10923e406298ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418ad970673eb171673185e36044fd79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a418ad970673eb171673185e36044fd79">rte_eth_xstats_get_names</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__xstat__name.html">rte_eth_xstat_name</a> *xstats_names, unsigned int size)</td></tr>
<tr class="separator:a418ad970673eb171673185e36044fd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300d75b583c1f5acfe5b162a5d8c0ac1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a300d75b583c1f5acfe5b162a5d8c0ac1">rte_eth_xstats_get</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__xstat.html">rte_eth_xstat</a> *xstats, unsigned int n)</td></tr>
<tr class="separator:a300d75b583c1f5acfe5b162a5d8c0ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a53393e74caa397ca60d87a7bb8cce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a90a53393e74caa397ca60d87a7bb8cce">rte_eth_xstats_get_names_by_id</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__xstat__name.html">rte_eth_xstat_name</a> *xstats_names, unsigned int size, uint64_t *ids)</td></tr>
<tr class="separator:a90a53393e74caa397ca60d87a7bb8cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a69960b27a4c949dc85edbeb6966565"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a5a69960b27a4c949dc85edbeb6966565">rte_eth_xstats_get_by_id</a> (uint16_t port_id, const uint64_t *ids, uint64_t *values, unsigned int size)</td></tr>
<tr class="separator:a5a69960b27a4c949dc85edbeb6966565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab128d376f5f713e8fea10090b31e2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a9ab128d376f5f713e8fea10090b31e2c">rte_eth_xstats_get_id_by_name</a> (uint16_t port_id, const char *xstat_name, uint64_t *id)</td></tr>
<tr class="separator:a9ab128d376f5f713e8fea10090b31e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7f377b013951b8446bba9449cae626"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#add7f377b013951b8446bba9449cae626">rte_eth_xstats_reset</a> (uint16_t port_id)</td></tr>
<tr class="separator:add7f377b013951b8446bba9449cae626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fae7e398b289f795a1b6256149c4f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a56fae7e398b289f795a1b6256149c4f3">rte_eth_dev_set_tx_queue_stats_mapping</a> (uint16_t port_id, uint16_t tx_queue_id, uint8_t stat_idx)</td></tr>
<tr class="separator:a56fae7e398b289f795a1b6256149c4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a2d29926171cb3876546ec9fe6efae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af5a2d29926171cb3876546ec9fe6efae">rte_eth_dev_set_rx_queue_stats_mapping</a> (uint16_t port_id, uint16_t rx_queue_id, uint8_t stat_idx)</td></tr>
<tr class="separator:af5a2d29926171cb3876546ec9fe6efae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a28375b279ded9125c99a46bf3956ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a8a28375b279ded9125c99a46bf3956ef">rte_eth_macaddr_get</a> (uint16_t port_id, struct <a class="el" href="structrte__ether__addr.html">rte_ether_addr</a> *mac_addr)</td></tr>
<tr class="separator:a8a28375b279ded9125c99a46bf3956ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb00fa523b8718cdd0a4ac9e41d66ffa"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aeb00fa523b8718cdd0a4ac9e41d66ffa">rte_eth_macaddrs_get</a> (uint16_t port_id, struct <a class="el" href="structrte__ether__addr.html">rte_ether_addr</a> *ma, unsigned int num)</td></tr>
<tr class="separator:aeb00fa523b8718cdd0a4ac9e41d66ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7593f4fff04f4ae1b1d718db7ca7dc8c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a7593f4fff04f4ae1b1d718db7ca7dc8c">rte_eth_dev_info_get</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__dev__info.html">rte_eth_dev_info</a> *dev_info)</td></tr>
<tr class="separator:a7593f4fff04f4ae1b1d718db7ca7dc8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4ca98a91959125ad83bdbbae1f3b09"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aca4ca98a91959125ad83bdbbae1f3b09">rte_eth_dev_conf_get</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__conf.html">rte_eth_conf</a> *dev_conf)</td></tr>
<tr class="separator:aca4ca98a91959125ad83bdbbae1f3b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4756122298bd756c4d7171579f77be95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a4756122298bd756c4d7171579f77be95">rte_eth_dev_fw_version_get</a> (uint16_t port_id, char *fw_version, size_t fw_size)</td></tr>
<tr class="separator:a4756122298bd756c4d7171579f77be95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63202d322632467f9cc5fc460e04ea4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aa63202d322632467f9cc5fc460e04ea4">rte_eth_dev_get_supported_ptypes</a> (uint16_t port_id, uint32_t ptype_mask, uint32_t *ptypes, int num)</td></tr>
<tr class="separator:aa63202d322632467f9cc5fc460e04ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7266b14734c87b387c654ff2fdd2b33"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad7266b14734c87b387c654ff2fdd2b33">rte_eth_dev_set_ptypes</a> (uint16_t port_id, uint32_t ptype_mask, uint32_t *set_ptypes, unsigned int num)</td></tr>
<tr class="separator:ad7266b14734c87b387c654ff2fdd2b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386c83c7cc16ec9886ecf2925e7be4a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a386c83c7cc16ec9886ecf2925e7be4a3">rte_eth_dev_get_mtu</a> (uint16_t port_id, uint16_t *mtu)</td></tr>
<tr class="separator:a386c83c7cc16ec9886ecf2925e7be4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f17597cea4652045427bb9f81e46366"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a8f17597cea4652045427bb9f81e46366">rte_eth_dev_set_mtu</a> (uint16_t port_id, uint16_t mtu)</td></tr>
<tr class="separator:a8f17597cea4652045427bb9f81e46366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642f58ba9a5848a12acb18f2d7f296e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a642f58ba9a5848a12acb18f2d7f296e1">rte_eth_dev_vlan_filter</a> (uint16_t port_id, uint16_t vlan_id, int on)</td></tr>
<tr class="separator:a642f58ba9a5848a12acb18f2d7f296e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc1b487a103817c6d19bfa8b291b84b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a6bc1b487a103817c6d19bfa8b291b84b">rte_eth_dev_set_vlan_strip_on_queue</a> (uint16_t port_id, uint16_t rx_queue_id, int on)</td></tr>
<tr class="separator:a6bc1b487a103817c6d19bfa8b291b84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e531f8e53c6bcded644ce496cfbf74a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a6e531f8e53c6bcded644ce496cfbf74a">rte_eth_dev_set_vlan_ether_type</a> (uint16_t port_id, enum <a class="el" href="rte__ethdev_8h.html#ae8c05489ea927eb7989108bf94b4f06f">rte_vlan_type</a> vlan_type, uint16_t tag_type)</td></tr>
<tr class="separator:a6e531f8e53c6bcded644ce496cfbf74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a17c2c85724d5222ab137188599a28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a81a17c2c85724d5222ab137188599a28">rte_eth_dev_set_vlan_offload</a> (uint16_t port_id, int offload_mask)</td></tr>
<tr class="separator:a81a17c2c85724d5222ab137188599a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3260e2784aee53f93200c6f221abbba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ab3260e2784aee53f93200c6f221abbba">rte_eth_dev_get_vlan_offload</a> (uint16_t port_id)</td></tr>
<tr class="separator:ab3260e2784aee53f93200c6f221abbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c89d5cdec796fd46c64f1e80f1b454"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a81c89d5cdec796fd46c64f1e80f1b454">rte_eth_dev_set_vlan_pvid</a> (uint16_t port_id, uint16_t pvid, int on)</td></tr>
<tr class="separator:a81c89d5cdec796fd46c64f1e80f1b454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ccf6e8777792403520a976d2b5bda8"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aa3ccf6e8777792403520a976d2b5bda8">rte_eth_rx_avail_thresh_set</a> (uint16_t port_id, uint16_t queue_id, uint8_t avail_thresh)</td></tr>
<tr class="separator:aa3ccf6e8777792403520a976d2b5bda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b73e6191843b7920030a1bd28d02f0"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad8b73e6191843b7920030a1bd28d02f0">rte_eth_rx_avail_thresh_query</a> (uint16_t port_id, uint16_t *queue_id, uint8_t *avail_thresh)</td></tr>
<tr class="separator:ad8b73e6191843b7920030a1bd28d02f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5323444ecbe84309a5fcc03aa3c99cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac5323444ecbe84309a5fcc03aa3c99cb">rte_eth_tx_buffer_init</a> (struct <a class="el" href="structrte__eth__dev__tx__buffer.html">rte_eth_dev_tx_buffer</a> *buffer, uint16_t size)</td></tr>
<tr class="separator:ac5323444ecbe84309a5fcc03aa3c99cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd4952d9f45acd463e203c21db9a7bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aacd4952d9f45acd463e203c21db9a7bb">rte_eth_tx_buffer_set_err_callback</a> (struct <a class="el" href="structrte__eth__dev__tx__buffer.html">rte_eth_dev_tx_buffer</a> *buffer, buffer_tx_error_fn callback, void *userdata)</td></tr>
<tr class="separator:aacd4952d9f45acd463e203c21db9a7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbca22df1ad695663d271f9671811b3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#acbca22df1ad695663d271f9671811b3d">rte_eth_tx_buffer_drop_callback</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **pkts, uint16_t unsent, void *userdata)</td></tr>
<tr class="separator:acbca22df1ad695663d271f9671811b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e9cb28245ce5e06f6b2caf0506cf60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac2e9cb28245ce5e06f6b2caf0506cf60">rte_eth_tx_buffer_count_callback</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **pkts, uint16_t unsent, void *userdata)</td></tr>
<tr class="separator:ac2e9cb28245ce5e06f6b2caf0506cf60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d26dc7414a83a01c2a581f12a6c381"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a08d26dc7414a83a01c2a581f12a6c381">rte_eth_tx_done_cleanup</a> (uint16_t port_id, uint16_t queue_id, uint32_t free_cnt)</td></tr>
<tr class="separator:a08d26dc7414a83a01c2a581f12a6c381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0bef2920a6ade4041cab5103f4700d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac0bef2920a6ade4041cab5103f4700d9">rte_eth_dev_callback_register</a> (uint16_t port_id, enum <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779d">rte_eth_event_type</a> event, <a class="el" href="rte__ethdev_8h.html#a868605d09373258672f598e8bf4dab82">rte_eth_dev_cb_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="separator:ac0bef2920a6ade4041cab5103f4700d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac24c5a883555ffe08143ff8e277161"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a9ac24c5a883555ffe08143ff8e277161">rte_eth_dev_callback_unregister</a> (uint16_t port_id, enum <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779d">rte_eth_event_type</a> event, <a class="el" href="rte__ethdev_8h.html#a868605d09373258672f598e8bf4dab82">rte_eth_dev_cb_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="separator:a9ac24c5a883555ffe08143ff8e277161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88371c8cf4b2ec9e3e2e7c9adae2fe9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a88371c8cf4b2ec9e3e2e7c9adae2fe9a">rte_eth_dev_rx_intr_enable</a> (uint16_t port_id, uint16_t queue_id)</td></tr>
<tr class="separator:a88371c8cf4b2ec9e3e2e7c9adae2fe9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c30fbc44657558d5ebef03f6b6a8bbc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a7c30fbc44657558d5ebef03f6b6a8bbc">rte_eth_dev_rx_intr_disable</a> (uint16_t port_id, uint16_t queue_id)</td></tr>
<tr class="separator:a7c30fbc44657558d5ebef03f6b6a8bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd10b586923569451fd7370280e2a36d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#abd10b586923569451fd7370280e2a36d">rte_eth_dev_rx_intr_ctl</a> (uint16_t port_id, int epfd, int op, void *data)</td></tr>
<tr class="separator:abd10b586923569451fd7370280e2a36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b48c883e8e25f35a653aa88fbf5ae62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a1b48c883e8e25f35a653aa88fbf5ae62">rte_eth_dev_rx_intr_ctl_q</a> (uint16_t port_id, uint16_t queue_id, int epfd, int op, void *data)</td></tr>
<tr class="separator:a1b48c883e8e25f35a653aa88fbf5ae62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842134147a67ac903f9cfe0aeabf1064"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a842134147a67ac903f9cfe0aeabf1064">rte_eth_dev_rx_intr_ctl_q_get_fd</a> (uint16_t port_id, uint16_t queue_id)</td></tr>
<tr class="separator:a842134147a67ac903f9cfe0aeabf1064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbd0361b479f33762b4b24354f373f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a9fbd0361b479f33762b4b24354f373f1">rte_eth_led_on</a> (uint16_t port_id)</td></tr>
<tr class="separator:a9fbd0361b479f33762b4b24354f373f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0cb9d142d16d8b8cfe39aa4fb8a3c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a4c0cb9d142d16d8b8cfe39aa4fb8a3c0">rte_eth_led_off</a> (uint16_t port_id)</td></tr>
<tr class="separator:a4c0cb9d142d16d8b8cfe39aa4fb8a3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef356da666852b06301ab92f29098b5"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#afef356da666852b06301ab92f29098b5">rte_eth_fec_get_capability</a> (uint16_t port_id, struct rte_eth_fec_capa *speed_fec_capa, unsigned int num)</td></tr>
<tr class="separator:afef356da666852b06301ab92f29098b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1cfa84ae39dd8f878affd97339291c"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a9b1cfa84ae39dd8f878affd97339291c">rte_eth_fec_get</a> (uint16_t port_id, uint32_t *fec_capa)</td></tr>
<tr class="separator:a9b1cfa84ae39dd8f878affd97339291c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527bc13f6c7fada902cb598c050782ee"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a527bc13f6c7fada902cb598c050782ee">rte_eth_fec_set</a> (uint16_t port_id, uint32_t fec_capa)</td></tr>
<tr class="separator:a527bc13f6c7fada902cb598c050782ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511f239b9199de49474a5705ca0bdf27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a511f239b9199de49474a5705ca0bdf27">rte_eth_dev_flow_ctrl_get</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__fc__conf.html">rte_eth_fc_conf</a> *fc_conf)</td></tr>
<tr class="separator:a511f239b9199de49474a5705ca0bdf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abc01863cf282ac707faf4a2782392a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a3abc01863cf282ac707faf4a2782392a">rte_eth_dev_flow_ctrl_set</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__fc__conf.html">rte_eth_fc_conf</a> *fc_conf)</td></tr>
<tr class="separator:a3abc01863cf282ac707faf4a2782392a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e47e0d2a4837966f8d407bad03d29e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a63e47e0d2a4837966f8d407bad03d29e">rte_eth_dev_priority_flow_ctrl_set</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__pfc__conf.html">rte_eth_pfc_conf</a> *pfc_conf)</td></tr>
<tr class="separator:a63e47e0d2a4837966f8d407bad03d29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1a98a4ba67296647a29abb8cce1031"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aae1a98a4ba67296647a29abb8cce1031">rte_eth_dev_mac_addr_add</a> (uint16_t port_id, struct <a class="el" href="structrte__ether__addr.html">rte_ether_addr</a> *mac_addr, uint32_t pool)</td></tr>
<tr class="separator:aae1a98a4ba67296647a29abb8cce1031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d7805f7a401618814461ff3cfb4e94"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a91d7805f7a401618814461ff3cfb4e94">rte_eth_dev_priority_flow_ctrl_queue_info_get</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__pfc__queue__info.html">rte_eth_pfc_queue_info</a> *pfc_queue_info)</td></tr>
<tr class="separator:a91d7805f7a401618814461ff3cfb4e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2657f029c1e6a37b8ceccbf2f6dea26"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ab2657f029c1e6a37b8ceccbf2f6dea26">rte_eth_dev_priority_flow_ctrl_queue_configure</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__pfc__queue__conf.html">rte_eth_pfc_queue_conf</a> *pfc_queue_conf)</td></tr>
<tr class="separator:ab2657f029c1e6a37b8ceccbf2f6dea26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c7016e17fb74bbea305604b31356cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad8c7016e17fb74bbea305604b31356cc">rte_eth_dev_mac_addr_remove</a> (uint16_t port_id, struct <a class="el" href="structrte__ether__addr.html">rte_ether_addr</a> *mac_addr)</td></tr>
<tr class="separator:ad8c7016e17fb74bbea305604b31356cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1b91521b0308b3b462095e25ba521a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a8d1b91521b0308b3b462095e25ba521a">rte_eth_dev_default_mac_addr_set</a> (uint16_t port_id, struct <a class="el" href="structrte__ether__addr.html">rte_ether_addr</a> *mac_addr)</td></tr>
<tr class="separator:a8d1b91521b0308b3b462095e25ba521a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1540852c9cf1e576a883902c2e310d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a3c1540852c9cf1e576a883902c2e310d">rte_eth_dev_rss_reta_update</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__rss__reta__entry64.html">rte_eth_rss_reta_entry64</a> *reta_conf, uint16_t reta_size)</td></tr>
<tr class="separator:a3c1540852c9cf1e576a883902c2e310d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a22596cff13d0c2c777383a9043feb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aa0a22596cff13d0c2c777383a9043feb">rte_eth_dev_rss_reta_query</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__rss__reta__entry64.html">rte_eth_rss_reta_entry64</a> *reta_conf, uint16_t reta_size)</td></tr>
<tr class="separator:aa0a22596cff13d0c2c777383a9043feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec6ab973ff515cc8b07aaad2b3dddb8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aaec6ab973ff515cc8b07aaad2b3dddb8">rte_eth_dev_uc_hash_table_set</a> (uint16_t port_id, struct <a class="el" href="structrte__ether__addr.html">rte_ether_addr</a> *addr, uint8_t on)</td></tr>
<tr class="separator:aaec6ab973ff515cc8b07aaad2b3dddb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f0255ba0a08a74dcb0c1a5133ecaf3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a41f0255ba0a08a74dcb0c1a5133ecaf3">rte_eth_dev_uc_all_hash_table_set</a> (uint16_t port_id, uint8_t on)</td></tr>
<tr class="separator:a41f0255ba0a08a74dcb0c1a5133ecaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a43c745bd11679ad3cf736317a84aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ae0a43c745bd11679ad3cf736317a84aa">rte_eth_set_queue_rate_limit</a> (uint16_t port_id, uint16_t queue_idx, uint32_t tx_rate)</td></tr>
<tr class="separator:ae0a43c745bd11679ad3cf736317a84aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6461a60f6592292d398bbd87dbdebc4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad6461a60f6592292d398bbd87dbdebc4">rte_eth_dev_rss_hash_update</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__rss__conf.html">rte_eth_rss_conf</a> *rss_conf)</td></tr>
<tr class="separator:ad6461a60f6592292d398bbd87dbdebc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6000dca62f9815414b3f3b9c5d8be62f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a6000dca62f9815414b3f3b9c5d8be62f">rte_eth_dev_rss_hash_conf_get</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__rss__conf.html">rte_eth_rss_conf</a> *rss_conf)</td></tr>
<tr class="separator:a6000dca62f9815414b3f3b9c5d8be62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9b5de44a82809e291f6a2b4753ad7e"><td class="memItemLeft" align="right" valign="top">__rte_experimental const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#acd9b5de44a82809e291f6a2b4753ad7e">rte_eth_dev_rss_algo_name</a> (enum <a class="el" href="rte__ethdev_8h.html#aecb895db261266fa2a85cf518d007ed9">rte_eth_hash_function</a> rss_algo)</td></tr>
<tr class="separator:acd9b5de44a82809e291f6a2b4753ad7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6455af7a0ed7d417d443984181045464"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a6455af7a0ed7d417d443984181045464">rte_eth_dev_udp_tunnel_port_add</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__udp__tunnel.html">rte_eth_udp_tunnel</a> *tunnel_udp)</td></tr>
<tr class="separator:a6455af7a0ed7d417d443984181045464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49d9cf227f6190c502dfc53e6953d2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac49d9cf227f6190c502dfc53e6953d2d">rte_eth_dev_udp_tunnel_port_delete</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__udp__tunnel.html">rte_eth_udp_tunnel</a> *tunnel_udp)</td></tr>
<tr class="separator:ac49d9cf227f6190c502dfc53e6953d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d0e47c19784b52b5f711dcc5088ce6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad5d0e47c19784b52b5f711dcc5088ce6">rte_eth_dev_get_dcb_info</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__dcb__info.html">rte_eth_dcb_info</a> *dcb_info)</td></tr>
<tr class="separator:ad5d0e47c19784b52b5f711dcc5088ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb70723c985c3ea177591b67cfc49178"><td class="memItemLeft" align="right" valign="top">const struct rte_eth_rxtx_callback *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#adb70723c985c3ea177591b67cfc49178">rte_eth_add_rx_callback</a> (uint16_t port_id, uint16_t queue_id, <a class="el" href="rte__ethdev_8h.html#a7400438ebc28f2343aa0453ad5a4a021">rte_rx_callback_fn</a> fn, void *user_param)</td></tr>
<tr class="separator:adb70723c985c3ea177591b67cfc49178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4797e1f9ba75064bf0fbc4db8826d2f3"><td class="memItemLeft" align="right" valign="top">const struct rte_eth_rxtx_callback *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a4797e1f9ba75064bf0fbc4db8826d2f3">rte_eth_add_first_rx_callback</a> (uint16_t port_id, uint16_t queue_id, <a class="el" href="rte__ethdev_8h.html#a7400438ebc28f2343aa0453ad5a4a021">rte_rx_callback_fn</a> fn, void *user_param)</td></tr>
<tr class="separator:a4797e1f9ba75064bf0fbc4db8826d2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1880bf92c5e7d1d6901807a431024490"><td class="memItemLeft" align="right" valign="top">const struct rte_eth_rxtx_callback *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a1880bf92c5e7d1d6901807a431024490">rte_eth_add_tx_callback</a> (uint16_t port_id, uint16_t queue_id, <a class="el" href="rte__ethdev_8h.html#aeb995c6332dcda43bc0c551ea266d7fd">rte_tx_callback_fn</a> fn, void *user_param)</td></tr>
<tr class="separator:a1880bf92c5e7d1d6901807a431024490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b55620c8cafdbf383f24539ca8f01bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a7b55620c8cafdbf383f24539ca8f01bb">rte_eth_remove_rx_callback</a> (uint16_t port_id, uint16_t queue_id, const struct rte_eth_rxtx_callback *user_cb)</td></tr>
<tr class="separator:a7b55620c8cafdbf383f24539ca8f01bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60938179a2892235fd72f2827eacb2df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a60938179a2892235fd72f2827eacb2df">rte_eth_remove_tx_callback</a> (uint16_t port_id, uint16_t queue_id, const struct rte_eth_rxtx_callback *user_cb)</td></tr>
<tr class="separator:a60938179a2892235fd72f2827eacb2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6daa1713d569210c5ac4c8746b83169"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ab6daa1713d569210c5ac4c8746b83169">rte_eth_rx_queue_info_get</a> (uint16_t port_id, uint16_t queue_id, struct <a class="el" href="structrte__eth__rxq__info.html">rte_eth_rxq_info</a> *qinfo)</td></tr>
<tr class="separator:ab6daa1713d569210c5ac4c8746b83169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c6f6f02c73e5c67967c1106758ca9b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac3c6f6f02c73e5c67967c1106758ca9b">rte_eth_tx_queue_info_get</a> (uint16_t port_id, uint16_t queue_id, struct <a class="el" href="structrte__eth__txq__info.html">rte_eth_txq_info</a> *qinfo)</td></tr>
<tr class="separator:ac3c6f6f02c73e5c67967c1106758ca9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1e1119f0a009aa9cd952984c91c389"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a2b1e1119f0a009aa9cd952984c91c389">rte_eth_recycle_rx_queue_info_get</a> (uint16_t port_id, uint16_t queue_id, struct <a class="el" href="structrte__eth__recycle__rxq__info.html">rte_eth_recycle_rxq_info</a> *recycle_rxq_info)</td></tr>
<tr class="separator:a2b1e1119f0a009aa9cd952984c91c389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef67562b2fe058913e5b4e3d2611758"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a1ef67562b2fe058913e5b4e3d2611758">rte_eth_rx_burst_mode_get</a> (uint16_t port_id, uint16_t queue_id, struct <a class="el" href="structrte__eth__burst__mode.html">rte_eth_burst_mode</a> *mode)</td></tr>
<tr class="separator:a1ef67562b2fe058913e5b4e3d2611758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe833160a5ab1f0c5c9769da3624e3a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aabe833160a5ab1f0c5c9769da3624e3a">rte_eth_tx_burst_mode_get</a> (uint16_t port_id, uint16_t queue_id, struct <a class="el" href="structrte__eth__burst__mode.html">rte_eth_burst_mode</a> *mode)</td></tr>
<tr class="separator:aabe833160a5ab1f0c5c9769da3624e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3814d3730833ea325a299778f1440cf"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac3814d3730833ea325a299778f1440cf">rte_eth_get_monitor_addr</a> (uint16_t port_id, uint16_t queue_id, struct rte_power_monitor_cond *pmc)</td></tr>
<tr class="separator:ac3814d3730833ea325a299778f1440cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d10118286af88a01d3052e9b7ec400"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a00d10118286af88a01d3052e9b7ec400">rte_eth_dev_get_reg_info</a> (uint16_t port_id, struct rte_dev_reg_info *info)</td></tr>
<tr class="separator:a00d10118286af88a01d3052e9b7ec400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8866e436d02aa2d73da24857ef3d23fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a8866e436d02aa2d73da24857ef3d23fa">rte_eth_dev_get_eeprom_length</a> (uint16_t port_id)</td></tr>
<tr class="separator:a8866e436d02aa2d73da24857ef3d23fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6564843e5bdd9efcfb86376ea553972a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a6564843e5bdd9efcfb86376ea553972a">rte_eth_dev_get_eeprom</a> (uint16_t port_id, struct rte_dev_eeprom_info *info)</td></tr>
<tr class="separator:a6564843e5bdd9efcfb86376ea553972a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781645f3ba42b7e2abf8c1e649f932d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a781645f3ba42b7e2abf8c1e649f932d6">rte_eth_dev_set_eeprom</a> (uint16_t port_id, struct rte_dev_eeprom_info *info)</td></tr>
<tr class="separator:a781645f3ba42b7e2abf8c1e649f932d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f2748e0887b5528fda8b667dedae91"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a21f2748e0887b5528fda8b667dedae91">rte_eth_dev_get_module_info</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__dev__module__info.html">rte_eth_dev_module_info</a> *modinfo)</td></tr>
<tr class="separator:a21f2748e0887b5528fda8b667dedae91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba332478865156be084572b4893c0e9"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a6ba332478865156be084572b4893c0e9">rte_eth_dev_get_module_eeprom</a> (uint16_t port_id, struct rte_dev_eeprom_info *info)</td></tr>
<tr class="separator:a6ba332478865156be084572b4893c0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6d4ac37c4c3f2c25f97624a4ecad70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aab6d4ac37c4c3f2c25f97624a4ecad70">rte_eth_dev_set_mc_addr_list</a> (uint16_t port_id, struct <a class="el" href="structrte__ether__addr.html">rte_ether_addr</a> *mc_addr_set, uint32_t nb_mc_addr)</td></tr>
<tr class="separator:aab6d4ac37c4c3f2c25f97624a4ecad70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f45aabbfbb08ef986caddc70c48df4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a5f45aabbfbb08ef986caddc70c48df4c">rte_eth_timesync_enable</a> (uint16_t port_id)</td></tr>
<tr class="separator:a5f45aabbfbb08ef986caddc70c48df4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70953d8101144f803db78c2822a3dc37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a70953d8101144f803db78c2822a3dc37">rte_eth_timesync_disable</a> (uint16_t port_id)</td></tr>
<tr class="separator:a70953d8101144f803db78c2822a3dc37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2e742e5a9410b35def23d9c01ecd0f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a0b2e742e5a9410b35def23d9c01ecd0f">rte_eth_timesync_read_rx_timestamp</a> (uint16_t port_id, struct timespec *timestamp, uint32_t flags)</td></tr>
<tr class="separator:a0b2e742e5a9410b35def23d9c01ecd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42db8ae6951b141c67ae822c389197b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ae42db8ae6951b141c67ae822c389197b">rte_eth_timesync_read_tx_timestamp</a> (uint16_t port_id, struct timespec *timestamp)</td></tr>
<tr class="separator:ae42db8ae6951b141c67ae822c389197b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f941a2006073a1df36009b0956dad4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a12f941a2006073a1df36009b0956dad4">rte_eth_timesync_adjust_time</a> (uint16_t port_id, int64_t delta)</td></tr>
<tr class="separator:a12f941a2006073a1df36009b0956dad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7aaa6d846a6e71edb4f6c737cdf60c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad7aaa6d846a6e71edb4f6c737cdf60c7">rte_eth_timesync_read_time</a> (uint16_t port_id, struct timespec *time)</td></tr>
<tr class="separator:ad7aaa6d846a6e71edb4f6c737cdf60c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049d73092cce34847ea3653916cae41b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a049d73092cce34847ea3653916cae41b">rte_eth_timesync_write_time</a> (uint16_t port_id, const struct timespec *time)</td></tr>
<tr class="separator:a049d73092cce34847ea3653916cae41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4346bf07a0d302c9ba4fe06baffd3196"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a4346bf07a0d302c9ba4fe06baffd3196">rte_eth_read_clock</a> (uint16_t port_id, uint64_t *clock)</td></tr>
<tr class="separator:a4346bf07a0d302c9ba4fe06baffd3196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa972958b055560b44a6b2a38972d94c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aa972958b055560b44a6b2a38972d94c3">rte_eth_dev_get_port_by_name</a> (const char *name, uint16_t *port_id)</td></tr>
<tr class="separator:aa972958b055560b44a6b2a38972d94c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc43e2c17cd21cb3a27fbfc1d68f3a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aefc43e2c17cd21cb3a27fbfc1d68f3a1">rte_eth_dev_get_name_by_port</a> (uint16_t port_id, char *name)</td></tr>
<tr class="separator:aefc43e2c17cd21cb3a27fbfc1d68f3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31219b87a1733d5b367a7c04c7f7b48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad31219b87a1733d5b367a7c04c7f7b48">rte_eth_dev_adjust_nb_rx_tx_desc</a> (uint16_t port_id, uint16_t *nb_rx_desc, uint16_t *nb_tx_desc)</td></tr>
<tr class="separator:ad31219b87a1733d5b367a7c04c7f7b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab594dc8be07126874ef7139be51c8fde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ab594dc8be07126874ef7139be51c8fde">rte_eth_dev_pool_ops_supported</a> (uint16_t port_id, const char *pool)</td></tr>
<tr class="separator:ab594dc8be07126874ef7139be51c8fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539fa8ee80c94d538a42d951e4bcb00e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a539fa8ee80c94d538a42d951e4bcb00e">rte_eth_dev_get_sec_ctx</a> (uint16_t port_id)</td></tr>
<tr class="separator:a539fa8ee80c94d538a42d951e4bcb00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c8c334ea684ba08f052aa45735c917"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a07c8c334ea684ba08f052aa45735c917">rte_eth_dev_hairpin_capability_get</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__hairpin__cap.html">rte_eth_hairpin_cap</a> *cap)</td></tr>
<tr class="separator:a07c8c334ea684ba08f052aa45735c917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb24caf408218da527e40f4f89ccdaf"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#afcb24caf408218da527e40f4f89ccdaf">rte_eth_representor_info_get</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__representor__info.html">rte_eth_representor_info</a> *info)</td></tr>
<tr class="separator:afcb24caf408218da527e40f4f89ccdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db20d79921cad6ad83be1eea28cecee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a5db20d79921cad6ad83be1eea28cecee">rte_eth_rx_metadata_negotiate</a> (uint16_t port_id, uint64_t *features)</td></tr>
<tr class="separator:a5db20d79921cad6ad83be1eea28cecee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6897d12b08de1aa7a9a6336527bd4c1f"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a6897d12b08de1aa7a9a6336527bd4c1f">rte_eth_ip_reassembly_capability_get</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__ip__reassembly__params.html">rte_eth_ip_reassembly_params</a> *capa)</td></tr>
<tr class="separator:a6897d12b08de1aa7a9a6336527bd4c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33a29576956d540ecc6e9326389b22f"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac33a29576956d540ecc6e9326389b22f">rte_eth_ip_reassembly_conf_get</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__ip__reassembly__params.html">rte_eth_ip_reassembly_params</a> *conf)</td></tr>
<tr class="separator:ac33a29576956d540ecc6e9326389b22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3973f055a644c18206e2478842fa432"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aa3973f055a644c18206e2478842fa432">rte_eth_ip_reassembly_conf_set</a> (uint16_t port_id, const struct <a class="el" href="structrte__eth__ip__reassembly__params.html">rte_eth_ip_reassembly_params</a> *conf)</td></tr>
<tr class="separator:aa3973f055a644c18206e2478842fa432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc089b7ee8966e1b3ae367cb9694e3a"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a2cc089b7ee8966e1b3ae367cb9694e3a">rte_eth_dev_priv_dump</a> (uint16_t port_id, FILE *file)</td></tr>
<tr class="separator:a2cc089b7ee8966e1b3ae367cb9694e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8595c621f1443ce7b690362556cd8b69"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a8595c621f1443ce7b690362556cd8b69">rte_eth_rx_descriptor_dump</a> (uint16_t port_id, uint16_t queue_id, uint16_t offset, uint16_t num, FILE *file)</td></tr>
<tr class="separator:a8595c621f1443ce7b690362556cd8b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84ffcb6d9c042a5ebb1cc28e8ca4d8f"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac84ffcb6d9c042a5ebb1cc28e8ca4d8f">rte_eth_tx_descriptor_dump</a> (uint16_t port_id, uint16_t queue_id, uint16_t offset, uint16_t num, FILE *file)</td></tr>
<tr class="separator:ac84ffcb6d9c042a5ebb1cc28e8ca4d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86cc8371ee0ccd37de1aac86de2001c"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aa86cc8371ee0ccd37de1aac86de2001c">rte_eth_cman_info_get</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__cman__info.html">rte_eth_cman_info</a> *info)</td></tr>
<tr class="separator:aa86cc8371ee0ccd37de1aac86de2001c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3a8189e26117c3bb32a5f958f58f06"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#afb3a8189e26117c3bb32a5f958f58f06">rte_eth_cman_config_init</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__cman__config.html">rte_eth_cman_config</a> *config)</td></tr>
<tr class="separator:afb3a8189e26117c3bb32a5f958f58f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9071b6429e82b7540180f5dbbee4a01"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af9071b6429e82b7540180f5dbbee4a01">rte_eth_cman_config_set</a> (uint16_t port_id, const struct <a class="el" href="structrte__eth__cman__config.html">rte_eth_cman_config</a> *config)</td></tr>
<tr class="separator:af9071b6429e82b7540180f5dbbee4a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d4b5ac9ecaf8dec9c1471425476864"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a05d4b5ac9ecaf8dec9c1471425476864">rte_eth_cman_config_get</a> (uint16_t port_id, struct <a class="el" href="structrte__eth__cman__config.html">rte_eth_cman_config</a> *config)</td></tr>
<tr class="separator:a05d4b5ac9ecaf8dec9c1471425476864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7d76a451b46348686ea97d6367f102"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a3e7d76a451b46348686ea97d6367f102">rte_eth_rx_burst</a> (uint16_t port_id, uint16_t queue_id, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **rx_pkts, const uint16_t nb_pkts)</td></tr>
<tr class="separator:a3e7d76a451b46348686ea97d6367f102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e8c822c9c5f82879eb0c01ca50ea9c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af5e8c822c9c5f82879eb0c01ca50ea9c">rte_eth_rx_queue_count</a> (uint16_t port_id, uint16_t queue_id)</td></tr>
<tr class="separator:af5e8c822c9c5f82879eb0c01ca50ea9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3129ac553f76fd90d7e5eea46a63398"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad3129ac553f76fd90d7e5eea46a63398">rte_eth_rx_descriptor_status</a> (uint16_t port_id, uint16_t queue_id, uint16_t offset)</td></tr>
<tr class="separator:ad3129ac553f76fd90d7e5eea46a63398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43765b16539f14b46926235dccd0460"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad43765b16539f14b46926235dccd0460">rte_eth_tx_descriptor_status</a> (uint16_t port_id, uint16_t queue_id, uint16_t offset)</td></tr>
<tr class="separator:ad43765b16539f14b46926235dccd0460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e56cabbd31637efd648e3fc010392b"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a83e56cabbd31637efd648e3fc010392b">rte_eth_tx_burst</a> (uint16_t port_id, uint16_t queue_id, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **tx_pkts, uint16_t nb_pkts)</td></tr>
<tr class="separator:a83e56cabbd31637efd648e3fc010392b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ff3eecd29f6c2f26793bec8c2ecff6"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a76ff3eecd29f6c2f26793bec8c2ecff6">rte_eth_tx_prepare</a> (uint16_t port_id, uint16_t queue_id, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **tx_pkts, uint16_t nb_pkts)</td></tr>
<tr class="separator:a76ff3eecd29f6c2f26793bec8c2ecff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8779bcecccb86c94ce3638f35c9254"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ace8779bcecccb86c94ce3638f35c9254">rte_eth_tx_buffer_flush</a> (uint16_t port_id, uint16_t queue_id, struct <a class="el" href="structrte__eth__dev__tx__buffer.html">rte_eth_dev_tx_buffer</a> *buffer)</td></tr>
<tr class="separator:ace8779bcecccb86c94ce3638f35c9254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e941a74ae1b1b886764bc282458d946"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a0e941a74ae1b1b886764bc282458d946">rte_eth_tx_buffer</a> (uint16_t port_id, uint16_t queue_id, struct <a class="el" href="structrte__eth__dev__tx__buffer.html">rte_eth_dev_tx_buffer</a> *buffer, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *tx_pkt)</td></tr>
<tr class="separator:a0e941a74ae1b1b886764bc282458d946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f3fc7c24dff3df06b2927d01b5339d"><td class="memItemLeft" align="right" valign="top">static __rte_experimental uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad5f3fc7c24dff3df06b2927d01b5339d">rte_eth_recycle_mbufs</a> (uint16_t rx_port_id, uint16_t rx_queue_id, uint16_t tx_port_id, uint16_t tx_queue_id, struct <a class="el" href="structrte__eth__recycle__rxq__info.html">rte_eth_recycle_rxq_info</a> *recycle_rxq_info)</td></tr>
<tr class="separator:ad5f3fc7c24dff3df06b2927d01b5339d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f7771caa2f14871b8d33571428a7d4"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a91f7771caa2f14871b8d33571428a7d4">rte_eth_buffer_split_get_supported_hdr_ptypes</a> (uint16_t port_id, uint32_t *ptypes, int num)</td></tr>
<tr class="separator:a91f7771caa2f14871b8d33571428a7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aae24fc4f200e75aa8215f797b2561dbf"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aae24fc4f200e75aa8215f797b2561dbf">link_speed</a></td></tr>
<tr class="separator:aae24fc4f200e75aa8215f797b2561dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9a73e9e688ae4d72cf319872c0bdf1"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a8a9a73e9e688ae4d72cf319872c0bdf1">link_duplex</a></td></tr>
<tr class="separator:a8a9a73e9e688ae4d72cf319872c0bdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab62bf07f7dec65838124372503f7d09"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aab62bf07f7dec65838124372503f7d09">link_autoneg</a></td></tr>
<tr class="separator:aab62bf07f7dec65838124372503f7d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226d9406cdd84b64b3c3701e5ab8be88"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a226d9406cdd84b64b3c3701e5ab8be88">link_status</a></td></tr>
<tr class="separator:a226d9406cdd84b64b3c3701e5ab8be88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE Ethernet Device API</p>
<p>The Ethernet Device API is composed of two parts:</p>
<ul>
<li>The application-oriented Ethernet API that includes functions to setup an Ethernet device (configure it, setup its Rx and Tx queues and start it), to get its MAC address, the speed and the status of its physical link, to receive and to transmit packets, and so on.</li>
<li>The driver-oriented Ethernet API that exports functions allowing an Ethernet Poll Mode Driver (PMD) to allocate an Ethernet device instance, create memzone for HW rings and process registered callbacks, and so on. PMDs should include ethdev_driver.h instead of this header.</li>
</ul>
<p>By default, all the functions of the Ethernet Device API exported by a PMD are lock-free functions which assume to not be invoked in parallel on different logical cores to work on the same target object. For instance, the receive function of a PMD cannot be invoked in parallel on two logical cores to poll the same Rx queue [of the same port]. Of course, this function can be invoked in parallel by different logical cores on different Rx queues. It is the responsibility of the upper level application to enforce this rule.</p>
<p>If needed, parallel accesses by multiple logical cores to shared queues shall be explicitly protected by dedicated inline lock-aware functions built on top of their corresponding lock-free functions of the PMD API.</p>
<p>In all functions of the Ethernet API, the Ethernet device is designated by an integer &gt;= 0 named the device port identifier.</p>
<p>At the Ethernet driver level, Ethernet devices are represented by a generic data structure of type <em>rte_eth_dev</em>.</p>
<p>Ethernet devices are dynamically registered during the PCI probing phase performed at EAL initialization time. When an Ethernet device is being probed, an <em>rte_eth_dev</em> structure and a new port identifier are allocated for that device. Then, the eth_dev_init() function supplied by the Ethernet driver matching the probed PCI device is invoked to properly initialize the device.</p>
<p>The role of the device init function consists of resetting the hardware, checking access to Non-volatile Memory (NVM), reading the MAC address from NVM etc.</p>
<p>If the device init operation is successful, the correspondence between the port identifier assigned to the new device and its associated <em>rte_eth_dev</em> structure is effectively registered. Otherwise, both the <em>rte_eth_dev</em> structure and the port identifier are freed.</p>
<p>The functions exported by the application Ethernet API to setup a device designated by its port identifier must be invoked in the following order:</p><ul>
<li><a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a></li>
<li><a class="el" href="rte__ethdev_8h.html#a796c2f20778984c6f41b271e36bae50e">rte_eth_tx_queue_setup()</a></li>
<li><a class="el" href="rte__ethdev_8h.html#a36ba70a5a6fce2c2c1f774828ba78f8d">rte_eth_rx_queue_setup()</a></li>
<li><a class="el" href="rte__ethdev_8h.html#afdc834c1c52e9fb512301990468ca7c2">rte_eth_dev_start()</a></li>
</ul>
<p>Then, the network application can invoke, in any order, the functions exported by the Ethernet API to get the MAC address of a given device, to get the speed and the status of a device physical link, to receive/transmit [burst of] packets, and so on.</p>
<p>If the application wants to change the configuration (i.e. call <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>, <a class="el" href="rte__ethdev_8h.html#a796c2f20778984c6f41b271e36bae50e">rte_eth_tx_queue_setup()</a>, or <a class="el" href="rte__ethdev_8h.html#a36ba70a5a6fce2c2c1f774828ba78f8d">rte_eth_rx_queue_setup()</a>), it must call <a class="el" href="rte__ethdev_8h.html#a6fc010cf6216331c50bc02d2fd4e614f">rte_eth_dev_stop()</a> first to stop the device and then do the reconfiguration before calling <a class="el" href="rte__ethdev_8h.html#afdc834c1c52e9fb512301990468ca7c2">rte_eth_dev_start()</a> again. The transmit and receive functions should not be invoked when the device or the queue is stopped.</p>
<p>Please note that some configuration is not stored between calls to <a class="el" href="rte__ethdev_8h.html#a6fc010cf6216331c50bc02d2fd4e614f">rte_eth_dev_stop()</a>/rte_eth_dev_start(). The following configuration will be retained: </p><pre class="fragment">- MTU
- flow control settings
- receive mode configuration (promiscuous mode, all-multicast mode,
  hardware checksum mode, RSS/VMDq settings etc.)
- VLAN filtering configuration
- default MAC address
- MAC addresses supplied to MAC address array
- flow director filtering mode (but not filtering rules)
- NIC queue statistics mappings
</pre><p> The following configuration may be retained or not depending on the device capabilities: </p><pre class="fragment">- flow rules
- flow-related shared objects, e.g. indirect actions
</pre><p> Any other configuration will not be stored and will need to be re-entered before a call to <a class="el" href="rte__ethdev_8h.html#afdc834c1c52e9fb512301990468ca7c2">rte_eth_dev_start()</a>.</p>
<p>Finally, a network application can close an Ethernet device by invoking the <a class="el" href="rte__ethdev_8h.html#ac2c7507787a5520e8049fff94432169e">rte_eth_dev_close()</a> function.</p>
<p>Each function of the application Ethernet API invokes a specific function of the PMD that controls the target device designated by its port identifier. For this purpose, all device-specific functions of an Ethernet driver are supplied through a set of pointers contained in a generic structure of type <em>eth_dev_ops</em>. The address of the <em>eth_dev_ops</em> structure is stored in the <em>rte_eth_dev</em> structure by the device init function of the Ethernet driver, which is invoked during the PCI probing phase, as explained earlier.</p>
<p>In other words, each function of the Ethernet API simply retrieves the <em>rte_eth_dev</em> structure associated with the device port identifier and performs an indirect invocation of the corresponding driver function supplied in the <em>eth_dev_ops</em> structure of the <em>rte_eth_dev</em> structure.</p>
<p>For performance reasons, the address of the burst-oriented Rx and Tx functions of the Ethernet driver are not contained in the <em>eth_dev_ops</em> structure. Instead, they are directly stored at the beginning of the <em>rte_eth_dev</em> structure to avoid an extra indirect memory access during their invocation.</p>
<p>RTE Ethernet device drivers do not use interrupts for transmitting or receiving. Instead, Ethernet drivers export Poll-Mode receive and transmit functions to applications. Both receive and transmit functions are packet-burst oriented to minimize their cost per packet through the following optimizations:</p>
<ul>
<li>Sharing among multiple packets the incompressible cost of the invocation of receive/transmit functions.</li>
<li>Enabling receive/transmit functions to take advantage of burst-oriented hardware features (L1 cache, prefetch instructions, NIC head/tail registers) to minimize the number of CPU cycles per packet, for instance, by avoiding useless read memory accesses to ring descriptors, or by systematically using arrays of pointers that exactly fit L1 cache line boundaries and sizes.</li>
</ul>
<p>The burst-oriented receive function does not provide any error notification, to avoid the corresponding overhead. As a hint, the upper-level application might check the status of the device link once being systematically returned a 0 value by the receive function of the driver for a given number of tries. </p>

<p class="definition">Definition in file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ac5779482dfcd7e4a3d774b0da3e36641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5779482dfcd7e4a3d774b0da3e36641">&#9670;&nbsp;</a></span>RTE_ETH_FOREACH_MATCHING_DEV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_FOREACH_MATCHING_DEV</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">devargs, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iter&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<a class="code" href="rte__ethdev_8h.html#aab89ef2eba4241e67212196237807077">rte_eth_iterator_init</a>(iter, devargs), \</div>
<div class="line">         <span class="keywordtype">id</span> = <a class="code" href="rte__ethdev_8h.html#a67c79e898a7391d9eae52e4b3ba1cb79">rte_eth_iterator_next</a>(iter); \</div>
<div class="line">         id != RTE_MAX_ETHPORTS; \</div>
<div class="line">         id = <a class="code" href="rte__ethdev_8h.html#a67c79e898a7391d9eae52e4b3ba1cb79">rte_eth_iterator_next</a>(iter))</div>
<div class="ttc" id="arte__ethdev_8h_html_a67c79e898a7391d9eae52e4b3ba1cb79"><div class="ttname"><a href="rte__ethdev_8h.html#a67c79e898a7391d9eae52e4b3ba1cb79">rte_eth_iterator_next</a></div><div class="ttdeci">uint16_t rte_eth_iterator_next(struct rte_dev_iterator *iter)</div></div>
<div class="ttc" id="arte__ethdev_8h_html_aab89ef2eba4241e67212196237807077"><div class="ttname"><a href="rte__ethdev_8h.html#aab89ef2eba4241e67212196237807077">rte_eth_iterator_init</a></div><div class="ttdeci">int rte_eth_iterator_init(struct rte_dev_iterator *iter, const char *devargs)</div></div>
</div><!-- fragment --><p>Macro to iterate over all ethdev ports matching some devargs.</p>
<p>If a break is done before the end of the loop, the function <a class="el" href="rte__ethdev_8h.html#a101d4a079237de694871c688c547c85e">rte_eth_iterator_cleanup()</a> must be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Iterated port ID of type uint16_t. </td></tr>
    <tr><td class="paramname">devargs</td><td>Device parameters input as string of type char*. </td></tr>
    <tr><td class="paramname">iter</td><td>Iterator handle of type struct <a class="el" href="structrte__dev__iterator.html">rte_dev_iterator</a>, used internally. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00246">246</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a1016c5eb3a3e69ff6cbbcd0842e66d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1016c5eb3a3e69ff6cbbcd0842e66d94">&#9670;&nbsp;</a></span>RTE_ETH_LINK_SPEED_AUTONEG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_SPEED_AUTONEG&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Autonegotiate (all speeds) </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00290">290</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="ad0c8b245eca75f1784301ca309118799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c8b245eca75f1784301ca309118799">&#9670;&nbsp;</a></span>RTE_ETH_LINK_SPEED_FIXED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_SPEED_FIXED&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable autoneg (fixed speed) </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00291">291</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a58978c83b5797c529e1821eba0a56feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58978c83b5797c529e1821eba0a56feb">&#9670;&nbsp;</a></span>RTE_ETH_LINK_SPEED_10M_HD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_SPEED_10M_HD&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>10 Mbps half-duplex </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00292">292</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a25d06b2382de7110ba5e61da5bd1cc5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d06b2382de7110ba5e61da5bd1cc5f">&#9670;&nbsp;</a></span>RTE_ETH_LINK_SPEED_10M</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_SPEED_10M&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>10 Mbps full-duplex </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00293">293</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a21d828ff2e554c242e01115c0721d8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d828ff2e554c242e01115c0721d8fa">&#9670;&nbsp;</a></span>RTE_ETH_LINK_SPEED_100M_HD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_SPEED_100M_HD&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(3)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>100 Mbps half-duplex </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00294">294</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="abb9bc69e0715a6a94cfd03f95f0a694d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9bc69e0715a6a94cfd03f95f0a694d">&#9670;&nbsp;</a></span>RTE_ETH_LINK_SPEED_100M</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_SPEED_100M&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(4)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>100 Mbps full-duplex </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00295">295</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="ab77442a17c299185fbae87ac01442afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77442a17c299185fbae87ac01442afa">&#9670;&nbsp;</a></span>RTE_ETH_LINK_SPEED_1G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_SPEED_1G&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(5)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>1 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00296">296</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a5f5beb2c2d4dfc9d2be22a028c3e3be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5beb2c2d4dfc9d2be22a028c3e3be6">&#9670;&nbsp;</a></span>RTE_ETH_LINK_SPEED_2_5G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_SPEED_2_5G&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(6)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>2.5 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00297">297</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a47e322ee653d48456eab00371838691e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e322ee653d48456eab00371838691e">&#9670;&nbsp;</a></span>RTE_ETH_LINK_SPEED_5G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_SPEED_5G&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(7)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>5 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00298">298</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="aa934a67d656f06427696945a01295f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa934a67d656f06427696945a01295f1e">&#9670;&nbsp;</a></span>RTE_ETH_LINK_SPEED_10G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_SPEED_10G&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(8)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>10 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00299">299</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="abe583a91d5eecbf09cb0114006cf7d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe583a91d5eecbf09cb0114006cf7d4e">&#9670;&nbsp;</a></span>RTE_ETH_LINK_SPEED_20G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_SPEED_20G&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(9)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>20 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00300">300</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a02a282cfc405124977cb2503227d5c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a282cfc405124977cb2503227d5c83">&#9670;&nbsp;</a></span>RTE_ETH_LINK_SPEED_25G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_SPEED_25G&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(10)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>25 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00301">301</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a18082b3ff6da3c599073e38233f94e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18082b3ff6da3c599073e38233f94e80">&#9670;&nbsp;</a></span>RTE_ETH_LINK_SPEED_40G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_SPEED_40G&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(11)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>40 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00302">302</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a4800ebca83ac27cb46bbe74098206682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4800ebca83ac27cb46bbe74098206682">&#9670;&nbsp;</a></span>RTE_ETH_LINK_SPEED_50G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_SPEED_50G&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(12)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>50 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00303">303</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="aa664a99f449d71f85a116878b216561b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa664a99f449d71f85a116878b216561b">&#9670;&nbsp;</a></span>RTE_ETH_LINK_SPEED_56G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_SPEED_56G&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(13)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>56 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00304">304</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a183a5166614b4a20de1e09c6615f6570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183a5166614b4a20de1e09c6615f6570">&#9670;&nbsp;</a></span>RTE_ETH_LINK_SPEED_100G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_SPEED_100G&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(14)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>100 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00305">305</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a21b97fe70c3dc9cab51e48db839450af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b97fe70c3dc9cab51e48db839450af">&#9670;&nbsp;</a></span>RTE_ETH_LINK_SPEED_200G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_SPEED_200G&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(15)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>200 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00306">306</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a196131c6a97096a6d23e441c6852a570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196131c6a97096a6d23e441c6852a570">&#9670;&nbsp;</a></span>RTE_ETH_LINK_SPEED_400G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_SPEED_400G&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(16)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>400 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00307">307</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a097f6c3ec66c069623dbaafc4f21f1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a097f6c3ec66c069623dbaafc4f21f1b6">&#9670;&nbsp;</a></span>RTE_ETH_SPEED_NUM_NONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_SPEED_NUM_NONE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Not defined </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00313">313</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a38cc9e26fe0b2c33cf7ded660961c22c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38cc9e26fe0b2c33cf7ded660961c22c">&#9670;&nbsp;</a></span>RTE_ETH_SPEED_NUM_10M</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_SPEED_NUM_10M&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>10 Mbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00314">314</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a591107c9b175ff8b4b160fdb258f55fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591107c9b175ff8b4b160fdb258f55fd">&#9670;&nbsp;</a></span>RTE_ETH_SPEED_NUM_100M</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_SPEED_NUM_100M&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>100 Mbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00315">315</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a3112616e5f27ada75c527d338ab49a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3112616e5f27ada75c527d338ab49a9d">&#9670;&nbsp;</a></span>RTE_ETH_SPEED_NUM_1G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_SPEED_NUM_1G&#160;&#160;&#160;1000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>1 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00316">316</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a588aa1584f250ded024807cf1d2be85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588aa1584f250ded024807cf1d2be85e">&#9670;&nbsp;</a></span>RTE_ETH_SPEED_NUM_2_5G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_SPEED_NUM_2_5G&#160;&#160;&#160;2500</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>2.5 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00317">317</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a12739ac2400dd43b71317be35756e0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12739ac2400dd43b71317be35756e0f2">&#9670;&nbsp;</a></span>RTE_ETH_SPEED_NUM_5G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_SPEED_NUM_5G&#160;&#160;&#160;5000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>5 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00318">318</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="aafb91534e3e4fd48d1beb52c73c41966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb91534e3e4fd48d1beb52c73c41966">&#9670;&nbsp;</a></span>RTE_ETH_SPEED_NUM_10G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_SPEED_NUM_10G&#160;&#160;&#160;10000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>10 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00319">319</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="acae910660c8241d69b01b180a192d488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae910660c8241d69b01b180a192d488">&#9670;&nbsp;</a></span>RTE_ETH_SPEED_NUM_20G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_SPEED_NUM_20G&#160;&#160;&#160;20000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>20 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00320">320</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="acd96aae4d2e1eb2bfcf60e22c0903c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd96aae4d2e1eb2bfcf60e22c0903c6a">&#9670;&nbsp;</a></span>RTE_ETH_SPEED_NUM_25G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_SPEED_NUM_25G&#160;&#160;&#160;25000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>25 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00321">321</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a36b0369044e83603bc88aadd0070a382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b0369044e83603bc88aadd0070a382">&#9670;&nbsp;</a></span>RTE_ETH_SPEED_NUM_40G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_SPEED_NUM_40G&#160;&#160;&#160;40000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>40 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00322">322</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a95c33b0f2782e591a0ab8675bd3865eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c33b0f2782e591a0ab8675bd3865eb">&#9670;&nbsp;</a></span>RTE_ETH_SPEED_NUM_50G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_SPEED_NUM_50G&#160;&#160;&#160;50000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>50 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00323">323</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="afd8b034a24123458db37bd831c495fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8b034a24123458db37bd831c495fee">&#9670;&nbsp;</a></span>RTE_ETH_SPEED_NUM_56G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_SPEED_NUM_56G&#160;&#160;&#160;56000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>56 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00324">324</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="ae6de23b6918f91776bcdd9c19408e35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6de23b6918f91776bcdd9c19408e35e">&#9670;&nbsp;</a></span>RTE_ETH_SPEED_NUM_100G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_SPEED_NUM_100G&#160;&#160;&#160;100000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>100 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00325">325</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a82ac73559e9edd2ffebd3bbc3a7a5dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ac73559e9edd2ffebd3bbc3a7a5dfc">&#9670;&nbsp;</a></span>RTE_ETH_SPEED_NUM_200G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_SPEED_NUM_200G&#160;&#160;&#160;200000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>200 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00326">326</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a92ea70b3e476b9eb5924da0838f82f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ea70b3e476b9eb5924da0838f82f6e">&#9670;&nbsp;</a></span>RTE_ETH_SPEED_NUM_400G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_SPEED_NUM_400G&#160;&#160;&#160;400000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>400 Gbps </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00327">327</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a5542082799b1410125eab256b2711002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5542082799b1410125eab256b2711002">&#9670;&nbsp;</a></span>RTE_ETH_SPEED_NUM_UNKNOWN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_SPEED_NUM_UNKNOWN&#160;&#160;&#160;UINT32_MAX</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unknown </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00328">328</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="ac41ad0dab3e7aa7934e9c7ffa3f61bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41ad0dab3e7aa7934e9c7ffa3f61bac">&#9670;&nbsp;</a></span>RTE_ETH_LINK_HALF_DUPLEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_HALF_DUPLEX&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Half-duplex connection (see link_duplex). </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00345">345</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a1c0da1e11afe4fbc233bb5454145100c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0da1e11afe4fbc233bb5454145100c">&#9670;&nbsp;</a></span>RTE_ETH_LINK_FULL_DUPLEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_FULL_DUPLEX&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Full-duplex connection (see link_duplex). </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00346">346</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a25dcf5d88b202ce0d25d389459f0b009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25dcf5d88b202ce0d25d389459f0b009">&#9670;&nbsp;</a></span>RTE_ETH_LINK_DOWN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_DOWN&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Link is down (see link_status). </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a61">examples/ipv4_multicast/main.c</a>, and <a class="el" href="examples_2syntony_2main_8c-example.html#a61">examples/syntony/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00347">347</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a47a679c23f624fdace0170488179cf8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a679c23f624fdace0170488179cf8b">&#9670;&nbsp;</a></span>RTE_ETH_LINK_UP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_UP&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Link is up (see link_status). </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00348">348</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a95f6e2279cf7fc9dafdea87644d3fc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f6e2279cf7fc9dafdea87644d3fc11">&#9670;&nbsp;</a></span>RTE_ETH_LINK_FIXED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_FIXED&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>No autonegotiation (see link_autoneg). </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00349">349</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="aa84c533bcaf2a4a03a2d013fb39c7608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84c533bcaf2a4a03a2d013fb39c7608">&#9670;&nbsp;</a></span>RTE_ETH_LINK_AUTONEG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_AUTONEG&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Autonegotiated (see link_autoneg). </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00350">350</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a7a31d6736244603b6a1d7efdd32a8834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a31d6736244603b6a1d7efdd32a8834">&#9670;&nbsp;</a></span>RTE_ETH_LINK_MAX_STR_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_LINK_MAX_STR_LEN&#160;&#160;&#160;40</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max length of default link string. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a56">examples/ipv4_multicast/main.c</a>, and <a class="el" href="examples_2syntony_2main_8c-example.html#a56">examples/syntony/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00351">351</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="ab3f9dff54f4b62c055037c14192f3ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f9dff54f4b62c055037c14192f3ac4">&#9670;&nbsp;</a></span>RTE_ETH_MQ_RX_RSS_FLAG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_MQ_RX_RSS_FLAG&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable RSS. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structrte__eth__rss__conf.html">rte_eth_rss_conf</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00367">367</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a94796f5cd5a38f9b087b78ef11ca2733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94796f5cd5a38f9b087b78ef11ca2733">&#9670;&nbsp;</a></span>RTE_ETH_MQ_RX_DCB_FLAG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_MQ_RX_DCB_FLAG&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable DCB. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00368">368</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="ac7665dae0141ae048fec4b2916f863c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7665dae0141ae048fec4b2916f863c7">&#9670;&nbsp;</a></span>RTE_ETH_MQ_RX_VMDQ_FLAG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_MQ_RX_VMDQ_FLAG&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable VMDq. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00369">369</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="aa4b07cdd038086f27503c465d2ded314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b07cdd038086f27503c465d2ded314">&#9670;&nbsp;</a></span>RTE_ETH_FLOW_PORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_FLOW_PORT&#160;&#160;&#160;18</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consider device port number as a flow differentiator </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00529">529</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a8c2e24a4f3d94ec3ab65ac516b50c9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2e24a4f3d94ec3ab65ac516b50c9fb">&#9670;&nbsp;</a></span>RTE_ETH_FLOW_VXLAN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_FLOW_VXLAN&#160;&#160;&#160;19</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VXLAN protocol based flow </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00530">530</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a2f5ea2e44996c8f3aaeef61e63831e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f5ea2e44996c8f3aaeef61e63831e2f">&#9670;&nbsp;</a></span>RTE_ETH_FLOW_GENEVE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_FLOW_GENEVE&#160;&#160;&#160;20</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>GENEVE protocol based flow </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00531">531</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a93c44d6fe8c46c6e78102a0e629a06a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c44d6fe8c46c6e78102a0e629a06a3">&#9670;&nbsp;</a></span>RTE_ETH_FLOW_NVGRE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_FLOW_NVGRE&#160;&#160;&#160;21</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NVGRE protocol based flow </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00532">532</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="ad0bfed621cb545270fec65e438413e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0bfed621cb545270fec65e438413e8e">&#9670;&nbsp;</a></span>RTE_ETH_FLOW_VXLAN_GPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_FLOW_VXLAN_GPE&#160;&#160;&#160;22</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VXLAN-GPE protocol based flow </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00533">533</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a955f586fbbd6270877a389a5736663b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955f586fbbd6270877a389a5736663b1">&#9670;&nbsp;</a></span>RTE_ETH_FLOW_GTPU</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_FLOW_GTPU&#160;&#160;&#160;23</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>GTPU protocol based flow </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00534">534</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a8f8f9874848b6a43e61e855107e2cba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8f9874848b6a43e61e855107e2cba6">&#9670;&nbsp;</a></span>RTE_ETH_RSS_L4_CHKSUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_RSS_L4_CHKSUM&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(35)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The RTE_ETH_RSS_L4_CHKSUM works on checksum field of any L4 header. It is similar to RTE_ETH_RSS_PORT that they don't specify the specific type of L4 header. This macro is defined to replace some specific L4 (TCP/UDP/SCTP) checksum type for constructing the use of RSS offload bits.</p>
<p>Due to above reason, some old APIs (and configuration) don't support RTE_ETH_RSS_L4_CHKSUM. The rte_flow RSS API supports it.</p>
<p>For the case that checksum is not used in an UDP header, it takes the reserved value 0 as input for the hash function. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00586">586</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a5e2788ff14dafad3d2b081ee8002d9ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2788ff14dafad3d2b081ee8002d9ad">&#9670;&nbsp;</a></span>RTE_ETH_RSS_LEVEL_PMD_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_RSS_LEVEL_PMD_DEFAULT&#160;&#160;&#160;(UINT64_C(0) &lt;&lt; 50)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>level 0, requests the default behavior. Depending on the packet type, it can mean outermost, innermost, anything in between or even no RSS. It basically stands for the innermost encapsulation level RSS can be performed on according to PMD and device capabilities. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00632">632</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="af71e4d7a2c8aae73f1dfb7eb9a2f1699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71e4d7a2c8aae73f1dfb7eb9a2f1699">&#9670;&nbsp;</a></span>RTE_ETH_RSS_LEVEL_OUTERMOST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_RSS_LEVEL_OUTERMOST&#160;&#160;&#160;(UINT64_C(1) &lt;&lt; 50)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>level 1, requests RSS to be performed on the outermost packet encapsulation level. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00638">638</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a44399c69c5bd75f8cb4f959853cac861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44399c69c5bd75f8cb4f959853cac861">&#9670;&nbsp;</a></span>RTE_ETH_RSS_LEVEL_INNERMOST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_RSS_LEVEL_INNERMOST&#160;&#160;&#160;(UINT64_C(2) &lt;&lt; 50)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>level 2, requests RSS to be performed on the specified inner packet encapsulation level, from outermost to innermost (lower to higher values). </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00644">644</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a97296a3668c79dad63086110ad5afec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97296a3668c79dad63086110ad5afec2">&#9670;&nbsp;</a></span>RTE_ETH_RSS_PROTO_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_RSS_PROTO_MASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ( \</div>
<div class="line">    RTE_ETH_RSS_IPV4 | \</div>
<div class="line">    RTE_ETH_RSS_FRAG_IPV4 | \</div>
<div class="line">    RTE_ETH_RSS_NONFRAG_IPV4_TCP | \</div>
<div class="line">    RTE_ETH_RSS_NONFRAG_IPV4_UDP | \</div>
<div class="line">    RTE_ETH_RSS_NONFRAG_IPV4_SCTP | \</div>
<div class="line">    RTE_ETH_RSS_NONFRAG_IPV4_OTHER | \</div>
<div class="line">    RTE_ETH_RSS_IPV6 | \</div>
<div class="line">    RTE_ETH_RSS_FRAG_IPV6 | \</div>
<div class="line">    RTE_ETH_RSS_NONFRAG_IPV6_TCP | \</div>
<div class="line">    RTE_ETH_RSS_NONFRAG_IPV6_UDP | \</div>
<div class="line">    RTE_ETH_RSS_NONFRAG_IPV6_SCTP | \</div>
<div class="line">    RTE_ETH_RSS_NONFRAG_IPV6_OTHER | \</div>
<div class="line">    RTE_ETH_RSS_L2_PAYLOAD | \</div>
<div class="line">    RTE_ETH_RSS_IPV6_EX | \</div>
<div class="line">    RTE_ETH_RSS_IPV6_TCP_EX | \</div>
<div class="line">    RTE_ETH_RSS_IPV6_UDP_EX | \</div>
<div class="line">    RTE_ETH_RSS_PORT  | \</div>
<div class="line">    RTE_ETH_RSS_VXLAN | \</div>
<div class="line">    RTE_ETH_RSS_GENEVE | \</div>
<div class="line">    RTE_ETH_RSS_NVGRE | \</div>
<div class="line">    RTE_ETH_RSS_MPLS)</div>
</div><!-- fragment --><p>Mask of valid RSS hash protocols </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00800">800</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a6086d5152d45a531057af4521dd33b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6086d5152d45a531057af4521dd33b3a">&#9670;&nbsp;</a></span>RTE_ETH_VMDQ_MAX_VLAN_FILTERS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_VMDQ_MAX_VLAN_FILTERS&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum nb. of VMDq VLAN filters. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00835">835</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a2604741049d2115f9e0b5f36f6a3d591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2604741049d2115f9e0b5f36f6a3d591">&#9670;&nbsp;</a></span>RTE_ETH_DCB_NUM_USER_PRIORITIES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_DCB_NUM_USER_PRIORITIES&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum nb. of DCB priorities. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00836">836</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="ae421db3efad2132e9a686e1a96e26d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae421db3efad2132e9a686e1a96e26d81">&#9670;&nbsp;</a></span>RTE_ETH_VMDQ_DCB_NUM_QUEUES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_VMDQ_DCB_NUM_QUEUES&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum nb. of VMDq DCB queues. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00837">837</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="ae449697ac0a0ad5b3770c5b3c06c3305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae449697ac0a0ad5b3770c5b3c06c3305">&#9670;&nbsp;</a></span>RTE_ETH_DCB_NUM_QUEUES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_DCB_NUM_QUEUES&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum nb. of DCB queues. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00838">838</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a03ae4ab10a1f9a5d7e44dbf54609eb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ae4ab10a1f9a5d7e44dbf54609eb92">&#9670;&nbsp;</a></span>RTE_ETH_DCB_PG_SUPPORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_DCB_PG_SUPPORT&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Priority Group(ETS) support. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00842">842</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a563b1f15304c3ec5ed733fee19c79e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563b1f15304c3ec5ed733fee19c79e3a">&#9670;&nbsp;</a></span>RTE_ETH_DCB_PFC_SUPPORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_DCB_PFC_SUPPORT&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Priority Flow Control support. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00843">843</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="af139b95af2511203a5732c64d3aaba34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af139b95af2511203a5732c64d3aaba34">&#9670;&nbsp;</a></span>RTE_ETH_VLAN_STRIP_OFFLOAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_VLAN_STRIP_OFFLOAD&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VLAN Strip On/Off </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00847">847</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a6389be72892948f8d12fafdb1f7c41e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6389be72892948f8d12fafdb1f7c41e2">&#9670;&nbsp;</a></span>RTE_ETH_VLAN_FILTER_OFFLOAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_VLAN_FILTER_OFFLOAD&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VLAN Filter On/Off </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00848">848</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="acd3e8905940772cb41da75e9a09553e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3e8905940772cb41da75e9a09553e6">&#9670;&nbsp;</a></span>RTE_ETH_VLAN_EXTEND_OFFLOAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_VLAN_EXTEND_OFFLOAD&#160;&#160;&#160;0x0004</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VLAN Extend On/Off </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00849">849</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a0cf88fd26dba1759406f4f453e1671c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf88fd26dba1759406f4f453e1671c4">&#9670;&nbsp;</a></span>RTE_ETH_QINQ_STRIP_OFFLOAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_QINQ_STRIP_OFFLOAD&#160;&#160;&#160;0x0008</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>QINQ Strip On/Off </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00850">850</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a59c1a65aa437374e4e1cfc8efdbad64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c1a65aa437374e4e1cfc8efdbad64f">&#9670;&nbsp;</a></span>RTE_ETH_VLAN_STRIP_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_VLAN_STRIP_MASK&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VLAN Strip setting mask </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00852">852</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a5ff10995486199c1acec0d08561b08b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff10995486199c1acec0d08561b08b0">&#9670;&nbsp;</a></span>RTE_ETH_VLAN_FILTER_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_VLAN_FILTER_MASK&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VLAN Filter setting mask </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00853">853</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="afcf35ff1901c4a0ea852cb70059a39c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf35ff1901c4a0ea852cb70059a39c1">&#9670;&nbsp;</a></span>RTE_ETH_VLAN_EXTEND_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_VLAN_EXTEND_MASK&#160;&#160;&#160;0x0004</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VLAN Extend setting mask </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00854">854</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a0c5dad5fdc1f69a2ba55a18c5fdeb6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5dad5fdc1f69a2ba55a18c5fdeb6d2">&#9670;&nbsp;</a></span>RTE_ETH_QINQ_STRIP_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_QINQ_STRIP_MASK&#160;&#160;&#160;0x0008</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>QINQ Strip setting mask </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00855">855</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a70ab9023465d6295c8c92f6bbf910e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ab9023465d6295c8c92f6bbf910e03">&#9670;&nbsp;</a></span>RTE_ETH_VLAN_ID_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_VLAN_ID_MAX&#160;&#160;&#160;0x0FFF</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VLAN ID is in lower 12 bits </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00856">856</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a3de5da4661e215c3910bc599b265a7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de5da4661e215c3910bc599b265a7f5">&#9670;&nbsp;</a></span>RTE_ETH_NUM_RECEIVE_MAC_ADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_NUM_RECEIVE_MAC_ADDR&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum nb. of receive mac addr. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00860">860</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="ac5faaf8b9c988e47f69b6434b7d3e35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5faaf8b9c988e47f69b6434b7d3e35a">&#9670;&nbsp;</a></span>RTE_ETH_VMDQ_NUM_UC_HASH_ARRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_VMDQ_NUM_UC_HASH_ARRAY&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum nb. of UC hash array. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00863">863</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a8e4235c1b3f5e5f8095e0f5b16e565e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4235c1b3f5e5f8095e0f5b16e565e9">&#9670;&nbsp;</a></span>RTE_ETH_VMDQ_ACCEPT_UNTAG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_VMDQ_ACCEPT_UNTAG&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Accept untagged packets. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00869">869</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="afe2df94b09550b9fe0402d3afc3b1a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2df94b09550b9fe0402d3afc3b1a29">&#9670;&nbsp;</a></span>RTE_ETH_VMDQ_ACCEPT_HASH_MC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_VMDQ_ACCEPT_HASH_MC&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Accept packets in multicast table. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00871">871</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="aa3e2ec2852ddd2db863da67fd39793af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e2ec2852ddd2db863da67fd39793af">&#9670;&nbsp;</a></span>RTE_ETH_VMDQ_ACCEPT_HASH_UC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_VMDQ_ACCEPT_HASH_UC&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Accept packets in unicast table. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00873">873</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="abad72b961df8f1c1bd38ef02bd781b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad72b961df8f1c1bd38ef02bd781b15">&#9670;&nbsp;</a></span>RTE_ETH_VMDQ_ACCEPT_BROADCAST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_VMDQ_ACCEPT_BROADCAST&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(3)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Accept broadcast packets. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00875">875</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a1d739e7afdd47b54638d637f3a75199a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d739e7afdd47b54638d637f3a75199a">&#9670;&nbsp;</a></span>RTE_ETH_VMDQ_ACCEPT_MULTICAST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_VMDQ_ACCEPT_MULTICAST&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(4)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multicast promiscuous. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00877">877</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a8e5c6b6dfaf3c80239a29c94dba546d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5c6b6dfaf3c80239a29c94dba546d0">&#9670;&nbsp;</a></span>RTE_ETH_RX_OFFLOAD_VLAN_STRIP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_RX_OFFLOAD_VLAN_STRIP&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rx offload capabilities of a device. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01528">1528</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a6b084764f74d4dad7f6d800492f1c492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b084764f74d4dad7f6d800492f1c492">&#9670;&nbsp;</a></span>RTE_ETH_RX_OFFLOAD_TIMESTAMP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_RX_OFFLOAD_TIMESTAMP&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(14)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timestamp is set by the driver in RTE_MBUF_DYNFIELD_TIMESTAMP_NAME and RTE_MBUF_DYNFLAG_RX_TIMESTAMP_NAME is set in ol_flags. The mbuf field and flag are registered when the offload is configured. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01544">1544</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a1b05b665bf74a83ffeafe766cf032183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b05b665bf74a83ffeafe766cf032183">&#9670;&nbsp;</a></span>RTE_ETH_TX_OFFLOAD_VLAN_INSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_TX_OFFLOAD_VLAN_INSERT&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tx offload capabilities of a device. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01568">1568</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="ad08f92c795a300b3b89d716bd3824f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08f92c795a300b3b89d716bd3824f26">&#9670;&nbsp;</a></span>RTE_ETH_TX_OFFLOAD_OUTER_IPV4_CKSUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_TX_OFFLOAD_OUTER_IPV4_CKSUM&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(7)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used for tunneling packet. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01575">1575</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a6650d2907021c1175764d489dd356187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6650d2907021c1175764d489dd356187">&#9670;&nbsp;</a></span>RTE_ETH_TX_OFFLOAD_VXLAN_TNL_TSO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_TX_OFFLOAD_VXLAN_TNL_TSO&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(9)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used for tunneling packet. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01577">1577</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a1c5b8b65cf5b425c831fec11f8ab7549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5b8b65cf5b425c831fec11f8ab7549">&#9670;&nbsp;</a></span>RTE_ETH_TX_OFFLOAD_GRE_TNL_TSO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_TX_OFFLOAD_GRE_TNL_TSO&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(10)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used for tunneling packet. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01578">1578</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a590ccadf43e3935e33367cfb51d4164e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590ccadf43e3935e33367cfb51d4164e">&#9670;&nbsp;</a></span>RTE_ETH_TX_OFFLOAD_IPIP_TNL_TSO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_TX_OFFLOAD_IPIP_TNL_TSO&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(11)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used for tunneling packet. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01579">1579</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="af1fd63a49d052c11e85e12e20a2af5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1fd63a49d052c11e85e12e20a2af5a9">&#9670;&nbsp;</a></span>RTE_ETH_TX_OFFLOAD_GENEVE_TNL_TSO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_TX_OFFLOAD_GENEVE_TNL_TSO&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(12)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used for tunneling packet. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01580">1580</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a0cd8e0a04a7c7d8aa96cb649499bc5d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd8e0a04a7c7d8aa96cb649499bc5d8">&#9670;&nbsp;</a></span>RTE_ETH_TX_OFFLOAD_MT_LOCKFREE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_TX_OFFLOAD_MT_LOCKFREE&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(14)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiple threads can invoke <a class="el" href="rte__ethdev_8h.html#a83e56cabbd31637efd648e3fc010392b">rte_eth_tx_burst()</a> concurrently on the same Tx queue without SW lock. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01586">1586</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="af2aec9935b1040d8a03682f1adb5770e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2aec9935b1040d8a03682f1adb5770e">&#9670;&nbsp;</a></span>RTE_ETH_TX_OFFLOAD_MULTI_SEGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_TX_OFFLOAD_MULTI_SEGS&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(15)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device supports multi segment send. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a9">examples/ipv4_multicast/main.c</a>, and <a class="el" href="examples_2syntony_2main_8c-example.html#a9">examples/syntony/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01588">1588</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a43f198c6b59d965130d56fd8f40ceac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f198c6b59d965130d56fd8f40ceac1">&#9670;&nbsp;</a></span>RTE_ETH_TX_OFFLOAD_MBUF_FAST_FREE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_TX_OFFLOAD_MBUF_FAST_FREE&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(16)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device supports optimization for fast release of mbufs. When set application must guarantee that per-queue all mbufs comes from the same mempool and has refcnt = 1. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01594">1594</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a6f33b32ed53a39c9b88940b673c9a828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f33b32ed53a39c9b88940b673c9a828">&#9670;&nbsp;</a></span>RTE_ETH_TX_OFFLOAD_UDP_TNL_TSO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_TX_OFFLOAD_UDP_TNL_TSO&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(18)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device supports generic UDP tunneled packet TSO. Application must set RTE_MBUF_F_TX_TUNNEL_UDP and other mbuf fields required for tunnel TSO. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01601">1601</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a6eda9f39d545d96df591c4470bbfd2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eda9f39d545d96df591c4470bbfd2c7">&#9670;&nbsp;</a></span>RTE_ETH_TX_OFFLOAD_IP_TNL_TSO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_TX_OFFLOAD_IP_TNL_TSO&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(19)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device supports generic IP tunneled packet TSO. Application must set RTE_MBUF_F_TX_TUNNEL_IP and other mbuf fields required for tunnel TSO. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01607">1607</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a2098a9f392175b2797c14ef37f56efe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2098a9f392175b2797c14ef37f56efe9">&#9670;&nbsp;</a></span>RTE_ETH_TX_OFFLOAD_OUTER_UDP_CKSUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_TX_OFFLOAD_OUTER_UDP_CKSUM&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(20)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device supports outer UDP checksum </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01609">1609</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="af12803b6c19b10bd0c5ee30e8f07ef56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12803b6c19b10bd0c5ee30e8f07ef56">&#9670;&nbsp;</a></span>RTE_ETH_TX_OFFLOAD_SEND_ON_TIMESTAMP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_TX_OFFLOAD_SEND_ON_TIMESTAMP&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(21)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device sends on time read from RTE_MBUF_DYNFIELD_TIMESTAMP_NAME if RTE_MBUF_DYNFLAG_TX_TIMESTAMP_NAME is set in ol_flags. The mbuf field and flag are registered when the offload is configured. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01615">1615</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a59f716aab25560f9d074bda5e9daea78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f716aab25560f9d074bda5e9daea78">&#9670;&nbsp;</a></span>RTE_ETH_DEV_CAPA_RUNTIME_RX_QUEUE_SETUP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_DEV_CAPA_RUNTIME_RX_QUEUE_SETUP&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device supports Rx queue setup after device started. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01625">1625</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a069e4f3f971c847588f6ee53edc9b63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069e4f3f971c847588f6ee53edc9b63a">&#9670;&nbsp;</a></span>RTE_ETH_DEV_CAPA_RUNTIME_TX_QUEUE_SETUP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_DEV_CAPA_RUNTIME_TX_QUEUE_SETUP&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device supports Tx queue setup after device started. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01627">1627</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="ab40be0550562865a1f8299a867979832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab40be0550562865a1f8299a867979832">&#9670;&nbsp;</a></span>RTE_ETH_DEV_CAPA_RXQ_SHARE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_DEV_CAPA_RXQ_SHARE&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device supports shared Rx queue among ports within Rx domain and switch domain. Mbufs are consumed by shared Rx queue instead of each queue. Multiple groups are supported by share_group of Rx queue configuration. Shared Rx queue is identified by PMD using share_qid of Rx queue configuration. Polling any port in the group receive packets of all member ports, source port identified by mbuf-&gt;port field. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01637">1637</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a7413b162b5cec14de0291f104a77567e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7413b162b5cec14de0291f104a77567e">&#9670;&nbsp;</a></span>RTE_ETH_DEV_CAPA_FLOW_RULE_KEEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_DEV_CAPA_FLOW_RULE_KEEP&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(3)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device supports keeping flow rules across restart. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01639">1639</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a553d459c88eb2ccf31f6ed0e5910847d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553d459c88eb2ccf31f6ed0e5910847d">&#9670;&nbsp;</a></span>RTE_ETH_DEV_CAPA_FLOW_SHARED_OBJECT_KEEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_DEV_CAPA_FLOW_SHARED_OBJECT_KEEP&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(4)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device supports keeping shared flow objects across restart. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01641">1641</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="af54d566e2ae76bc015c0f7ed1fe000c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af54d566e2ae76bc015c0f7ed1fe000c9">&#9670;&nbsp;</a></span>RTE_ETH_DEV_SWITCH_DOMAIN_ID_INVALID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_DEV_SWITCH_DOMAIN_ID_INVALID&#160;&#160;&#160;(UINT16_MAX)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default values for switch domain ID when ethdev does not support switch domain definitions. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01669">1669</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a3abc58fe4d2e266f9e285d5f34eb3579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3abc58fe4d2e266f9e285d5f34eb3579">&#9670;&nbsp;</a></span>RTE_ETH_QUEUE_STATE_STOPPED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_QUEUE_STATE_STOPPED&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queue stopped. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01828">1828</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a0753713af1e72b067884e51ce1f1782b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0753713af1e72b067884e51ce1f1782b">&#9670;&nbsp;</a></span>RTE_ETH_QUEUE_STATE_STARTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_QUEUE_STATE_STARTED&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queue started. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01829">1829</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="add59ad5a5a7497b381ab114f89893992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add59ad5a5a7497b381ab114f89893992">&#9670;&nbsp;</a></span>RTE_ETH_QUEUE_STATE_HAIRPIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_QUEUE_STATE_HAIRPIN&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queue used for hairpin. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01830">1830</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a861af3fb10a9faa1324e43c00bfa2391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861af3fb10a9faa1324e43c00bfa2391">&#9670;&nbsp;</a></span>RTE_ETH_BURST_FLAG_PER_QUEUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_BURST_FLAG_PER_QUEUE&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the queues have different burst mode description, this bit will be set by PMD, then the application can iterate to retrieve burst description for all other queues. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01894">1894</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a2e6044a6301db5c64fd0b0e1b807bfd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6044a6301db5c64fd0b0e1b807bfd1">&#9670;&nbsp;</a></span>RTE_ETH_BURST_MODE_INFO_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_BURST_MODE_INFO_SIZE&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum size for information </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01903">1903</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="aef015c6435970820b78112eaaef14d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef015c6435970820b78112eaaef14d58">&#9670;&nbsp;</a></span>RTE_ETH_XSTATS_NAME_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_XSTATS_NAME_SIZE&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum name length for extended statistics counters </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01908">1908</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="aba3aae3effe98f1567b59974f6477984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3aae3effe98f1567b59974f6477984">&#9670;&nbsp;</a></span>RTE_ETH_DEV_FLOW_OPS_THREAD_SAFE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_DEV_FLOW_OPS_THREAD_SAFE&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PMD supports thread-safe flow operations </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l02100">2100</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="ac9c2348839c58faa378a071c09c22db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c2348839c58faa378a071c09c22db6">&#9670;&nbsp;</a></span>RTE_ETH_DEV_INTR_LSC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_DEV_INTR_LSC&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device supports link state interrupt </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l02102">2102</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a8e1b6a70dd6b9277d4d93fc4c0c075ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1b6a70dd6b9277d4d93fc4c0c075ca">&#9670;&nbsp;</a></span>RTE_ETH_DEV_BONDING_MEMBER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_DEV_BONDING_MEMBER&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device is a bonding member </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l02104">2104</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a4c7ea7a84189637d9bb6bb7bc2e86ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7ea7a84189637d9bb6bb7bc2e86ee2">&#9670;&nbsp;</a></span>RTE_ETH_DEV_INTR_RMV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_DEV_INTR_RMV&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(3)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device supports device removal interrupt </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l02106">2106</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="aa1b0cf1c6bf0c5a5b175997c73aacd3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b0cf1c6bf0c5a5b175997c73aacd3b">&#9670;&nbsp;</a></span>RTE_ETH_DEV_REPRESENTOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_DEV_REPRESENTOR&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(4)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device is port representor </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l02108">2108</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a57f879ef19601f28f200d4293933854e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f879ef19601f28f200d4293933854e">&#9670;&nbsp;</a></span>RTE_ETH_DEV_NOLIVE_MAC_ADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_DEV_NOLIVE_MAC_ADDR&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(5)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device does not support MAC change after started </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l02110">2110</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a8b145edb9f8961ef6604ed508486a396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b145edb9f8961ef6604ed508486a396">&#9670;&nbsp;</a></span>RTE_ETH_DEV_AUTOFILL_QUEUE_XSTATS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_DEV_AUTOFILL_QUEUE_XSTATS&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(6)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queue xstats filled automatically by ethdev layer. PMDs filling the queue xstats themselves should not set this flag </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l02115">2115</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a0251ed7f4aa8c0bd8d12e5bc3fa17e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0251ed7f4aa8c0bd8d12e5bc3fa17e84">&#9670;&nbsp;</a></span>RTE_ETH_FOREACH_DEV_OWNED_BY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_FOREACH_DEV_OWNED_BY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">o&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">for</span> (p = <a class="code" href="rte__ethdev_8h.html#a4b6a29579d85e90b52e629139144aebc">rte_eth_find_next_owned_by</a>(0, o); \</div>
<div class="line">         (<span class="keywordtype">unsigned</span> int)p &lt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)RTE_MAX_ETHPORTS; \</div>
<div class="line">         p = <a class="code" href="rte__ethdev_8h.html#a4b6a29579d85e90b52e629139144aebc">rte_eth_find_next_owned_by</a>(p + 1, o))</div>
<div class="ttc" id="arte__ethdev_8h_html_a4b6a29579d85e90b52e629139144aebc"><div class="ttname"><a href="rte__ethdev_8h.html#a4b6a29579d85e90b52e629139144aebc">rte_eth_find_next_owned_by</a></div><div class="ttdeci">uint64_t rte_eth_find_next_owned_by(uint16_t port_id, const uint64_t owner_id)</div></div>
</div><!-- fragment --><p>Macro to iterate over all enabled ethdev ports owned by a specific owner. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l02135">2135</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="ad7b46c67203d37fe3a34f11076d970d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b46c67203d37fe3a34f11076d970d6">&#9670;&nbsp;</a></span>RTE_ETH_FOREACH_DEV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_FOREACH_DEV</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p</td><td>)</td>
          <td>&#160;&#160;&#160;	<a class="el" href="rte__ethdev_8h.html#a0251ed7f4aa8c0bd8d12e5bc3fa17e84">RTE_ETH_FOREACH_DEV_OWNED_BY</a>(p, RTE_ETH_DEV_NO_OWNER)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro to iterate over all enabled and ownerless ethdev ports. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a57">examples/ipv4_multicast/main.c</a>, and <a class="el" href="examples_2syntony_2main_8c-example.html#a57">examples/syntony/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l02153">2153</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a7d4fe1205ba0a7164273457c8f36720c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4fe1205ba0a7164273457c8f36720c">&#9670;&nbsp;</a></span>RTE_ETH_FOREACH_DEV_OF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_FOREACH_DEV_OF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">port_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">parent&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">for</span> (port_id = <a class="code" href="rte__ethdev_8h.html#ae67f6b336d3cd3f90cecc41e629ebbe1">rte_eth_find_next_of</a>(0, parent); \</div>
<div class="line">        port_id &lt; RTE_MAX_ETHPORTS; \</div>
<div class="line">        port_id = <a class="code" href="rte__ethdev_8h.html#ae67f6b336d3cd3f90cecc41e629ebbe1">rte_eth_find_next_of</a>(port_id + 1, parent))</div>
<div class="ttc" id="arte__ethdev_8h_html_ae67f6b336d3cd3f90cecc41e629ebbe1"><div class="ttname"><a href="rte__ethdev_8h.html#ae67f6b336d3cd3f90cecc41e629ebbe1">rte_eth_find_next_of</a></div><div class="ttdeci">uint16_t rte_eth_find_next_of(uint16_t port_id_start, const struct rte_device *parent)</div></div>
</div><!-- fragment --><p>Macro to iterate over all ethdev ports of a specified device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The ID of the matching port being iterated. </td></tr>
    <tr><td class="paramname">parent</td><td>The rte_device pointer matching the iterated ports. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l02179">2179</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a3638b7c090190701b94aef18b1369bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3638b7c090190701b94aef18b1369bfa">&#9670;&nbsp;</a></span>RTE_ETH_FOREACH_DEV_SIBLING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_FOREACH_DEV_SIBLING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">port_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ref_port_id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">for</span> (port_id = <a class="code" href="rte__ethdev_8h.html#a967a92a5681b48c414a6496d0e134789">rte_eth_find_next_sibling</a>(0, ref_port_id); \</div>
<div class="line">        port_id &lt; RTE_MAX_ETHPORTS; \</div>
<div class="line">        port_id = <a class="code" href="rte__ethdev_8h.html#a967a92a5681b48c414a6496d0e134789">rte_eth_find_next_sibling</a>(port_id + 1, ref_port_id))</div>
<div class="ttc" id="arte__ethdev_8h_html_a967a92a5681b48c414a6496d0e134789"><div class="ttname"><a href="rte__ethdev_8h.html#a967a92a5681b48c414a6496d0e134789">rte_eth_find_next_sibling</a></div><div class="ttdeci">uint16_t rte_eth_find_next_sibling(uint16_t port_id_start, uint16_t ref_port_id)</div></div>
</div><!-- fragment --><p>Macro to iterate over all ethdev ports sharing the same rte_device as the specified port. Note: the specified reference port is part of the loop iterations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The ID of the matching port being iterated. </td></tr>
    <tr><td class="paramname">ref_port_id</td><td>The ID of the port being compared. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l02208">2208</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="aff24ae3f48be43275b50966c3573a7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff24ae3f48be43275b50966c3573a7a9">&#9670;&nbsp;</a></span>RTE_ETH_TX_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_TX_BUFFER_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sz</td><td>)</td>
          <td>&#160;&#160;&#160;	(sizeof(struct <a class="el" href="structrte__eth__dev__tx__buffer.html">rte_eth_dev_tx_buffer</a>) + (sz) * sizeof(struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the size of the Tx buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>Number of stored packets. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l03747">3747</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a9ef90b0d32dcf444b5bbf5c3b9b778c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef90b0d32dcf444b5bbf5c3b9b778c4">&#9670;&nbsp;</a></span>RTE_ETH_RX_METADATA_USER_FLAG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_RX_METADATA_USER_FLAG&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The NIC is able to deliver flag (if set) with packets to the PMD. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l05514">5514</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a0afa36f3c9d4c1f66a5828e2850a9cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0afa36f3c9d4c1f66a5828e2850a9cd3">&#9670;&nbsp;</a></span>RTE_ETH_RX_METADATA_USER_MARK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_RX_METADATA_USER_MARK&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The NIC is able to deliver mark ID with packets to the PMD. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l05517">5517</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a302ba9f7eb77bfaf00e26503ce866b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302ba9f7eb77bfaf00e26503ce866b44">&#9670;&nbsp;</a></span>RTE_ETH_RX_METADATA_TUNNEL_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_RX_METADATA_TUNNEL_ID&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a00b092ca74422b69b4baa653396a3285">RTE_BIT64</a>(2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The NIC is able to deliver tunnel ID with packets to the PMD. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l05520">5520</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a34e2d3a2e79cf285863d23d2cf9740fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e2d3a2e79cf285863d23d2cf9740fd">&#9670;&nbsp;</a></span>RTE_ETH_DEV_REASSEMBLY_F_IPV4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_DEV_REASSEMBLY_F_IPV4&#160;&#160;&#160;(<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(0))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag to offload IP reassembly for IPv4 packets. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l05564">5564</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a02baf1aa61b3c92ad215961db03d274b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02baf1aa61b3c92ad215961db03d274b">&#9670;&nbsp;</a></span>RTE_ETH_DEV_REASSEMBLY_F_IPV6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_DEV_REASSEMBLY_F_IPV6&#160;&#160;&#160;(<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(1))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag to offload IP reassembly for IPv6 packets. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l05566">5566</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="af7bd60e9403569c36e77fa16a21ecf17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bd60e9403569c36e77fa16a21ecf17">&#9670;&nbsp;</a></span>RTE_ETH_RX_DESC_AVAIL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_RX_DESC_AVAIL&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Desc available for hw. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l06151">6151</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="abc8f3353b8a75da4604d54012c87fc10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8f3353b8a75da4604d54012c87fc10">&#9670;&nbsp;</a></span>RTE_ETH_RX_DESC_DONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_RX_DESC_DONE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Desc done, filled by hw. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l06152">6152</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="aa57b694aa035341057c03fd9977b7f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57b694aa035341057c03fd9977b7f09">&#9670;&nbsp;</a></span>RTE_ETH_RX_DESC_UNAVAIL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_RX_DESC_UNAVAIL&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Desc used by driver or hw. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l06153">6153</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a04664422a6ea44b1a7961523344e53f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04664422a6ea44b1a7961523344e53f4">&#9670;&nbsp;</a></span>RTE_ETH_TX_DESC_FULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_TX_DESC_FULL&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Desc filled for hw, waiting xmit. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l06223">6223</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a1ac2b8d40c588ca7677b592b267a09d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac2b8d40c588ca7677b592b267a09d7">&#9670;&nbsp;</a></span>RTE_ETH_TX_DESC_DONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_TX_DESC_DONE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Desc done, packet is transmitted. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l06224">6224</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="ac5bdf994261b2caae5be400abed2796d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5bdf994261b2caae5be400abed2796d">&#9670;&nbsp;</a></span>RTE_ETH_TX_DESC_UNAVAIL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ETH_TX_DESC_UNAVAIL&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Desc used by driver or hw. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l06225">6225</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a7400438ebc28f2343aa0453ad5a4a021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7400438ebc28f2343aa0453ad5a4a021">&#9670;&nbsp;</a></span>rte_rx_callback_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> uint16_t(* rte_rx_callback_fn) (uint16_t port_id, uint16_t queue, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *pkts[], uint16_t nb_pkts, uint16_t max_pkts, void *user_param)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function type used for Rx packet processing packet callbacks.</p>
<p>The callback function is called on Rx with a burst of packets that have been received on the given port and queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The Ethernet port on which Rx is being performed. </td></tr>
    <tr><td class="paramname">queue</td><td>The queue on the Ethernet port which is being used to receive the packets. </td></tr>
    <tr><td class="paramname">pkts</td><td>The burst of packets that have just been received. </td></tr>
    <tr><td class="paramname">nb_pkts</td><td>The number of packets in the burst pointed to by "pkts". </td></tr>
    <tr><td class="paramname">max_pkts</td><td>The max number of packets that can be stored in the "pkts" array. </td></tr>
    <tr><td class="paramname">user_param</td><td>The arbitrary user parameter passed in by the application when the callback was originally configured. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets returned to the user. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l02037">2037</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="aeb995c6332dcda43bc0c551ea266d7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb995c6332dcda43bc0c551ea266d7fd">&#9670;&nbsp;</a></span>rte_tx_callback_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> uint16_t(* rte_tx_callback_fn) (uint16_t port_id, uint16_t queue, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *pkts[], uint16_t nb_pkts, void *user_param)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function type used for Tx packet processing packet callbacks.</p>
<p>The callback function is called on Tx with a burst of packets immediately before the packets are put onto the hardware queue for transmission.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The Ethernet port on which Tx is being performed. </td></tr>
    <tr><td class="paramname">queue</td><td>The queue on the Ethernet port which is being used to transmit the packets. </td></tr>
    <tr><td class="paramname">pkts</td><td>The burst of packets that are about to be transmitted. </td></tr>
    <tr><td class="paramname">nb_pkts</td><td>The number of packets in the burst pointed to by "pkts". </td></tr>
    <tr><td class="paramname">user_param</td><td>The arbitrary user parameter passed in by the application when the callback was originally configured. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets to be written to the NIC. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l02061">2061</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a868605d09373258672f598e8bf4dab82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868605d09373258672f598e8bf4dab82">&#9670;&nbsp;</a></span>rte_eth_dev_cb_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> int(* rte_eth_dev_cb_fn) (uint16_t port_id, enum <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779d">rte_eth_event_type</a> event, void *cb_arg, void *ret_param)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>User application callback to be registered for interrupts. </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l04093">4093</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a586b8e86131b4ec0ccaf464e847ccf3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586b8e86131b4ec0ccaf464e847ccf3e">&#9670;&nbsp;</a></span>rte_eth_rx_mq_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3e">rte_eth_rx_mq_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A set of values to identify what method is to be used to route packets to multiple queues. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a586b8e86131b4ec0ccaf464e847ccf3eac0de03aca722016af342202cf50c8b1d"></a>RTE_ETH_MQ_RX_NONE&#160;</td><td class="fielddoc"><p>None of DCB, RSS or VMDq mode </p>
</td></tr>
<tr><td class="fieldname"><a id="a586b8e86131b4ec0ccaf464e847ccf3eacbbd9761e99374702db64823901e27c9"></a>RTE_ETH_MQ_RX_RSS&#160;</td><td class="fielddoc"><p>For Rx side, only RSS is on </p>
</td></tr>
<tr><td class="fieldname"><a id="a586b8e86131b4ec0ccaf464e847ccf3ea7a0ef8d03750d5bac7dc5d323a99ac71"></a>RTE_ETH_MQ_RX_DCB&#160;</td><td class="fielddoc"><p>For Rx side,only DCB is on. </p>
</td></tr>
<tr><td class="fieldname"><a id="a586b8e86131b4ec0ccaf464e847ccf3ea4f82f1f9657b61e204c6ea6d8e41613c"></a>RTE_ETH_MQ_RX_DCB_RSS&#160;</td><td class="fielddoc"><p>Both DCB and RSS enable </p>
</td></tr>
<tr><td class="fieldname"><a id="a586b8e86131b4ec0ccaf464e847ccf3eae0269cffccfa3c7b0c4486394e78f386"></a>RTE_ETH_MQ_RX_VMDQ_ONLY&#160;</td><td class="fielddoc"><p>Only VMDq, no RSS nor DCB </p>
</td></tr>
<tr><td class="fieldname"><a id="a586b8e86131b4ec0ccaf464e847ccf3eac0883fb0c59e8a04b6d57d8245e6973e"></a>RTE_ETH_MQ_RX_VMDQ_RSS&#160;</td><td class="fielddoc"><p>RSS mode with VMDq </p>
</td></tr>
<tr><td class="fieldname"><a id="a586b8e86131b4ec0ccaf464e847ccf3eabe84d1a50e212e1a8fa2df21bc6e7401"></a>RTE_ETH_MQ_RX_VMDQ_DCB&#160;</td><td class="fielddoc"><p>Use VMDq+DCB to route traffic to queues </p>
</td></tr>
<tr><td class="fieldname"><a id="a586b8e86131b4ec0ccaf464e847ccf3ea5e4d6373c0b8b8e0d99335e4124c3889"></a>RTE_ETH_MQ_RX_VMDQ_DCB_RSS&#160;</td><td class="fielddoc"><p>Enable both VMDq and DCB in VMDq </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00376">376</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a4834f572f4dd4e46d81ad09b7d5fffd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4834f572f4dd4e46d81ad09b7d5fffd5">&#9670;&nbsp;</a></span>rte_eth_tx_mq_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#a4834f572f4dd4e46d81ad09b7d5fffd5">rte_eth_tx_mq_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A set of values to identify what method is to be used to transmit packets using multi-TCs. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4834f572f4dd4e46d81ad09b7d5fffd5a8b60a567503b43239d4fc7a5c3384015"></a>RTE_ETH_MQ_TX_NONE&#160;</td><td class="fielddoc"><p>It is in neither DCB nor VT mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4834f572f4dd4e46d81ad09b7d5fffd5a294a2e1aecaf653e0edd9a421385acb0"></a>RTE_ETH_MQ_TX_DCB&#160;</td><td class="fielddoc"><p>For Tx side,only DCB is on. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4834f572f4dd4e46d81ad09b7d5fffd5a335913388afb6743bf327782c6cf5a42"></a>RTE_ETH_MQ_TX_VMDQ_DCB&#160;</td><td class="fielddoc"><p>For Tx side,both DCB and VT is on. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4834f572f4dd4e46d81ad09b7d5fffd5a523c9fd4cae5bd8d0d019dc12e9bacb2"></a>RTE_ETH_MQ_TX_VMDQ_ONLY&#160;</td><td class="fielddoc"><p>Only VT on, no DCB </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00402">402</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="ae8c05489ea927eb7989108bf94b4f06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c05489ea927eb7989108bf94b4f06f">&#9670;&nbsp;</a></span>rte_vlan_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#ae8c05489ea927eb7989108bf94b4f06f">rte_vlan_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VLAN types to indicate if it is for single VLAN, inner VLAN or outer VLAN. Note that single VLAN is treated the same as inner VLAN. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae8c05489ea927eb7989108bf94b4f06fabf0211e843caebad16392c3d1a326ff9"></a>RTE_ETH_VLAN_TYPE_INNER&#160;</td><td class="fielddoc"><p>Inner VLAN. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae8c05489ea927eb7989108bf94b4f06fa9e6c98abc1253b6ebd2c24429591c83e"></a>RTE_ETH_VLAN_TYPE_OUTER&#160;</td><td class="fielddoc"><p>Single VLAN, or outer VLAN. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00433">433</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="aecb895db261266fa2a85cf518d007ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb895db261266fa2a85cf518d007ed9">&#9670;&nbsp;</a></span>rte_eth_hash_function</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#aecb895db261266fa2a85cf518d007ed9">rte_eth_hash_function</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hash function types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aecb895db261266fa2a85cf518d007ed9a2e12dcdea2601d69d9e15804243427f4"></a>RTE_ETH_HASH_FUNCTION_DEFAULT&#160;</td><td class="fielddoc"><p>DEFAULT means driver decides which hash algorithm to pick. </p>
</td></tr>
<tr><td class="fieldname"><a id="aecb895db261266fa2a85cf518d007ed9ad9ea5197524353c07c3b913d8243d156"></a>RTE_ETH_HASH_FUNCTION_TOEPLITZ&#160;</td><td class="fielddoc"><p>Toeplitz </p>
</td></tr>
<tr><td class="fieldname"><a id="aecb895db261266fa2a85cf518d007ed9a6e24a99a6463e7f6c9ca54318824c797"></a>RTE_ETH_HASH_FUNCTION_SIMPLE_XOR&#160;</td><td class="fielddoc"><p>Simple XOR </p>
</td></tr>
<tr><td class="fieldname"><a id="aecb895db261266fa2a85cf518d007ed9abe2d96db40e3d1b487f6be5b4cb486e5"></a>RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ&#160;</td><td class="fielddoc"><p>Symmetric Toeplitz: src, dst will be replaced by xor(src, dst). For the case with src/dst only, src or dst address will xor with zero pair. </p>
</td></tr>
<tr><td class="fieldname"><a id="aecb895db261266fa2a85cf518d007ed9a46d887a01ec93e64a1a3f8f1e7969158"></a>RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ_SORT&#160;</td><td class="fielddoc"><p>Symmetric Toeplitz: L3 and L4 fields are sorted prior to the hash function. If src_ip &gt; dst_ip, swap src_ip and dst_ip. If src_port &gt; dst_port, swap src_port and dst_port. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00451">451</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="afb320893bc8887d4fa065488519edeeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb320893bc8887d4fa065488519edeeb">&#9670;&nbsp;</a></span>rte_eth_nb_tcs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#afb320893bc8887d4fa065488519edeeb">rte_eth_nb_tcs</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enum indicates the possible number of traffic classes in DCB configurations </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afb320893bc8887d4fa065488519edeeba114c88e340bb61bdebd1c16176a3f206"></a>RTE_ETH_4_TCS&#160;</td><td class="fielddoc"><p>4 TCs with DCB. </p>
</td></tr>
<tr><td class="fieldname"><a id="afb320893bc8887d4fa065488519edeeba2969d5b0d15006a4e05e2f49cbf37efa"></a>RTE_ETH_8_TCS&#160;</td><td class="fielddoc"><p>8 TCs with DCB. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00897">897</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a012a874434677984af1f026ad585dd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012a874434677984af1f026ad585dd0d">&#9670;&nbsp;</a></span>rte_eth_nb_pools</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#a012a874434677984af1f026ad585dd0d">rte_eth_nb_pools</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enum indicates the possible number of queue pools in VMDq configurations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a012a874434677984af1f026ad585dd0da596c7fa9c2949232314a9bfb159e917e"></a>RTE_ETH_8_POOLS&#160;</td><td class="fielddoc"><p>8 VMDq pools. </p>
</td></tr>
<tr><td class="fieldname"><a id="a012a874434677984af1f026ad585dd0dad5e8faa07e7524af675cbf8f22f6871a"></a>RTE_ETH_16_POOLS&#160;</td><td class="fielddoc"><p>16 VMDq pools. </p>
</td></tr>
<tr><td class="fieldname"><a id="a012a874434677984af1f026ad585dd0da551250176fb51d1eee725c82d1c21aeb"></a>RTE_ETH_32_POOLS&#160;</td><td class="fielddoc"><p>32 VMDq pools. </p>
</td></tr>
<tr><td class="fieldname"><a id="a012a874434677984af1f026ad585dd0da49d2ff63295c28fbaa46f14a888b178f"></a>RTE_ETH_64_POOLS&#160;</td><td class="fielddoc"><p>64 VMDq pools. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00906">906</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a9caad71a6958aaf72dfce61bac897ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9caad71a6958aaf72dfce61bac897ad3">&#9670;&nbsp;</a></span>rte_eth_fc_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#a9caad71a6958aaf72dfce61bac897ad3">rte_eth_fc_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enum indicates the flow control mode </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9caad71a6958aaf72dfce61bac897ad3a60637133a72b1ae14c7e61d6944831b7"></a>RTE_ETH_FC_NONE&#160;</td><td class="fielddoc"><p>Disable flow control. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9caad71a6958aaf72dfce61bac897ad3a1bc46b2606b5a7f5d5ba331e80d7a8d5"></a>RTE_ETH_FC_RX_PAUSE&#160;</td><td class="fielddoc"><p>Rx pause frame, enable flowctrl on Tx side. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9caad71a6958aaf72dfce61bac897ad3a184373388db933788c0725672dd4f5df"></a>RTE_ETH_FC_TX_PAUSE&#160;</td><td class="fielddoc"><p>Tx pause frame, enable flowctrl on Rx side. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9caad71a6958aaf72dfce61bac897ad3af4cb6ec62485cd703e25f31e91408657"></a>RTE_ETH_FC_FULL&#160;</td><td class="fielddoc"><p>Enable flow control on both side. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01349">1349</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a77fa0fb1bfae6afc833bb38a82186f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77fa0fb1bfae6afc833bb38a82186f72">&#9670;&nbsp;</a></span>rte_eth_tunnel_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#a77fa0fb1bfae6afc833bb38a82186f72">rte_eth_tunnel_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tunnel type for device-specific classifier configuration. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structrte__eth__udp__tunnel.html">rte_eth_udp_tunnel</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01438">1438</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a5dedc2dcd96cb76abe4d81052c3fd78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dedc2dcd96cb76abe4d81052c3fd78f">&#9670;&nbsp;</a></span>rte_eth_representor_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#a5dedc2dcd96cb76abe4d81052c3fd78f">rte_eth_representor_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ethernet device information Ethernet device representor port type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5dedc2dcd96cb76abe4d81052c3fd78fafbd2eb57b3dcffe9fdb080ed35f1cb48"></a>RTE_ETH_REPRESENTOR_NONE&#160;</td><td class="fielddoc"><p>not a representor. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5dedc2dcd96cb76abe4d81052c3fd78fa990985066f385f9ece190fff6d64df5a"></a>RTE_ETH_REPRESENTOR_VF&#160;</td><td class="fielddoc"><p>representor of Virtual Function. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5dedc2dcd96cb76abe4d81052c3fd78fa99c8f6c6751077e31444c9fcb5030a0d"></a>RTE_ETH_REPRESENTOR_SF&#160;</td><td class="fielddoc"><p>representor of Sub Function. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5dedc2dcd96cb76abe4d81052c3fd78fa5b8188154513ceee15b854eb709da669"></a>RTE_ETH_REPRESENTOR_PF&#160;</td><td class="fielddoc"><p>representor of Physical Function. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01715">1715</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a435680ac5e5b6d7cdd569a6cad128040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435680ac5e5b6d7cdd569a6cad128040">&#9670;&nbsp;</a></span>rte_eth_err_handle_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#a435680ac5e5b6d7cdd569a6cad128040">rte_eth_err_handle_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this enumeration may change without prior notice.</dd></dl>
<p>Ethernet device error handling mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a435680ac5e5b6d7cdd569a6cad128040ae9d6ea5b2bbc13fab6e7887a3936bfdd"></a>RTE_ETH_ERROR_HANDLE_MODE_NONE&#160;</td><td class="fielddoc"><p>No error handling modes are supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a435680ac5e5b6d7cdd569a6cad128040a0dcb9d56206617105113f1ee302d3a67"></a>RTE_ETH_ERROR_HANDLE_MODE_PASSIVE&#160;</td><td class="fielddoc"><p>Passive error handling, after the PMD detects that a reset is required, the PMD reports </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779da80601fd3050782eab6bfb77ab6083812">RTE_ETH_EVENT_INTR_RESET</a> event, and the application invokes </dd>
<dd>
<a class="el" href="rte__ethdev_8h.html#a2d1e21461d6316d4378e5b530c3e0ef9">rte_eth_dev_reset</a> to recover the port. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a435680ac5e5b6d7cdd569a6cad128040af50d4c963339a498e0e89c59e705e9fb"></a>RTE_ETH_ERROR_HANDLE_MODE_PROACTIVE&#160;</td><td class="fielddoc"><p>Proactive error handling, after the PMD detects that a reset is required, the PMD reports </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779daab3a5e82ce678c742a12b7f3a546a151">RTE_ETH_EVENT_ERR_RECOVERING</a> event, do recovery internally, and finally reports the recovery result event (</dd>
<dd>
RTE_ETH_EVENT_RECOVERY_*). </dd></dl>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01728">1728</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a3fb80537ae4bbec7d12870ff4c620e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb80537ae4bbec7d12870ff4c620e96">&#9670;&nbsp;</a></span>rte_eth_fec_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#a3fb80537ae4bbec7d12870ff4c620e96">rte_eth_fec_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enum indicates the possible Forward Error Correction (FEC) modes of an ethdev port. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3fb80537ae4bbec7d12870ff4c620e96a004244bb807fadac186695a733470351"></a>RTE_ETH_FEC_NOFEC&#160;</td><td class="fielddoc"><p>FEC is off </p>
</td></tr>
<tr><td class="fieldname"><a id="a3fb80537ae4bbec7d12870ff4c620e96ad0745f1f46edb7291856c304bcc6758d"></a>RTE_ETH_FEC_AUTO&#160;</td><td class="fielddoc"><p>FEC autonegotiation modes </p>
</td></tr>
<tr><td class="fieldname"><a id="a3fb80537ae4bbec7d12870ff4c620e96a032ce951079353d1e99acc5eae5f25fc"></a>RTE_ETH_FEC_BASER&#160;</td><td class="fielddoc"><p>FEC using common algorithm </p>
</td></tr>
<tr><td class="fieldname"><a id="a3fb80537ae4bbec7d12870ff4c620e96add58fbd4b98a82c9cdbf8f5ae93dba04"></a>RTE_ETH_FEC_RS&#160;</td><td class="fielddoc"><p>FEC using RS algorithm </p>
</td></tr>
<tr><td class="fieldname"><a id="a3fb80537ae4bbec7d12870ff4c620e96af2b3d26203d2ff26c212d7d906e40278"></a>RTE_ETH_FEC_LLRS&#160;</td><td class="fielddoc"><p>FEC using LLRS algorithm </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l01978">1978</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a32ff25f28872830b629b52e5e12d8efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ff25f28872830b629b52e5e12d8efa">&#9670;&nbsp;</a></span>rte_eth_dev_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#a32ff25f28872830b629b52e5e12d8efa">rte_eth_dev_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible states of an ethdev port. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a32ff25f28872830b629b52e5e12d8efaa94ffb50804f8adc38f5a97d4bebb28fd"></a>RTE_ETH_DEV_UNUSED&#160;</td><td class="fielddoc"><p>Device is unused before being probed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a32ff25f28872830b629b52e5e12d8efaa261626b3f24873374faa78d577a8ff23"></a>RTE_ETH_DEV_ATTACHED&#160;</td><td class="fielddoc"><p>Device is attached when allocated in probing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a32ff25f28872830b629b52e5e12d8efaac4606e4f318a8ed36de5be444e75ac79"></a>RTE_ETH_DEV_REMOVED&#160;</td><td class="fielddoc"><p>Device is in removed state when plug-out is detected. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l02067">2067</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a183b2159da654a43eee045105cb8c04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183b2159da654a43eee045105cb8c04e">&#9670;&nbsp;</a></span>rte_eth_event_macsec_subtype</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#a183b2159da654a43eee045105cb8c04e">rte_eth_event_macsec_subtype</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtypes for MACsec offload event (<a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779dab7679227d47c8aa08acaba205ef95984">RTE_ETH_EVENT_MACSEC</a>) raised by Ethernet device. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a183b2159da654a43eee045105cb8c04ea0a8ceba7187aeb48b303620664e425b4"></a>RTE_ETH_SUBEVENT_MACSEC_UNKNOWN&#160;</td><td class="fielddoc"><p>Notifies unknown MACsec subevent. </p>
</td></tr>
<tr><td class="fieldname"><a id="a183b2159da654a43eee045105cb8c04eafe00490ad8c3fd46008ac8986fe1e979"></a>RTE_ETH_SUBEVENT_MACSEC_RX_SECTAG_V_EQ1&#160;</td><td class="fielddoc"><p>Subevent of RTE_ETH_EVENT_MACSEC_SECTAG_VAL_ERR sectag validation events Validation check: SecTag.TCI.V = 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="a183b2159da654a43eee045105cb8c04ea5073a9cf34dc6e90b8894bb5c02c99d7"></a>RTE_ETH_SUBEVENT_MACSEC_RX_SECTAG_E_EQ0_C_EQ1&#160;</td><td class="fielddoc"><p>Subevent of RTE_ETH_EVENT_MACSEC_SECTAG_VAL_ERR sectag validation events Validation check: SecTag.TCI.E = 0 &amp;&amp; SecTag.TCI.C = 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="a183b2159da654a43eee045105cb8c04ea7913a4b4356fc60a6721ffb5a7730846"></a>RTE_ETH_SUBEVENT_MACSEC_RX_SECTAG_SL_GTE48&#160;</td><td class="fielddoc"><p>Subevent of RTE_ETH_EVENT_MACSEC_SECTAG_VAL_ERR sectag validation events Validation check: SecTag.SL &gt;= 'd48 </p>
</td></tr>
<tr><td class="fieldname"><a id="a183b2159da654a43eee045105cb8c04eae79ba30d5d59c0a8bab5f0fc83f175bd"></a>RTE_ETH_SUBEVENT_MACSEC_RX_SECTAG_ES_EQ1_SC_EQ1&#160;</td><td class="fielddoc"><p>Subevent of RTE_ETH_EVENT_MACSEC_SECTAG_VAL_ERR sectag validation events Validation check: SecTag.TCI.ES = 1 &amp;&amp; SecTag.TCI.SC = 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="a183b2159da654a43eee045105cb8c04eab3d8bf318e2d7af1aae55fd33d58822b"></a>RTE_ETH_SUBEVENT_MACSEC_RX_SECTAG_SC_EQ1_SCB_EQ1&#160;</td><td class="fielddoc"><p>Subevent of RTE_ETH_EVENT_MACSEC_SECTAG_VAL_ERR sectag validation events Validation check: SecTag.TCI.SC = 1 &amp;&amp; SecTag.TCI.SCB = 1 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l03876">3876</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a9d6ffc5327f2a4070a9430244ff6d034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6ffc5327f2a4070a9430244ff6d034">&#9670;&nbsp;</a></span>rte_eth_event_macsec_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#a9d6ffc5327f2a4070a9430244ff6d034">rte_eth_event_macsec_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event types for MACsec offload event (<a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779dab7679227d47c8aa08acaba205ef95984">RTE_ETH_EVENT_MACSEC</a>) raised by eth device. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9d6ffc5327f2a4070a9430244ff6d034a6b05fb240c05ddd2c7898c85ba371396"></a>RTE_ETH_EVENT_MACSEC_UNKNOWN&#160;</td><td class="fielddoc"><p>Notifies unknown MACsec event. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9d6ffc5327f2a4070a9430244ff6d034ad4913ef9e3dfd4aef0fed23496757977"></a>RTE_ETH_EVENT_MACSEC_SECTAG_VAL_ERR&#160;</td><td class="fielddoc"><p>Notifies Sectag validation failure events. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9d6ffc5327f2a4070a9430244ff6d034a256d97486afd4254ff6e84a288eb6660"></a>RTE_ETH_EVENT_MACSEC_RX_SA_PN_HARD_EXP&#160;</td><td class="fielddoc"><p>Notifies Rx SA hard expiry events. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9d6ffc5327f2a4070a9430244ff6d034a51070fa924c2db4dd4b06f2319b526ce"></a>RTE_ETH_EVENT_MACSEC_RX_SA_PN_SOFT_EXP&#160;</td><td class="fielddoc"><p>Notifies Rx SA soft expiry events. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9d6ffc5327f2a4070a9430244ff6d034a6df48b957550d4c38dbcde20cefe831a"></a>RTE_ETH_EVENT_MACSEC_TX_SA_PN_HARD_EXP&#160;</td><td class="fielddoc"><p>Notifies Tx SA hard expiry events. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9d6ffc5327f2a4070a9430244ff6d034adcfb4d9ef6bd3201cbc3d35af765cf4f"></a>RTE_ETH_EVENT_MACSEC_TX_SA_PN_SOFT_EXP&#160;</td><td class="fielddoc"><p>Notifies Tx SA soft events. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9d6ffc5327f2a4070a9430244ff6d034a327231ad92a585489669705e7a6c358d"></a>RTE_ETH_EVENT_MACSEC_SA_NOT_VALID&#160;</td><td class="fielddoc"><p>Notifies Invalid SA event. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l03910">3910</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a0449571f8fe2d8751f35999a5508f8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0449571f8fe2d8751f35999a5508f8be">&#9670;&nbsp;</a></span>rte_eth_event_ipsec_subtype</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#a0449571f8fe2d8751f35999a5508f8be">rte_eth_event_ipsec_subtype</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtypes for IPsec offload event(<a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779da67808fda4e4561d661020bec76a67fdd">RTE_ETH_EVENT_IPSEC</a>) raised by eth device. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0449571f8fe2d8751f35999a5508f8beadc27e78ea9aa035fe2b596095311d68e"></a>RTE_ETH_EVENT_IPSEC_PMD_ERROR_START&#160;</td><td class="fielddoc"><p>PMD specific error start </p>
</td></tr>
<tr><td class="fieldname"><a id="a0449571f8fe2d8751f35999a5508f8bea303e7b902b14ba261426c9d1026d4b97"></a>RTE_ETH_EVENT_IPSEC_PMD_ERROR_END&#160;</td><td class="fielddoc"><p>PMD specific error end </p>
</td></tr>
<tr><td class="fieldname"><a id="a0449571f8fe2d8751f35999a5508f8bea34ce8f3e4773f164d07b1b814d5faad6"></a>RTE_ETH_EVENT_IPSEC_UNKNOWN&#160;</td><td class="fielddoc"><p>Unknown event type </p>
</td></tr>
<tr><td class="fieldname"><a id="a0449571f8fe2d8751f35999a5508f8beaa8bb18616ef0485c9fd7e493d6d909b2"></a>RTE_ETH_EVENT_IPSEC_ESN_OVERFLOW&#160;</td><td class="fielddoc"><p>Sequence number overflow </p>
</td></tr>
<tr><td class="fieldname"><a id="a0449571f8fe2d8751f35999a5508f8beae7d1101a85e644b6dd96e24c12f6287d"></a>RTE_ETH_EVENT_IPSEC_SA_TIME_EXPIRY&#160;</td><td class="fielddoc"><p>Soft time expiry of SA </p>
</td></tr>
<tr><td class="fieldname"><a id="a0449571f8fe2d8751f35999a5508f8beae20592d15276d5257d2ff81e4965b3ee"></a>RTE_ETH_EVENT_IPSEC_SA_BYTE_EXPIRY&#160;</td><td class="fielddoc"><p>Soft byte expiry of SA determined by <a class="el" href="structrte__security__ipsec__lifetime.html#a4f5c1fe8ee31cfb3d1e028acbd8a08ba">rte_security_ipsec_lifetime::bytes_soft_limit</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a0449571f8fe2d8751f35999a5508f8bea68ec479f524f28701bac5682e32a6571"></a>RTE_ETH_EVENT_IPSEC_SA_PKT_EXPIRY&#160;</td><td class="fielddoc"><p>Soft packet expiry of SA determined by <a class="el" href="structrte__security__ipsec__lifetime.html#a74404781015d5517e810f41a7ed246eb">rte_security_ipsec_lifetime::packets_soft_limit</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a0449571f8fe2d8751f35999a5508f8beaa9fbbc7302920c2ad74333b7c710e2e8"></a>RTE_ETH_EVENT_IPSEC_SA_BYTE_HARD_EXPIRY&#160;</td><td class="fielddoc"><p>Hard byte expiry of SA determined by <a class="el" href="structrte__security__ipsec__lifetime.html#a61a4b106318a2e19ffc3f70990e74356">rte_security_ipsec_lifetime::bytes_hard_limit</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a0449571f8fe2d8751f35999a5508f8beaf01b6dc325faabfc351214c9ab7df043"></a>RTE_ETH_EVENT_IPSEC_SA_PKT_HARD_EXPIRY&#160;</td><td class="fielddoc"><p>Hard packet expiry of SA determined by <a class="el" href="structrte__security__ipsec__lifetime.html#a9bc6c22de2b3356a0c1ffa75252ac3e2">rte_security_ipsec_lifetime::packets_hard_limit</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a0449571f8fe2d8751f35999a5508f8bea66a7ea9e93381cdf133f6bd86fbd85df"></a>RTE_ETH_EVENT_IPSEC_MAX&#160;</td><td class="fielddoc"><p>Max value of this enum </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l03952">3952</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a1e6788469a92700a583d06bf079d779d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6788469a92700a583d06bf079d779d">&#9670;&nbsp;</a></span>rte_eth_event_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779d">rte_eth_event_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The eth device event type for interrupt, and maybe others in the future. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1e6788469a92700a583d06bf079d779da0da770e4c0207ac9c358c974ff830716"></a>RTE_ETH_EVENT_UNKNOWN&#160;</td><td class="fielddoc"><p>unknown event type </p>
</td></tr>
<tr><td class="fieldname"><a id="a1e6788469a92700a583d06bf079d779dad4b7ae5186810a8eacba937ac45d6a73"></a>RTE_ETH_EVENT_INTR_LSC&#160;</td><td class="fielddoc"><p>lsc interrupt event </p>
</td></tr>
<tr><td class="fieldname"><a id="a1e6788469a92700a583d06bf079d779dad3ab0b7c29797255078c3fd482d432a0"></a>RTE_ETH_EVENT_QUEUE_STATE&#160;</td><td class="fielddoc"><p>queue state event (enabled/disabled) </p>
</td></tr>
<tr><td class="fieldname"><a id="a1e6788469a92700a583d06bf079d779da80601fd3050782eab6bfb77ab6083812"></a>RTE_ETH_EVENT_INTR_RESET&#160;</td><td class="fielddoc"><p>reset interrupt event, sent to VF on PF reset </p>
</td></tr>
<tr><td class="fieldname"><a id="a1e6788469a92700a583d06bf079d779da36a9f9b974cba6943252f3ff8563e067"></a>RTE_ETH_EVENT_VF_MBOX&#160;</td><td class="fielddoc"><p>message from the VF received by PF </p>
</td></tr>
<tr><td class="fieldname"><a id="a1e6788469a92700a583d06bf079d779dab7679227d47c8aa08acaba205ef95984"></a>RTE_ETH_EVENT_MACSEC&#160;</td><td class="fielddoc"><p>MACsec offload related event </p>
</td></tr>
<tr><td class="fieldname"><a id="a1e6788469a92700a583d06bf079d779da811ea894a83a9295eea28602d87fcb0d"></a>RTE_ETH_EVENT_INTR_RMV&#160;</td><td class="fielddoc"><p>device removal event </p>
</td></tr>
<tr><td class="fieldname"><a id="a1e6788469a92700a583d06bf079d779dafba97d8c075ab1b0ce5cbfe6d56cb333"></a>RTE_ETH_EVENT_NEW&#160;</td><td class="fielddoc"><p>port is probed </p>
</td></tr>
<tr><td class="fieldname"><a id="a1e6788469a92700a583d06bf079d779dac9662ab609834d045ae6d986d0c36fe7"></a>RTE_ETH_EVENT_DESTROY&#160;</td><td class="fielddoc"><p>port is released </p>
</td></tr>
<tr><td class="fieldname"><a id="a1e6788469a92700a583d06bf079d779da67808fda4e4561d661020bec76a67fdd"></a>RTE_ETH_EVENT_IPSEC&#160;</td><td class="fielddoc"><p>IPsec offload related event </p>
</td></tr>
<tr><td class="fieldname"><a id="a1e6788469a92700a583d06bf079d779dacd52a236091fd2e0481093f36cff614b"></a>RTE_ETH_EVENT_FLOW_AGED&#160;</td><td class="fielddoc"><p>New aged-out flows is detected </p>
</td></tr>
<tr><td class="fieldname"><a id="a1e6788469a92700a583d06bf079d779dafb35f538a637f0eb645556accae3ea20"></a>RTE_ETH_EVENT_RX_AVAIL_THRESH&#160;</td><td class="fielddoc"><p>Number of available Rx descriptors is smaller than the threshold. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__ethdev_8h.html#aa3ccf6e8777792403520a976d2b5bda8">rte_eth_rx_avail_thresh_set()</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a1e6788469a92700a583d06bf079d779daab3a5e82ce678c742a12b7f3a546a151"></a>RTE_ETH_EVENT_ERR_RECOVERING&#160;</td><td class="fielddoc"><p>Port recovering from a hardware or firmware error. If PMD supports proactive error recovery, it should trigger this event to notify application that it detected an error and the recovery is being started. Upon receiving the event, the application should not invoke any control path API (such as rte_eth_dev_configure/rte_eth_dev_stop...) until receiving RTE_ETH_EVENT_RECOVERY_SUCCESS or RTE_ETH_EVENT_RECOVERY_FAILED event. The PMD will set the data path pointers to dummy functions, and re-set the data path pointers to non-dummy functions before reporting RTE_ETH_EVENT_RECOVERY_SUCCESS event. It means that the application cannot send or receive any packets during this period. </p><dl class="section note"><dt>Note</dt><dd>Before the PMD reports the recovery result, the PMD may report the RTE_ETH_EVENT_ERR_RECOVERING event again, because a larger error may occur during the recovery. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a1e6788469a92700a583d06bf079d779dac0a3e334f303b04a5635dcbae94ae8b7"></a>RTE_ETH_EVENT_RECOVERY_SUCCESS&#160;</td><td class="fielddoc"><p>Port recovers successfully from the error. The PMD already re-configured the port, and the effect is the same as a restart operation. a) The following operation will be retained: (alphabetically)</p><ul>
<li>DCB configuration</li>
<li>FEC configuration</li>
<li>Flow control configuration</li>
<li>LRO configuration</li>
<li>LSC configuration</li>
<li>MTU</li>
<li>MAC address (default and those supplied by MAC address array)</li>
<li>Promiscuous and allmulticast mode</li>
<li>PTP configuration</li>
<li>Queue (Rx/Tx) settings</li>
<li>Queue statistics mappings</li>
<li>RSS configuration by rte_eth_dev_rss_xxx() family</li>
<li>Rx checksum configuration</li>
<li>Rx interrupt settings</li>
<li>Traffic management configuration</li>
<li>VLAN configuration (including filtering, tpid, strip, pvid)</li>
<li>VMDq configuration b) The following configuration maybe retained or not depending on the device capabilities:</li>
<li>flow rules (<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__ethdev_8h.html#a7413b162b5cec14de0291f104a77567e">RTE_ETH_DEV_CAPA_FLOW_RULE_KEEP</a>)</dd></dl>
</li>
<li>shared flow objects (<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__ethdev_8h.html#a553d459c88eb2ccf31f6ed0e5910847d">RTE_ETH_DEV_CAPA_FLOW_SHARED_OBJECT_KEEP</a>) c) Any other configuration will not be stored and will need to be re-configured. </dd></dl>
</li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="a1e6788469a92700a583d06bf079d779da0a5042aef87f298ff87b336314bf0a8b"></a>RTE_ETH_EVENT_RECOVERY_FAILED&#160;</td><td class="fielddoc"><p>Port recovery failed. It means that the port should not be usable anymore. The application should close the port. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1e6788469a92700a583d06bf079d779daf036573c1c236f5780892cb4fadaa7e6"></a>RTE_ETH_EVENT_MAX&#160;</td><td class="fielddoc"><p>max value of this enum </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l04017">4017</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a24cf5a6087d1da0d510c87fce00db46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24cf5a6087d1da0d510c87fce00db46a">&#9670;&nbsp;</a></span>rte_eth_cman_obj</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#a24cf5a6087d1da0d510c87fce00db46a">rte_eth_cman_obj</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumerate list of ethdev congestion management objects </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a24cf5a6087d1da0d510c87fce00db46aa67118f387d658085ef218f46c8db6699"></a>RTE_ETH_CMAN_OBJ_RX_QUEUE&#160;</td><td class="fielddoc"><p>Congestion management based on Rx queue depth </p>
</td></tr>
<tr><td class="fieldname"><a id="a24cf5a6087d1da0d510c87fce00db46aa103584ec943f07d47d5e37c13675d3ae"></a>RTE_ETH_CMAN_OBJ_RX_QUEUE_MEMPOOL&#160;</td><td class="fielddoc"><p>Congestion management based on mempool depth associated with Rx queue </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__ethdev_8h.html#a36ba70a5a6fce2c2c1f774828ba78f8d">rte_eth_rx_queue_setup()</a> </dd></dl>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l05768">5768</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aab89ef2eba4241e67212196237807077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab89ef2eba4241e67212196237807077">&#9670;&nbsp;</a></span>rte_eth_iterator_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_iterator_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__dev__iterator.html">rte_dev_iterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>devargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a device iterator.</p>
<p>This iterator allows accessing a list of devices matching some devargs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Device iterator handle initialized by the function. The fields bus_str and cls_str might be dynamically allocated, and could be freed by calling <a class="el" href="rte__ethdev_8h.html#a101d4a079237de694871c688c547c85e">rte_eth_iterator_cleanup()</a>.</td></tr>
    <tr><td class="paramname">devargs</td><td>Device description string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on successful initialization, negative otherwise. </dd></dl>

</div>
</div>
<a id="a67c79e898a7391d9eae52e4b3ba1cb79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c79e898a7391d9eae52e4b3ba1cb79">&#9670;&nbsp;</a></span>rte_eth_iterator_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rte_eth_iterator_next </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__dev__iterator.html">rte_dev_iterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterates on devices with devargs filter. The ownership is not checked.</p>
<p>The next port ID is returned, and the iterator is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Device iterator handle initialized by <a class="el" href="rte__ethdev_8h.html#aab89ef2eba4241e67212196237807077">rte_eth_iterator_init()</a>. Some fields bus_str and cls_str might be freed when no more port is found, by calling <a class="el" href="rte__ethdev_8h.html#a101d4a079237de694871c688c547c85e">rte_eth_iterator_cleanup()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A port ID if found, RTE_MAX_ETHPORTS otherwise. </dd></dl>

</div>
</div>
<a id="a101d4a079237de694871c688c547c85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101d4a079237de694871c688c547c85e">&#9670;&nbsp;</a></span>rte_eth_iterator_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_eth_iterator_cleanup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__dev__iterator.html">rte_dev_iterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free some allocated fields of the iterator.</p>
<p>This function is automatically called by <a class="el" href="rte__ethdev_8h.html#a67c79e898a7391d9eae52e4b3ba1cb79">rte_eth_iterator_next()</a> on the last iteration (i.e. when no more matching port is found).</p>
<p>It is safe to call this function twice; it will do nothing more.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Device iterator handle initialized by <a class="el" href="rte__ethdev_8h.html#aab89ef2eba4241e67212196237807077">rte_eth_iterator_init()</a>. The fields bus_str and cls_str are freed if needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9c80e6e25ce9d6e8acd4e720cc64c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c80e6e25ce9d6e8acd4e720cc64c36">&#9670;&nbsp;</a></span>__rte_aligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__extension__ struct <a class="el" href="structrte__eth__link.html">rte_eth_link</a> <a class="el" href="struct____rte__aligned.html">__rte_aligned</a> </td>
          <td>(</td>
          <td class="paramtype">8&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>aligned for atomic64 read/write </p>

</div>
</div>
<a id="a0bb6f86407ad82bfa9ba884b81e4f33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb6f86407ad82bfa9ba884b81e4f33e">&#9670;&nbsp;</a></span>rte_eth_rss_hf_refine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t rte_eth_rss_hf_refine </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>rss_hf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For input set change of hash filter, if SRC_ONLY and DST_ONLY of the same level are used simultaneously, it is the same case as none of them are added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rss_hf</td><td>RSS types with SRC/DST_ONLY. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RSS types. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00660">660</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a4b6a29579d85e90b52e629139144aebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6a29579d85e90b52e629139144aebc">&#9670;&nbsp;</a></span>rte_eth_find_next_owned_by()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t rte_eth_find_next_owned_by </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>owner_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterates over valid ethdev ports owned by a specific owner.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The ID of the next possible valid owned port. </td></tr>
    <tr><td class="paramname">owner_id</td><td>The owner identifier. RTE_ETH_DEV_NO_OWNER means iterate over all valid ownerless ports. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next valid port ID owned by owner_id, RTE_MAX_ETHPORTS if there is none. </dd></dl>

</div>
</div>
<a id="a572cbdd554578f35c4480f1397e7dea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572cbdd554578f35c4480f1397e7dea0">&#9670;&nbsp;</a></span>rte_eth_find_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rte_eth_find_next </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterates over valid ethdev ports.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The ID of the next possible valid port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next valid port ID, RTE_MAX_ETHPORTS if there is none. </dd></dl>

</div>
</div>
<a id="ae67f6b336d3cd3f90cecc41e629ebbe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67f6b336d3cd3f90cecc41e629ebbe1">&#9670;&nbsp;</a></span>rte_eth_find_next_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rte_eth_find_next_of </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct rte_device *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterates over ethdev ports of a specified device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id_start</td><td>The ID of the next possible valid port. </td></tr>
    <tr><td class="paramname">parent</td><td>The generic device behind the ports to iterate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next port ID of the device, possibly port_id_start, RTE_MAX_ETHPORTS if there is none. </dd></dl>

</div>
</div>
<a id="a967a92a5681b48c414a6496d0e134789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967a92a5681b48c414a6496d0e134789">&#9670;&nbsp;</a></span>rte_eth_find_next_sibling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rte_eth_find_next_sibling </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>ref_port_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterates over sibling ethdev ports (i.e. sharing the same rte_device).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id_start</td><td>The ID of the next possible valid sibling port. </td></tr>
    <tr><td class="paramname">ref_port_id</td><td>The ID of a reference port to compare rte_device with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next sibling port ID, possibly port_id_start or ref_port_id itself, RTE_MAX_ETHPORTS if there is none. </dd></dl>

</div>
</div>
<a id="ad6817cc801bf0faa566f52d382214457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6817cc801bf0faa566f52d382214457">&#9670;&nbsp;</a></span>rte_eth_dev_owner_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_owner_new </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>owner_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a new unique owner identifier. An owner identifier is used to owns Ethernet devices by only one DPDK entity to avoid multiple management of device by different entities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner_id</td><td>Owner identifier pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Negative errno value on error, 0 on success. </dd></dl>

</div>
</div>
<a id="aaee73817b1baaea6da5bb5d4c18c578f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee73817b1baaea6da5bb5d4c18c578f">&#9670;&nbsp;</a></span>rte_eth_dev_owner_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_owner_set </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct rte_eth_dev_owner *&#160;</td>
          <td class="paramname"><em>owner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set an Ethernet device owner.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The identifier of the port to own. </td></tr>
    <tr><td class="paramname">owner</td><td>The owner pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Negative errno value on error, 0 on success. </dd></dl>

</div>
</div>
<a id="ac333918086a96a28005ec8984d86f459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac333918086a96a28005ec8984d86f459">&#9670;&nbsp;</a></span>rte_eth_dev_owner_unset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_owner_unset </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>owner_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unset Ethernet device owner to make the device ownerless.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The identifier of port to make ownerless. </td></tr>
    <tr><td class="paramname">owner_id</td><td>The owner identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno value on error. </dd></dl>

</div>
</div>
<a id="a7f344baaff829a27a0a46b8d1be93004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f344baaff829a27a0a46b8d1be93004">&#9670;&nbsp;</a></span>rte_eth_dev_owner_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_owner_delete </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>owner_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove owner from all Ethernet devices owned by a specific owner.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner_id</td><td>The owner identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno value on error. </dd></dl>

</div>
</div>
<a id="a37091b7824c8cf16b1a97c8befcd84fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37091b7824c8cf16b1a97c8befcd84fd">&#9670;&nbsp;</a></span>rte_eth_dev_owner_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_owner_get </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct rte_eth_dev_owner *&#160;</td>
          <td class="paramname"><em>owner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the owner of an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier. </td></tr>
    <tr><td class="paramname">owner</td><td>The owner structure pointer to fill. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno value on error.. </dd></dl>

</div>
</div>
<a id="a9ab708089665bebcd65cefe5383b24f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab708089665bebcd65cefe5383b24f2">&#9670;&nbsp;</a></span>rte_eth_dev_count_avail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rte_eth_dev_count_avail </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of ports which are usable for the application.</p>
<p>These devices must be iterated by using the macro <code>RTE_ETH_FOREACH_DEV</code> or <code>RTE_ETH_FOREACH_DEV_OWNED_BY</code> to deal with non-contiguous ranges of devices.</p>
<dl class="section return"><dt>Returns</dt><dd>The count of available Ethernet devices. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a68">examples/ipv4_multicast/main.c</a>, and <a class="el" href="examples_2syntony_2main_8c-example.html#a68">examples/syntony/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="aee5929c07b0f1d3cb235784a6f33010f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5929c07b0f1d3cb235784a6f33010f">&#9670;&nbsp;</a></span>rte_eth_dev_count_total()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rte_eth_dev_count_total </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the total number of ports which are allocated.</p>
<p>Some devices may not be available for the application.</p>
<dl class="section return"><dt>Returns</dt><dd>The total count of Ethernet devices. </dd></dl>

</div>
</div>
<a id="ab06b3f5253aaea7fa0efdef786ff44f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06b3f5253aaea7fa0efdef786ff44f2">&#9670;&nbsp;</a></span>rte_eth_speed_bitflag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rte_eth_speed_bitflag </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>speed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>duplex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a numerical speed in Mbps to a bitmap flag that can be used in the bitmap link_speeds of the struct <a class="el" href="structrte__eth__conf.html">rte_eth_conf</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">speed</td><td>Numerical speed value in Mbps </td></tr>
    <tr><td class="paramname">duplex</td><td>RTE_ETH_LINK_[HALF/FULL]_DUPLEX (only for 10/100M speeds) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the speed cannot be mapped </dd></dl>

</div>
</div>
<a id="ad4f96cc61e41ad50346d0096c95053b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f96cc61e41ad50346d0096c95053b0">&#9670;&nbsp;</a></span>rte_eth_dev_rx_offload_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rte_eth_dev_rx_offload_name </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offload</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get RTE_ETH_RX_OFFLOAD_* flag name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offload</td><td>Offload flag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Offload name or 'UNKNOWN' if the flag cannot be recognised. </dd></dl>

</div>
</div>
<a id="aa034be0bc72cc626ade4094c036208f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa034be0bc72cc626ade4094c036208f4">&#9670;&nbsp;</a></span>rte_eth_dev_tx_offload_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rte_eth_dev_tx_offload_name </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offload</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get RTE_ETH_TX_OFFLOAD_* flag name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offload</td><td>Offload flag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Offload name or 'UNKNOWN' if the flag cannot be recognised. </dd></dl>

</div>
</div>
<a id="a5224e542eb1ee1cde8848519da015bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5224e542eb1ee1cde8848519da015bd2">&#9670;&nbsp;</a></span>rte_eth_dev_capability_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental const char* rte_eth_dev_capability_name </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>capability</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Get RTE_ETH_DEV_CAPA_* flag name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capability</td><td>Capability flag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Capability name or 'UNKNOWN' if the flag cannot be recognized. </dd></dl>

</div>
</div>
<a id="a1a7d3a20b102fee222541fda50fd87bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7d3a20b102fee222541fda50fd87bd">&#9670;&nbsp;</a></span>rte_eth_dev_configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_configure </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_rx_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_tx_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__eth__conf.html">rte_eth_conf</a> *&#160;</td>
          <td class="paramname"><em>eth_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure an Ethernet device. This function must be invoked first before any other function in the Ethernet API. This function can also be re-invoked when a device is in the stopped state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device to configure. </td></tr>
    <tr><td class="paramname">nb_rx_queue</td><td>The number of receive queues to set up for the Ethernet device. </td></tr>
    <tr><td class="paramname">nb_tx_queue</td><td>The number of transmit queues to set up for the Ethernet device. </td></tr>
    <tr><td class="paramname">eth_conf</td><td>The pointer to the configuration data to be used for the Ethernet device. The <em><a class="el" href="structrte__eth__conf.html">rte_eth_conf</a></em> structure includes:<ul>
<li>the hardware offload features to activate, with dedicated fields for each statically configurable offload hardware feature provided by Ethernet devices, such as IP checksum or VLAN tag stripping for example. The Rx offload bitfield API is obsolete and will be deprecated. Applications should set the ignore_bitfield_offloads bit on <em>rxmode</em> structure and use offloads field to set per-port offloads instead.</li>
<li>Any offloading set in eth_conf-&gt;[rt]xmode.offloads must be within the [rt]x_offload_capa returned from <a class="el" href="rte__ethdev_8h.html#a7593f4fff04f4ae1b1d718db7ca7dc8c">rte_eth_dev_info_get()</a>. Any type of device supported offloading set in the input argument eth_conf-&gt;[rt]xmode.offloads to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a> is enabled on all queues and it can't be disabled in rte_eth_[rt]x_queue_setup()</li>
<li>the Receive Side Scaling (RSS) configuration when using multiple Rx queues per port. Any RSS hash function set in eth_conf-&gt;rss_conf.rss_hf must be within the flow_type_rss_offloads provided by drivers via <a class="el" href="rte__ethdev_8h.html#a7593f4fff04f4ae1b1d718db7ca7dc8c">rte_eth_dev_info_get()</a> API.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Embedding all configuration information in a single data structure is the more flexible method that allows the addition of new features without changing the syntax of the API. </p><dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, device configured.</li>
<li>&lt;0: Error code returned by the driver configuration function. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a74">examples/ipv4_multicast/main.c</a>, <a class="el" href="examples_2receiver_2main_8c-example.html#a9">examples/receiver/main.c</a>, <a class="el" href="examples_2sender_2main_8c-example.html#a9">examples/sender/main.c</a>, and <a class="el" href="examples_2syntony_2main_8c-example.html#a74">examples/syntony/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a05e5d23e6c13b4f23d40c6c2067c1422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e5d23e6c13b4f23d40c6c2067c1422">&#9670;&nbsp;</a></span>rte_eth_dev_is_removed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_is_removed </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if an Ethernet device was physically removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 when the Ethernet device is removed, otherwise 0. </dd></dl>

</div>
</div>
<a id="a36ba70a5a6fce2c2c1f774828ba78f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ba70a5a6fce2c2c1f774828ba78f8d">&#9670;&nbsp;</a></span>rte_eth_rx_queue_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_rx_queue_setup </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rx_queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_rx_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__eth__rxconf.html">rte_eth_rxconf</a> *&#160;</td>
          <td class="paramname"><em>rx_conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mb_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate and set up a receive queue for an Ethernet device.</p>
<p>The function allocates a contiguous block of memory for <em>nb_rx_desc</em> receive descriptors from a memory zone associated with <em>socket_id</em> and initializes each receive descriptor with a network buffer allocated from the memory pool <em>mb_pool</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">rx_queue_id</td><td>The index of the receive queue to set up. The value must be in the range [0, nb_rx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">nb_rx_desc</td><td>The number of receive descriptors to allocate for the receive ring. </td></tr>
    <tr><td class="paramname">socket_id</td><td>The <em>socket_id</em> argument is the socket identifier in case of NUMA. The value can be <em>SOCKET_ID_ANY</em> if there is no NUMA constraint for the DMA memory allocated for the receive descriptors of the ring. </td></tr>
    <tr><td class="paramname">rx_conf</td><td>The pointer to the configuration data to be used for the receive queue. NULL value is allowed, in which case default Rx configuration will be used. The <em>rx_conf</em> structure contains an <em>rx_thresh</em> structure with the values of the Prefetch, Host, and Write-Back threshold registers of the receive ring. In addition it contains the hardware offloads features to activate using the RTE_ETH_RX_OFFLOAD_* flags. If an offloading set in rx_conf-&gt;offloads hasn't been set in the input argument eth_conf-&gt;rxmode.offloads to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>, it is a new added offloading, it must be per-queue type and it is enabled for the queue. No need to repeat any bit in rx_conf-&gt;offloads which has already been enabled in <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a> at port level. An offloading enabled at port level can't be disabled at queue level. The configuration structure also contains the pointer to the array of the receiving buffer segment descriptions, see rx_seg and rx_nseg fields, this extended configuration might be used by split offloads like RTE_ETH_RX_OFFLOAD_BUFFER_SPLIT. If mb_pool is not NULL, the extended configuration fields must be set to NULL and zero. </td></tr>
    <tr><td class="paramname">mb_pool</td><td>The pointer to the memory pool from which to allocate <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> network memory buffers to populate each descriptor of the receive ring. There are two options to provide Rx buffer configuration:<ul>
<li>single pool: mb_pool is not NULL, rx_conf.rx_nseg is 0.</li>
<li>multiple segments description: mb_pool is NULL, rx_conf.rx_seg is not NULL, rx_conf.rx_nseg is not 0. Taken only if flag RTE_ETH_RX_OFFLOAD_BUFFER_SPLIT is set in offloads.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, receive queue correctly set up.</li>
<li>-EIO: if device is removed.</li>
<li>-ENODEV: if <em>port_id</em> is invalid.</li>
<li>-EINVAL: The memory pool pointer is null or the size of network buffers which can be allocated from this memory pool does not fit the various buffer sizes allowed by the device controller.</li>
<li>-ENOMEM: Unable to allocate the receive ring descriptors or to allocate network memory buffers from the memory pool when initializing receive descriptors. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a78">examples/ipv4_multicast/main.c</a>, <a class="el" href="examples_2receiver_2main_8c-example.html#a10">examples/receiver/main.c</a>, <a class="el" href="examples_2sender_2main_8c-example.html#a10">examples/sender/main.c</a>, and <a class="el" href="examples_2syntony_2main_8c-example.html#a78">examples/syntony/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a7297b36c033fbeaaae77d31de13cc4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7297b36c033fbeaaae77d31de13cc4bc">&#9670;&nbsp;</a></span>rte_eth_rx_hairpin_queue_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_rx_hairpin_queue_setup </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rx_queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_rx_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__eth__hairpin__conf.html">rte_eth_hairpin_conf</a> *&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice</dd></dl>
<p>Allocate and set up a hairpin receive queue for an Ethernet device.</p>
<p>The function set up the selected queue to be used in hairpin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">rx_queue_id</td><td>The index of the receive queue to set up. The value must be in the range [0, nb_rx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">nb_rx_desc</td><td>The number of receive descriptors to allocate for the receive ring. 0 means the PMD will use default value. </td></tr>
    <tr><td class="paramname">conf</td><td>The pointer to the hairpin configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENODEV) if <em>port_id</em> is invalid.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter.</li>
<li>(-ENOMEM) if unable to allocate the resources. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a796c2f20778984c6f41b271e36bae50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a796c2f20778984c6f41b271e36bae50e">&#9670;&nbsp;</a></span>rte_eth_tx_queue_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_tx_queue_setup </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tx_queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_tx_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__eth__txconf.html">rte_eth_txconf</a> *&#160;</td>
          <td class="paramname"><em>tx_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate and set up a transmit queue for an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">tx_queue_id</td><td>The index of the transmit queue to set up. The value must be in the range [0, nb_tx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">nb_tx_desc</td><td>The number of transmit descriptors to allocate for the transmit ring. </td></tr>
    <tr><td class="paramname">socket_id</td><td>The <em>socket_id</em> argument is the socket identifier in case of NUMA. Its value can be <em>SOCKET_ID_ANY</em> if there is no NUMA constraint for the DMA memory allocated for the transmit descriptors of the ring. </td></tr>
    <tr><td class="paramname">tx_conf</td><td>The pointer to the configuration data to be used for the transmit queue. NULL value is allowed, in which case default Tx configuration will be used. The <em>tx_conf</em> structure contains the following data:<ul>
<li>The <em>tx_thresh</em> structure with the values of the Prefetch, Host, and Write-Back threshold registers of the transmit ring. When setting Write-Back threshold to the value greater then zero, <em>tx_rs_thresh</em> value should be explicitly set to one.</li>
<li>The <em>tx_free_thresh</em> value indicates the [minimum] number of network buffers that must be pending in the transmit ring to trigger their [implicit] freeing by the driver transmit function.</li>
<li>The <em>tx_rs_thresh</em> value indicates the [minimum] number of transmit descriptors that must be pending in the transmit ring before setting the RS bit on a descriptor by the driver transmit function. The <em>tx_rs_thresh</em> value should be less or equal then <em>tx_free_thresh</em> value, and both of them should be less then <em>nb_tx_desc</em> - 3.</li>
<li><p class="startli">The <em>offloads</em> member contains Tx offloads to be enabled. If an offloading set in tx_conf-&gt;offloads hasn't been set in the input argument eth_conf-&gt;txmode.offloads to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>, it is a new added offloading, it must be per-queue type and it is enabled for the queue. No need to repeat any bit in tx_conf-&gt;offloads which has already been enabled in <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a> at port level. An offloading enabled at port level can't be disabled at queue level.</p>
<p class="startli">Note that setting <em>tx_free_thresh</em> or <em>tx_rs_thresh</em> value to 0 forces the transmit function to use default values. </p>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, the transmit queue is correctly set up.</li>
<li>-ENOMEM: Unable to allocate the transmit ring descriptors. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a84">examples/ipv4_multicast/main.c</a>, <a class="el" href="examples_2receiver_2main_8c-example.html#a12">examples/receiver/main.c</a>, <a class="el" href="examples_2sender_2main_8c-example.html#a12">examples/sender/main.c</a>, and <a class="el" href="examples_2syntony_2main_8c-example.html#a84">examples/syntony/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="acd04b893212e9b643b8762344a97cf76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd04b893212e9b643b8762344a97cf76">&#9670;&nbsp;</a></span>rte_eth_tx_hairpin_queue_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_tx_hairpin_queue_setup </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tx_queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_tx_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__eth__hairpin__conf.html">rte_eth_hairpin_conf</a> *&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice</dd></dl>
<p>Allocate and set up a transmit hairpin queue for an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">tx_queue_id</td><td>The index of the transmit queue to set up. The value must be in the range [0, nb_tx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">nb_tx_desc</td><td>The number of transmit descriptors to allocate for the transmit ring. 0 to set default PMD value. </td></tr>
    <tr><td class="paramname">conf</td><td>The hairpin configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENODEV) if <em>port_id</em> is invalid.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter.</li>
<li>(-ENOMEM) if unable to allocate the resources. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab30a9a81670bd4a24d2251dd39e17e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30a9a81670bd4a24d2251dd39e17e94">&#9670;&nbsp;</a></span>rte_eth_hairpin_get_peer_ports()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_hairpin_get_peer_ports </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>peer_ports</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice</dd></dl>
<p>Get all the hairpin peer Rx / Tx ports of the current port. The caller should ensure that the array is large enough to save the ports list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">peer_ports</td><td>Pointer to the array to store the peer ports list. </td></tr>
    <tr><td class="paramname">len</td><td>Length of the array to store the port identifiers. </td></tr>
    <tr><td class="paramname">direction</td><td>Current port to peer port direction positive - current used as Tx to get all peer Rx ports. zero - current used as Rx to get all peer Tx ports.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0 or positive) actual peer ports number.</li>
<li>(-EINVAL) if bad parameter.</li>
<li>(-ENODEV) if <em>port_id</em> invalid</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>Others detailed errors from PMDs. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac2ff52a373e6d9ee2918771c96c5c1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ff52a373e6d9ee2918771c96c5c1a0">&#9670;&nbsp;</a></span>rte_eth_hairpin_bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_hairpin_bind </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tx_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rx_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice</dd></dl>
<p>Bind all hairpin Tx queues of one port to the Rx queues of the peer port. It is only allowed to call this function after all hairpin queues are configured properly and the devices are in started state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx_port</td><td>The identifier of the Tx port. </td></tr>
    <tr><td class="paramname">rx_port</td><td>The identifier of peer Rx port. RTE_MAX_ETHPORTS is allowed for the traversal of all devices. Rx port ID could have the same value as Tx port ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENODEV) if Tx port ID is invalid.</li>
<li>(-EBUSY) if device is not in started state.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>Others detailed errors from PMDs. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab0d424a4ac069442011f8e7a2eb8cef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d424a4ac069442011f8e7a2eb8cef8">&#9670;&nbsp;</a></span>rte_eth_hairpin_unbind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_hairpin_unbind </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tx_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rx_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice</dd></dl>
<p>Unbind all hairpin Tx queues of one port from the Rx queues of the peer port. This should be called before closing the Tx or Rx devices, if the bind function is called before. After unbinding the hairpin ports pair, it is allowed to bind them again. Changing queues configuration should be after stopping the device(s).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx_port</td><td>The identifier of the Tx port. </td></tr>
    <tr><td class="paramname">rx_port</td><td>The identifier of peer Rx port. RTE_MAX_ETHPORTS is allowed for traversal of all devices. Rx port ID could have the same value as Tx port ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENODEV) if Tx port ID is invalid.</li>
<li>(-EBUSY) if device is in stopped state.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>Others detailed errors from PMDs. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a3a3152a1e9a531bb905ee7089343056d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3152a1e9a531bb905ee7089343056d">&#9670;&nbsp;</a></span>rte_eth_dev_count_aggr_ports()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_dev_count_aggr_ports </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Get the number of aggregated ports of the DPDK port (specified with port_id). It is used when multiple ports are aggregated into a single one.</p>
<p>For the regular physical port doesn't have aggregated ports, the number of aggregated ports is reported as 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(&gt;=0) the number of aggregated port if success. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0d7315efad73b17c7d11e36c23b6c29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7315efad73b17c7d11e36c23b6c29d">&#9670;&nbsp;</a></span>rte_eth_dev_map_aggr_tx_affinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_dev_map_aggr_tx_affinity </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tx_queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>affinity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Map a Tx queue with an aggregated port of the DPDK port (specified with port_id). When multiple ports are aggregated into a single one, it allows to choose which port to use for Tx via a queue.</p>
<p>The application should use <a class="el" href="rte__ethdev_8h.html#a0d7315efad73b17c7d11e36c23b6c29d">rte_eth_dev_map_aggr_tx_affinity()</a> after <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>, <a class="el" href="rte__ethdev_8h.html#a796c2f20778984c6f41b271e36bae50e">rte_eth_tx_queue_setup()</a>, and before <a class="el" href="rte__ethdev_8h.html#afdc834c1c52e9fb512301990468ca7c2">rte_eth_dev_start()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The identifier of the port used in <a class="el" href="rte__ethdev_8h.html#a83e56cabbd31637efd648e3fc010392b">rte_eth_tx_burst()</a>. </td></tr>
    <tr><td class="paramname">tx_queue_id</td><td>The index of the transmit queue used in <a class="el" href="rte__ethdev_8h.html#a83e56cabbd31637efd648e3fc010392b">rte_eth_tx_burst()</a>. The value must be in the range [0, nb_tx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">affinity</td><td>The number of the aggregated port. Value 0 means no affinity and traffic could be routed to any aggregated port. The first aggregated port is number 1 and so on. The maximum number is given by <a class="el" href="rte__ethdev_8h.html#a3a3152a1e9a531bb905ee7089343056d">rte_eth_dev_count_aggr_ports()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if successful. Non-zero otherwise. </dd></dl>

</div>
</div>
<a id="ad032e25f712e6ffeb0c19eab1ec1fd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad032e25f712e6ffeb0c19eab1ec1fd2e">&#9670;&nbsp;</a></span>rte_eth_dev_socket_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_socket_id </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the NUMA socket to which an Ethernet device is connected</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The NUMA socket ID which the Ethernet device is connected to.</li>
<li>-1 (which translates to SOCKET_ID_ANY) if the socket could not be determined. rte_errno is then set to:<ul>
<li>EINVAL is the port_id is invalid,</li>
<li>0 is the socket could not be determined, </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a79">examples/ipv4_multicast/main.c</a>, <a class="el" href="examples_2receiver_2main_8c-example.html#a11">examples/receiver/main.c</a>, <a class="el" href="examples_2sender_2main_8c-example.html#a11">examples/sender/main.c</a>, and <a class="el" href="examples_2syntony_2main_8c-example.html#a79">examples/syntony/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a22dcfd3f5f2b34f657131d66132e23a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22dcfd3f5f2b34f657131d66132e23a7">&#9670;&nbsp;</a></span>rte_eth_dev_is_valid_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_is_valid_port </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if port_id of device is attached</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if port is out of range or not attached</li>
<li>1 if device is attached </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a80a6aad1fb6a064dd8d68cc1130831fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a6aad1fb6a064dd8d68cc1130831fe">&#9670;&nbsp;</a></span>rte_eth_rx_queue_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_rx_queue_is_valid </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice.</dd></dl>
<p>Check if Rx queue is valid. If the queue has been setup, it is considered valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the receive queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-ENODEV: if port_id is invalid.</li>
<li>-EINVAL: if queue_id is out of range or queue has not been setup.</li>
<li>0 if Rx queue is valid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad39535037b46be766d961d58fd337841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39535037b46be766d961d58fd337841">&#9670;&nbsp;</a></span>rte_eth_tx_queue_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_tx_queue_is_valid </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice.</dd></dl>
<p>Check if Tx queue is valid. If the queue has been setup, it is considered valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the transmit queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-ENODEV: if port_id is invalid.</li>
<li>-EINVAL: if queue_id is out of range or queue has not been setup.</li>
<li>0 if Tx queue is valid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="acde49b964009fcfdcab149ccc81d43d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde49b964009fcfdcab149ccc81d43d8">&#9670;&nbsp;</a></span>rte_eth_dev_rx_queue_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_rx_queue_start </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rx_queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start specified Rx queue of a port. It is used when rx_deferred_start flag of the specified queue is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device </td></tr>
    <tr><td class="paramname">rx_queue_id</td><td>The index of the Rx queue to update the ring. The value must be in the range [0, nb_rx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, the receive queue is started.</li>
<li>-ENODEV: if <em>port_id</em> is invalid.</li>
<li>-EINVAL: The queue_id out of range or belong to hairpin.</li>
<li>-EIO: if device is removed.</li>
<li>-ENOTSUP: The function not supported in PMD. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af3e11cec1cbed5a1f808e745fe441d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e11cec1cbed5a1f808e745fe441d24">&#9670;&nbsp;</a></span>rte_eth_dev_rx_queue_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_rx_queue_stop </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rx_queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop specified Rx queue of a port</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device </td></tr>
    <tr><td class="paramname">rx_queue_id</td><td>The index of the Rx queue to update the ring. The value must be in the range [0, nb_rx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, the receive queue is stopped.</li>
<li>-ENODEV: if <em>port_id</em> is invalid.</li>
<li>-EINVAL: The queue_id out of range or belong to hairpin.</li>
<li>-EIO: if device is removed.</li>
<li>-ENOTSUP: The function not supported in PMD. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad1524c8f84330b7ae60fb0ccd91bffd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1524c8f84330b7ae60fb0ccd91bffd9">&#9670;&nbsp;</a></span>rte_eth_dev_tx_queue_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_tx_queue_start </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tx_queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start Tx for specified queue of a port. It is used when tx_deferred_start flag of the specified queue is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device </td></tr>
    <tr><td class="paramname">tx_queue_id</td><td>The index of the Tx queue to update the ring. The value must be in the range [0, nb_tx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, the transmit queue is started.</li>
<li>-ENODEV: if <em>port_id</em> is invalid.</li>
<li>-EINVAL: The queue_id out of range or belong to hairpin.</li>
<li>-EIO: if device is removed.</li>
<li>-ENOTSUP: The function not supported in PMD. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7d5cfa35edda89bb3480d06ae32423dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5cfa35edda89bb3480d06ae32423dd">&#9670;&nbsp;</a></span>rte_eth_dev_tx_queue_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_tx_queue_stop </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tx_queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop specified Tx queue of a port</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device </td></tr>
    <tr><td class="paramname">tx_queue_id</td><td>The index of the Tx queue to update the ring. The value must be in the range [0, nb_tx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, the transmit queue is stopped.</li>
<li>-ENODEV: if <em>port_id</em> is invalid.</li>
<li>-EINVAL: The queue_id out of range or belong to hairpin.</li>
<li>-EIO: if device is removed.</li>
<li>-ENOTSUP: The function not supported in PMD. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afdc834c1c52e9fb512301990468ca7c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc834c1c52e9fb512301990468ca7c2">&#9670;&nbsp;</a></span>rte_eth_dev_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_start </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an Ethernet device.</p>
<p>The device start step is the last one and consists of setting the configured offload features and in starting the transmit and the receive units of the device.</p>
<p>Device RTE_ETH_DEV_NOLIVE_MAC_ADDR flag causes MAC address to be set before PMD port start callback function is invoked.</p>
<p>All device queues (except form deferred start queues) status should be <code>RTE_ETH_QUEUE_STATE_STARTED</code> after start.</p>
<p>On success, all basic functions exported by the Ethernet API (link status, receive/transmit, and so on) can be invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, Ethernet device started.</li>
<li>-EAGAIN: If start operation must be retried.</li>
<li>&lt;0: Error code of the driver device start function. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a87">examples/ipv4_multicast/main.c</a>, <a class="el" href="examples_2receiver_2main_8c-example.html#a13">examples/receiver/main.c</a>, <a class="el" href="examples_2sender_2main_8c-example.html#a13">examples/sender/main.c</a>, and <a class="el" href="examples_2syntony_2main_8c-example.html#a87">examples/syntony/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a6fc010cf6216331c50bc02d2fd4e614f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc010cf6216331c50bc02d2fd4e614f">&#9670;&nbsp;</a></span>rte_eth_dev_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_stop </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop an Ethernet device. The device can be restarted with a call to <a class="el" href="rte__ethdev_8h.html#afdc834c1c52e9fb512301990468ca7c2">rte_eth_dev_start()</a></p>
<p>All device queues status should be <code>RTE_ETH_QUEUE_STATE_STOPPED</code> after stop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, Ethernet device stopped.</li>
<li>-EBUSY: If stopping the port is not allowed in current state.</li>
<li>&lt;0: Error code of the driver device stop function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a51d7a0d2bb4202f9ebf9f174ba1f6e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d7a0d2bb4202f9ebf9f174ba1f6e5c">&#9670;&nbsp;</a></span>rte_eth_dev_set_link_up()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_link_up </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Link up an Ethernet device.</p>
<p>Set device link up will re-enable the device Rx/Tx functionality after it is previously set device linked down.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, Ethernet device linked up.</li>
<li>&lt;0: Error code of the driver device link up function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1447019543857c113d63a0f4ac7dd7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1447019543857c113d63a0f4ac7dd7c0">&#9670;&nbsp;</a></span>rte_eth_dev_set_link_down()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_link_down </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Link down an Ethernet device. The device Rx/Tx functionality will be disabled if success, and it can be re-enabled with a call to <a class="el" href="rte__ethdev_8h.html#a51d7a0d2bb4202f9ebf9f174ba1f6e5c">rte_eth_dev_set_link_up()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2c7507787a5520e8049fff94432169e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c7507787a5520e8049fff94432169e">&#9670;&nbsp;</a></span>rte_eth_dev_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_close </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close a stopped Ethernet device. The device cannot be restarted! The function frees all port resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Zero if the port is closed successfully.</li>
<li>Negative if something went wrong. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2d1e21461d6316d4378e5b530c3e0ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1e21461d6316d4378e5b530c3e0ef9">&#9670;&nbsp;</a></span>rte_eth_dev_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_reset </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset a Ethernet device and keep its port ID.</p>
<p>When a port has to be reset passively, the DPDK application can invoke this function. For example when a PF is reset, all its VFs should also be reset. Normally a DPDK application can invoke this function when RTE_ETH_EVENT_INTR_RESET event is detected, but can also use it to start a port reset in other circumstances.</p>
<p>When this function is called, it first stops the port and then calls the PMD specific dev_uninit( ) and dev_init( ) to return the port to initial state, in which no Tx and Rx queues are setup, as if the port has been reset and not started. The port keeps the port ID it had before the function call.</p>
<p>After calling <a class="el" href="rte__ethdev_8h.html#a2d1e21461d6316d4378e5b530c3e0ef9">rte_eth_dev_reset( )</a>, the application should use <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure( )</a>, <a class="el" href="rte__ethdev_8h.html#a36ba70a5a6fce2c2c1f774828ba78f8d">rte_eth_rx_queue_setup( )</a>, <a class="el" href="rte__ethdev_8h.html#a796c2f20778984c6f41b271e36bae50e">rte_eth_tx_queue_setup( )</a>, and <a class="el" href="rte__ethdev_8h.html#afdc834c1c52e9fb512301990468ca7c2">rte_eth_dev_start( )</a> to reconfigure the device as appropriate.</p>
<p>Note: To avoid unexpected behavior, the application should stop calling Tx and Rx functions before calling <a class="el" href="rte__ethdev_8h.html#a2d1e21461d6316d4378e5b530c3e0ef9">rte_eth_dev_reset( )</a>. For thread safety, all these controlling functions should be called from the same thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENODEV) if <em>port_id</em> is invalid.</li>
<li>(-ENOTSUP) if hardware doesn't support this function.</li>
<li>(-EPERM) if not ran from the primary process.</li>
<li>(-EIO) if re-initialisation failed or device is removed.</li>
<li>(-ENOMEM) if the reset failed due to OOM.</li>
<li>(-EAGAIN) if the reset temporarily failed and should be retried later. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5dd1dedaa45f05c72bcc35495e441e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd1dedaa45f05c72bcc35495e441e91">&#9670;&nbsp;</a></span>rte_eth_promiscuous_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_promiscuous_enable </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable receipt in promiscuous mode for an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if support for promiscuous_enable() does not exist for the device.</li>
<li>(-ENODEV) if <em>port_id</em> invalid. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2receiver_2main_8c-example.html#a14">examples/receiver/main.c</a>, and <a class="el" href="examples_2sender_2main_8c-example.html#a14">examples/sender/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a7a39728529379b48f941f5d34f04d2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a39728529379b48f941f5d34f04d2bd">&#9670;&nbsp;</a></span>rte_eth_promiscuous_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_promiscuous_disable </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable receipt in promiscuous mode for an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if support for promiscuous_disable() does not exist for the device.</li>
<li>(-ENODEV) if <em>port_id</em> invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a499736f02d96faf9a680686a45d87ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499736f02d96faf9a680686a45d87ff9">&#9670;&nbsp;</a></span>rte_eth_promiscuous_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_promiscuous_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of promiscuous mode for an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(1) if promiscuous is enabled</li>
<li>(0) if promiscuous is disabled.</li>
<li>(-1) on error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5da07e7e7f4fac5dbf46565be69626a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da07e7e7f4fac5dbf46565be69626a4">&#9670;&nbsp;</a></span>rte_eth_allmulticast_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_allmulticast_enable </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable the receipt of any multicast frame by an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if support for allmulticast_enable() does not exist for the device.</li>
<li>(-ENODEV) if <em>port_id</em> invalid. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a86">examples/ipv4_multicast/main.c</a>, and <a class="el" href="examples_2syntony_2main_8c-example.html#a86">examples/syntony/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a2fe97cde3f374385ef0b12f61e7c30da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe97cde3f374385ef0b12f61e7c30da">&#9670;&nbsp;</a></span>rte_eth_allmulticast_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_allmulticast_disable </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable the receipt of all multicast frames by an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if support for allmulticast_disable() does not exist for the device.</li>
<li>(-ENODEV) if <em>port_id</em> invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a59b46977383aa660990df9c76892ec82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b46977383aa660990df9c76892ec82">&#9670;&nbsp;</a></span>rte_eth_allmulticast_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_allmulticast_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of allmulticast mode for an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(1) if allmulticast is enabled</li>
<li>(0) if allmulticast is disabled.</li>
<li>(-1) on error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a56200b0c25f3ecab5abe9bd2b647c215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56200b0c25f3ecab5abe9bd2b647c215">&#9670;&nbsp;</a></span>rte_eth_link_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_link_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__link.html">rte_eth_link</a> *&#160;</td>
          <td class="paramname"><em>link</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the link status (up/down), the duplex mode (half/full), the negotiation (auto/fixed), and if available, the speed (Mbps).</p>
<p>It might need to wait up to 9 seconds. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__ethdev_8h.html#ad1263899f41301923c483c3b4ce0486f">rte_eth_link_get_nowait</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">link</td><td>Link information written back. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if the function is not supported in PMD.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad1263899f41301923c483c3b4ce0486f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1263899f41301923c483c3b4ce0486f">&#9670;&nbsp;</a></span>rte_eth_link_get_nowait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_link_get_nowait </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__link.html">rte_eth_link</a> *&#160;</td>
          <td class="paramname"><em>link</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the link status (up/down), the duplex mode (half/full), the negotiation (auto/fixed), and if available, the speed (Mbps).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">link</td><td>Link information written back. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if the function is not supported in PMD.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a58">examples/ipv4_multicast/main.c</a>, and <a class="el" href="examples_2syntony_2main_8c-example.html#a58">examples/syntony/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="ade8a6c56c3b7c65fa4cabf1d1106fdc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8a6c56c3b7c65fa4cabf1d1106fdc7">&#9670;&nbsp;</a></span>rte_eth_link_speed_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental const char* rte_eth_link_speed_to_str </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>link_speed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>The function converts a link_speed to a string. It handles all special values like unknown or none speed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_speed</td><td>link_speed of <a class="el" href="structrte__eth__link.html">rte_eth_link</a> struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Link speed in textual format. It's pointer to immutable memory. No free is required. </dd></dl>

</div>
</div>
<a id="a5f51139368b8d1a2c22fdecd90bc4d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f51139368b8d1a2c22fdecd90bc4d98">&#9670;&nbsp;</a></span>rte_eth_link_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_link_to_str </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__eth__link.html">rte_eth_link</a> *&#160;</td>
          <td class="paramname"><em>eth_link</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>The function converts a <a class="el" href="structrte__eth__link.html">rte_eth_link</a> struct representing a link status to a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A pointer to a string to be filled with textual representation of device status. At least RTE_ETH_LINK_MAX_STR_LEN bytes should be allocated to store default link status text. </td></tr>
    <tr><td class="paramname">len</td><td>Length of available memory at 'str' string. </td></tr>
    <tr><td class="paramname">eth_link</td><td>Link status returned by rte_eth_link_get function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written to str array or -EINVAL if bad parameter. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a60">examples/ipv4_multicast/main.c</a>, and <a class="el" href="examples_2syntony_2main_8c-example.html#a60">examples/syntony/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="adec226574c53ae413252c9b15f6f4bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec226574c53ae413252c9b15f6f4bab">&#9670;&nbsp;</a></span>rte_eth_stats_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_stats_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__stats.html">rte_eth_stats</a> *&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the general I/O statistics of an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">stats</td><td>A pointer to a structure of type <em><a class="el" href="structrte__eth__stats.html">rte_eth_stats</a></em> to be filled with the values of device counters for the following set of statistics:<ul>
<li><em>ipackets</em> with the total of successfully received packets.</li>
<li><em>opackets</em> with the total of successfully transmitted packets.</li>
<li><em>ibytes</em> with the total of successfully received bytes.</li>
<li><em>obytes</em> with the total of successfully transmitted bytes.</li>
<li><em>ierrors</em> with the total of erroneous received packets.</li>
<li><em>oerrors</em> with the total of failed transmitted packets. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if successful. Non-zero otherwise. </dd></dl>

</div>
</div>
<a id="af3ff61eaf3b5bd61fe10923e406298ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ff61eaf3b5bd61fe10923e406298ed">&#9670;&nbsp;</a></span>rte_eth_stats_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_stats_reset </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the general I/O statistics of an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if device notified to reset stats.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(&lt;0): Error code of the driver stats reset function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a418ad970673eb171673185e36044fd79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418ad970673eb171673185e36044fd79">&#9670;&nbsp;</a></span>rte_eth_xstats_get_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_xstats_get_names </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__xstat__name.html">rte_eth_xstat_name</a> *&#160;</td>
          <td class="paramname"><em>xstats_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve names of extended statistics of an Ethernet device.</p>
<p>There is an assumption that 'xstat_names' and 'xstats' arrays are matched by array index: xstats_names[i].name =&gt; xstats[i].value</p>
<p>And the array index is same with id field of 'struct <a class="el" href="structrte__eth__xstat.html">rte_eth_xstat</a>': xstats[i].id == i</p>
<p>This assumption makes key-value pair matching less flexible but simpler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">xstats_names</td><td>An <a class="el" href="structrte__eth__xstat__name.html">rte_eth_xstat_name</a> array of at least <em>size</em> elements to be filled. If set to NULL, the function returns the required number of elements. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the xstats_names array (number of elements). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>A positive value lower or equal to size: success. The return value is the number of entries filled in the stats table.</li>
<li>A positive value higher than size: error, the given statistics table is too small. The return value corresponds to the size that should be given to succeed. The entries in the table are not valid and shall not be used by the caller.</li>
<li>A negative value on error (invalid port ID). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a300d75b583c1f5acfe5b162a5d8c0ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300d75b583c1f5acfe5b162a5d8c0ac1">&#9670;&nbsp;</a></span>rte_eth_xstats_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_xstats_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__xstat.html">rte_eth_xstat</a> *&#160;</td>
          <td class="paramname"><em>xstats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve extended statistics of an Ethernet device.</p>
<p>There is an assumption that 'xstat_names' and 'xstats' arrays are matched by array index: xstats_names[i].name =&gt; xstats[i].value</p>
<p>And the array index is same with id field of 'struct <a class="el" href="structrte__eth__xstat.html">rte_eth_xstat</a>': xstats[i].id == i</p>
<p>This assumption makes key-value pair matching less flexible but simpler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">xstats</td><td>A pointer to a table of structure of type <em><a class="el" href="structrte__eth__xstat.html">rte_eth_xstat</a></em> to be filled with device statistics ids and values. This parameter can be set to NULL if and only if n is 0. </td></tr>
    <tr><td class="paramname">n</td><td>The size of the xstats array (number of elements). If lower than the required number of elements, the function returns the required number of elements. If equal to zero, the xstats must be NULL, the function returns the required number of elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>A positive value lower or equal to n: success. The return value is the number of entries filled in the stats table.</li>
<li>A positive value higher than n: error, the given statistics table is too small. The return value corresponds to the size that should be given to succeed. The entries in the table are not valid and shall not be used by the caller.</li>
<li>A negative value on error (invalid port ID). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a90a53393e74caa397ca60d87a7bb8cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a53393e74caa397ca60d87a7bb8cce">&#9670;&nbsp;</a></span>rte_eth_xstats_get_names_by_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_xstats_get_names_by_id </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__xstat__name.html">rte_eth_xstat_name</a> *&#160;</td>
          <td class="paramname"><em>xstats_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve names of extended statistics of an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">xstats_names</td><td>Array to be filled in with names of requested device statistics. Must not be NULL if <code>ids</code> are specified (not NULL). </td></tr>
    <tr><td class="paramname">size</td><td>Number of elements in <code>xstats_names</code> array (if not NULL) and in <code>ids</code> array (if not NULL). Must be 0 if both array pointers are NULL. </td></tr>
    <tr><td class="paramname">ids</td><td>IDs array given by app to retrieve specific statistics. May be NULL to retrieve names of all available statistics or, if <code>xstats_names</code> is NULL as well, just the number of available statistics. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>A positive value lower or equal to size: success. The return value is the number of entries filled in the stats table.</li>
<li>A positive value higher than size: success. The given statistics table is too small. The return value corresponds to the size that should be given to succeed. The entries in the table are not valid and shall not be used by the caller.</li>
<li>A negative value on error. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5a69960b27a4c949dc85edbeb6966565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a69960b27a4c949dc85edbeb6966565">&#9670;&nbsp;</a></span>rte_eth_xstats_get_by_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_xstats_get_by_id </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve extended statistics of an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">ids</td><td>IDs array given by app to retrieve specific statistics. May be NULL to retrieve all available statistics or, if <code>values</code> is NULL as well, just the number of available statistics. </td></tr>
    <tr><td class="paramname">values</td><td>Array to be filled in with requested device statistics. Must not be NULL if ids are specified (not NULL). </td></tr>
    <tr><td class="paramname">size</td><td>Number of elements in <code>values</code> array (if not NULL) and in <code>ids</code> array (if not NULL). Must be 0 if both array pointers are NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>A positive value lower or equal to size: success. The return value is the number of entries filled in the stats table.</li>
<li>A positive value higher than size: success: The given statistics table is too small. The return value corresponds to the size that should be given to succeed. The entries in the table are not valid and shall not be used by the caller.</li>
<li>A negative value on error. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9ab128d376f5f713e8fea10090b31e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab128d376f5f713e8fea10090b31e2c">&#9670;&nbsp;</a></span>rte_eth_xstats_get_id_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_xstats_get_id_by_name </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>xstat_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the ID of a statistic from its name.</p>
<p>This function searches for the statistics using string compares, and as such should not be used on the fast-path. For fast-path retrieval of specific statistics, store the ID as provided in <em>id</em> from this function, and pass the ID to <a class="el" href="rte__ethdev_8h.html#a300d75b583c1f5acfe5b162a5d8c0ac1">rte_eth_xstats_get()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">port_id</td><td>The port to look up statistics from </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">xstat_name</td><td>The name of the statistic to return </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>A pointer to an app-supplied uint64_t which should be set to the ID of the stat if the stat exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success -ENODEV for invalid port_id, -EIO if device is removed, -EINVAL if the xstat_name doesn't exist in port_id -ENOMEM if bad parameter. </dd></dl>

</div>
</div>
<a id="add7f377b013951b8446bba9449cae626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7f377b013951b8446bba9449cae626">&#9670;&nbsp;</a></span>rte_eth_xstats_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_xstats_reset </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset extended statistics of an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if device notified to reset extended stats.</li>
<li>(-ENOTSUP) if pmd doesn't support both extended stats and basic stats reset.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(&lt;0): Error code of the driver xstats reset function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a56fae7e398b289f795a1b6256149c4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56fae7e398b289f795a1b6256149c4f3">&#9670;&nbsp;</a></span>rte_eth_dev_set_tx_queue_stats_mapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_tx_queue_stats_mapping </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tx_queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>stat_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a mapping for the specified transmit queue to the specified per-queue statistics counter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">tx_queue_id</td><td>The index of the transmit queue for which a queue stats mapping is required. The value must be in the range [0, nb_tx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">stat_idx</td><td>The per-queue packet statistics functionality number that the transmit queue is to be assigned. The value must be in the range [0, RTE_ETHDEV_QUEUE_STAT_CNTRS - 1]. Max RTE_ETHDEV_QUEUE_STAT_CNTRS being 256. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if successful. Non-zero otherwise. </dd></dl>

</div>
</div>
<a id="af5a2d29926171cb3876546ec9fe6efae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a2d29926171cb3876546ec9fe6efae">&#9670;&nbsp;</a></span>rte_eth_dev_set_rx_queue_stats_mapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_rx_queue_stats_mapping </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rx_queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>stat_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a mapping for the specified receive queue to the specified per-queue statistics counter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">rx_queue_id</td><td>The index of the receive queue for which a queue stats mapping is required. The value must be in the range [0, nb_rx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">stat_idx</td><td>The per-queue packet statistics functionality number that the receive queue is to be assigned. The value must be in the range [0, RTE_ETHDEV_QUEUE_STAT_CNTRS - 1]. Max RTE_ETHDEV_QUEUE_STAT_CNTRS being 256. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if successful. Non-zero otherwise. </dd></dl>

</div>
</div>
<a id="a8a28375b279ded9125c99a46bf3956ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a28375b279ded9125c99a46bf3956ef">&#9670;&nbsp;</a></span>rte_eth_macaddr_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_macaddr_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ether__addr.html">rte_ether_addr</a> *&#160;</td>
          <td class="paramname"><em>mac_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the Ethernet address of an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">mac_addr</td><td>A pointer to a structure of type <em>ether_addr</em> to be filled with the Ethernet address of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a76">examples/ipv4_multicast/main.c</a>, and <a class="el" href="examples_2syntony_2main_8c-example.html#a76">examples/syntony/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="aeb00fa523b8718cdd0a4ac9e41d66ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb00fa523b8718cdd0a4ac9e41d66ffa">&#9670;&nbsp;</a></span>rte_eth_macaddrs_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_macaddrs_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ether__addr.html">rte_ether_addr</a> *&#160;</td>
          <td class="paramname"><em>ma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Retrieve the Ethernet addresses of an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">ma</td><td>A pointer to an array of structures of type <em>ether_addr</em> to be filled with the Ethernet addresses of the Ethernet device. </td></tr>
    <tr><td class="paramname">num</td><td>Number of elements in the <code>ma</code> array. Note that <a class="el" href="structrte__eth__dev__info.html#aeedc5331a92d4a0e1f8d993057274273">rte_eth_dev_info::max_mac_addrs</a> can be used to retrieve max number of Ethernet addresses for given port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>number of retrieved addresses if successful</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7593f4fff04f4ae1b1d718db7ca7dc8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7593f4fff04f4ae1b1d718db7ca7dc8c">&#9670;&nbsp;</a></span>rte_eth_dev_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_info_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__dev__info.html">rte_eth_dev_info</a> *&#160;</td>
          <td class="paramname"><em>dev_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the contextual information of an Ethernet device.</p>
<p>This function returns the Ethernet device information based on the values stored internally in the device specific data. For example: number of queues, descriptor limits, device capabilities and offload flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">dev_info</td><td>A pointer to a structure of type <em><a class="el" href="structrte__eth__dev__info.html">rte_eth_dev_info</a></em> to be filled with the contextual information of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if support for dev_infos_get() does not exist for the device.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a71">examples/ipv4_multicast/main.c</a>, and <a class="el" href="examples_2syntony_2main_8c-example.html#a71">examples/syntony/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="aca4ca98a91959125ad83bdbbae1f3b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4ca98a91959125ad83bdbbae1f3b09">&#9670;&nbsp;</a></span>rte_eth_dev_conf_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_dev_conf_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__conf.html">rte_eth_conf</a> *&#160;</td>
          <td class="paramname"><em>dev_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Retrieve the configuration of an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">dev_conf</td><td>Location for Ethernet device configuration to be filled in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4756122298bd756c4d7171579f77be95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4756122298bd756c4d7171579f77be95">&#9670;&nbsp;</a></span>rte_eth_dev_fw_version_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_fw_version_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>fw_version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fw_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the firmware version of a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the device. </td></tr>
    <tr><td class="paramname">fw_version</td><td>A pointer to a string array storing the firmware version of a device, the string includes terminating null. This pointer is allocated by caller. </td></tr>
    <tr><td class="paramname">fw_size</td><td>The size of the string array pointed by fw_version, which should be large enough to store firmware version of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if operation is not supported.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>(-EINVAL) if bad parameter.</li>
<li>(&gt;0) if <em>fw_size</em> is not enough to store firmware version, return the size of the non truncated string. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa63202d322632467f9cc5fc460e04ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63202d322632467f9cc5fc460e04ea4">&#9670;&nbsp;</a></span>rte_eth_dev_get_supported_ptypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_get_supported_ptypes </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ptype_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ptypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the supported packet types of an Ethernet device.</p>
<p>When a packet type is announced as supported, it <em>must</em> be recognized by the PMD. For instance, if RTE_PTYPE_L2_ETHER, RTE_PTYPE_L2_ETHER_VLAN and RTE_PTYPE_L3_IPV4 are announced, the PMD must return the following packet types for these packets:</p><ul>
<li>Ether/IPv4 -&gt; RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4</li>
<li>Ether/VLAN/IPv4 -&gt; RTE_PTYPE_L2_ETHER_VLAN | RTE_PTYPE_L3_IPV4</li>
<li>Ether/[anything else] -&gt; RTE_PTYPE_L2_ETHER</li>
<li>Ether/VLAN/[anything else] -&gt; RTE_PTYPE_L2_ETHER_VLAN</li>
</ul>
<p>When a packet is received by a PMD, the most precise type must be returned among the ones supported. However a PMD is allowed to set packet type that is not in the supported list, at the condition that it is more precise. Therefore, a PMD announcing no supported packet types can still set a matching packet type in a received packet.</p>
<dl class="section note"><dt>Note</dt><dd>Better to invoke this API after the device is already started or Rx burst function is decided, to obtain correct supported ptypes. </dd>
<dd>
if a given PMD does not report what ptypes it supports, then the supported ptype count is reported as 0. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">ptype_mask</td><td>A hint of what kind of packet type which the caller is interested in. </td></tr>
    <tr><td class="paramname">ptypes</td><td>An array pointer to store adequate packet types, allocated by caller. </td></tr>
    <tr><td class="paramname">num</td><td>Size of the array pointed by param ptypes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(&gt;=0) Number of supported ptypes. If the number of types exceeds num, only num entries will be filled into the ptypes array, but the full count of supported ptypes will be returned.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad7266b14734c87b387c654ff2fdd2b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7266b14734c87b387c654ff2fdd2b33">&#9670;&nbsp;</a></span>rte_eth_dev_set_ptypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_ptypes </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ptype_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>set_ptypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inform Ethernet device about reduced range of packet types to handle.</p>
<p>Application can use this function to set only specific ptypes that it's interested. This information can be used by the PMD to optimize Rx path.</p>
<p>The function accepts an array <code>set_ptypes</code> allocated by the caller to store the packet types set by the driver, the last element of the array is set to RTE_PTYPE_UNKNOWN. The size of the <code>set_ptype</code> array should be <code><a class="el" href="rte__ethdev_8h.html#aa63202d322632467f9cc5fc460e04ea4">rte_eth_dev_get_supported_ptypes()</a> + 1</code> else it might only be filled partially.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">ptype_mask</td><td>The ptype family that application is interested in should be bitwise OR of RTE_PTYPE_*_MASK or 0. </td></tr>
    <tr><td class="paramname">set_ptypes</td><td>An array pointer to store set packet types, allocated by caller. The function marks the end of array with RTE_PTYPE_UNKNOWN. </td></tr>
    <tr><td class="paramname">num</td><td>Size of the array pointed by param ptypes. Should be <a class="el" href="rte__ethdev_8h.html#aa63202d322632467f9cc5fc460e04ea4">rte_eth_dev_get_supported_ptypes()</a> + 1 to accommodate the set ptypes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if Success.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if <em>ptype_mask</em> is invalid (or) set_ptypes is NULL and num &gt; 0. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a386c83c7cc16ec9886ecf2925e7be4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386c83c7cc16ec9886ecf2925e7be4a3">&#9670;&nbsp;</a></span>rte_eth_dev_get_mtu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_get_mtu </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>mtu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the MTU of an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">mtu</td><td>A pointer to a uint16_t where the retrieved MTU is to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8f17597cea4652045427bb9f81e46366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f17597cea4652045427bb9f81e46366">&#9670;&nbsp;</a></span>rte_eth_dev_set_mtu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_mtu </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mtu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the MTU of an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">mtu</td><td>A uint16_t for the MTU to be applied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if operation is not supported.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>(-EINVAL) if <em>mtu</em> invalid, validation of mtu can occur within rte_eth_dev_set_mtu if dev_infos_get is supported by the device or when the mtu is set using dev-&gt;dev_ops-&gt;mtu_set.</li>
<li>(-EBUSY) if operation is not allowed when the port is running </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a642f58ba9a5848a12acb18f2d7f296e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642f58ba9a5848a12acb18f2d7f296e1">&#9670;&nbsp;</a></span>rte_eth_dev_vlan_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_vlan_filter </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>vlan_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable/Disable hardware filtering by an Ethernet device of received VLAN packets tagged with a given VLAN Tag Identifier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">vlan_id</td><td>The VLAN Tag Identifier whose filtering must be enabled or disabled. </td></tr>
    <tr><td class="paramname">on</td><td>If &gt; 0, enable VLAN filtering of VLAN packets tagged with <em>vlan_id</em>. Otherwise, disable VLAN filtering of VLAN packets tagged with <em>vlan_id</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware-assisted VLAN filtering not configured.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>(-ENOSYS) if VLAN filtering on <em>port_id</em> disabled.</li>
<li>(-EINVAL) if <em>vlan_id</em> &gt; 4095. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6bc1b487a103817c6d19bfa8b291b84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc1b487a103817c6d19bfa8b291b84b">&#9670;&nbsp;</a></span>rte_eth_dev_set_vlan_strip_on_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_vlan_strip_on_queue </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rx_queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable/Disable hardware VLAN Strip by a Rx queue of an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">rx_queue_id</td><td>The index of the receive queue for which a queue stats mapping is required. The value must be in the range [0, nb_rx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">on</td><td>If 1, Enable VLAN Stripping of the receive queue of the Ethernet port. If 0, Disable VLAN Stripping of the receive queue of the Ethernet port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware-assisted VLAN stripping not configured.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if <em>rx_queue_id</em> invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6e531f8e53c6bcded644ce496cfbf74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e531f8e53c6bcded644ce496cfbf74a">&#9670;&nbsp;</a></span>rte_eth_dev_set_vlan_ether_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_vlan_ether_type </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__ethdev_8h.html#ae8c05489ea927eb7989108bf94b4f06f">rte_vlan_type</a>&#160;</td>
          <td class="paramname"><em>vlan_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tag_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the Outer VLAN Ether Type by an Ethernet device, it can be inserted to the VLAN header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">vlan_type</td><td>The VLAN type. </td></tr>
    <tr><td class="paramname">tag_type</td><td>The Tag Protocol ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware-assisted VLAN TPID setup is not supported.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a81a17c2c85724d5222ab137188599a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a17c2c85724d5222ab137188599a28">&#9670;&nbsp;</a></span>rte_eth_dev_set_vlan_offload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_vlan_offload </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offload_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set VLAN offload configuration on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">offload_mask</td><td>The VLAN Offload bit mask can be mixed use with "OR" RTE_ETH_VLAN_STRIP_OFFLOAD RTE_ETH_VLAN_FILTER_OFFLOAD RTE_ETH_VLAN_EXTEND_OFFLOAD RTE_ETH_QINQ_STRIP_OFFLOAD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware-assisted VLAN filtering not configured.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab3260e2784aee53f93200c6f221abbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3260e2784aee53f93200c6f221abbba">&#9670;&nbsp;</a></span>rte_eth_dev_get_vlan_offload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_get_vlan_offload </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read VLAN Offload configuration from an Ethernet device</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(&gt;0) if successful. Bit mask to indicate RTE_ETH_VLAN_STRIP_OFFLOAD RTE_ETH_VLAN_FILTER_OFFLOAD RTE_ETH_VLAN_EXTEND_OFFLOAD RTE_ETH_QINQ_STRIP_OFFLOAD</li>
<li>(-ENODEV) if <em>port_id</em> invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a81c89d5cdec796fd46c64f1e80f1b454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c89d5cdec796fd46c64f1e80f1b454">&#9670;&nbsp;</a></span>rte_eth_dev_set_vlan_pvid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_vlan_pvid </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pvid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set port based Tx VLAN insertion on or off.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">pvid</td><td>Port based Tx VLAN identifier together with user priority. </td></tr>
    <tr><td class="paramname">on</td><td>Turn on or off the port based Tx VLAN insertion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>negative if failed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa3ccf6e8777792403520a976d2b5bda8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ccf6e8777792403520a976d2b5bda8">&#9670;&nbsp;</a></span>rte_eth_rx_avail_thresh_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_rx_avail_thresh_set </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>avail_thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Set Rx queue available descriptors threshold.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the receive queue. </td></tr>
    <tr><td class="paramname">avail_thresh</td><td>The available descriptors threshold is percentage of Rx queue size which describes the availability of Rx queue for hardware. If the Rx queue availability is below it, the event RTE_ETH_EVENT_RX_AVAIL_THRESH is triggered. [1-99] to set a new available descriptors threshold. 0 to disable threshold monitoring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if successful.</li>
<li>(-ENODEV) if <code>port_id</code> is invalid.</li>
<li>(-EINVAL) if bad parameter.</li>
<li>(-ENOTSUP) if available Rx descriptors threshold is not supported.</li>
<li>(-EIO) if device is removed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad8b73e6191843b7920030a1bd28d02f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b73e6191843b7920030a1bd28d02f0">&#9670;&nbsp;</a></span>rte_eth_rx_avail_thresh_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_rx_avail_thresh_query </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>avail_thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Find Rx queue with RTE_ETH_EVENT_RX_AVAIL_THRESH event pending.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">queue_id</td><td>On input starting Rx queue index to search from. If the queue_id is bigger than maximum queue ID of the port, search is started from 0. So that application can keep calling this function to handle all pending events with a simple increment of queue_id on the next call. On output if return value is 1, Rx queue index with the event pending. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">avail_thresh</td><td>Location for available descriptors threshold of the found Rx queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>1 if an Rx queue with pending event is found.</li>
<li>0 if no Rx queue with pending event is found.</li>
<li>(-ENODEV) if <code>port_id</code> is invalid.</li>
<li>(-EINVAL) if bad parameter (e.g. <code>queue_id</code> is NULL).</li>
<li>(-ENOTSUP) if operation is not supported.</li>
<li>(-EIO) if device is removed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac5323444ecbe84309a5fcc03aa3c99cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5323444ecbe84309a5fcc03aa3c99cb">&#9670;&nbsp;</a></span>rte_eth_tx_buffer_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_tx_buffer_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__dev__tx__buffer.html">rte_eth_dev_tx_buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize default values for buffered transmitting</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Tx buffer to be initialized. </td></tr>
    <tr><td class="paramname">size</td><td>Buffer size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if no error </dd></dl>

</div>
</div>
<a id="aacd4952d9f45acd463e203c21db9a7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd4952d9f45acd463e203c21db9a7bb">&#9670;&nbsp;</a></span>rte_eth_tx_buffer_set_err_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_tx_buffer_set_err_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__dev__tx__buffer.html">rte_eth_dev_tx_buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">buffer_tx_error_fn&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure a callback for buffered packets which cannot be sent</p>
<p>Register a specific callback to be called when an attempt is made to send all packets buffered on an Ethernet port, but not all packets can successfully be sent. The callback registered here will be called only from calls to <a class="el" href="rte__ethdev_8h.html#a0e941a74ae1b1b886764bc282458d946">rte_eth_tx_buffer()</a> and <a class="el" href="rte__ethdev_8h.html#ace8779bcecccb86c94ce3638f35c9254">rte_eth_tx_buffer_flush()</a> APIs. The default callback configured for each queue by default just frees the packets back to the calling mempool. If additional behaviour is required, for example, to count dropped packets, or to retry transmission of packets which cannot be sent, this function should be used to register a suitable callback function to implement the desired behaviour. The example callback "rte_eth_tx_buffer_count_callback()" is also provided as reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">callback</td><td>The function to be used as the callback. </td></tr>
    <tr><td class="paramname">userdata</td><td>Arbitrary parameter to be passed to the callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or -EINVAL if bad parameter </dd></dl>

</div>
</div>
<a id="acbca22df1ad695663d271f9671811b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbca22df1ad695663d271f9671811b3d">&#9670;&nbsp;</a></span>rte_eth_tx_buffer_drop_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_eth_tx_buffer_drop_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **&#160;</td>
          <td class="paramname"><em>pkts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>unsent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function for silently dropping unsent buffered packets.</p>
<p>This function can be passed to <a class="el" href="rte__ethdev_8h.html#aacd4952d9f45acd463e203c21db9a7bb">rte_eth_tx_buffer_set_err_callback()</a> to adjust the default behavior when buffered packets cannot be sent. This function drops any unsent packets silently and is used by Tx buffered operations as default behavior.</p>
<p>NOTE: this function should not be called directly, instead it should be used as a callback for packet buffering.</p>
<p>NOTE: when configuring this function as a callback with <a class="el" href="rte__ethdev_8h.html#aacd4952d9f45acd463e203c21db9a7bb">rte_eth_tx_buffer_set_err_callback()</a>, the final, userdata parameter should point to an uint64_t value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkts</td><td>The previously buffered packets which could not be sent </td></tr>
    <tr><td class="paramname">unsent</td><td>The number of unsent packets in the pkts array </td></tr>
    <tr><td class="paramname">userdata</td><td>Not used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2e9cb28245ce5e06f6b2caf0506cf60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e9cb28245ce5e06f6b2caf0506cf60">&#9670;&nbsp;</a></span>rte_eth_tx_buffer_count_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_eth_tx_buffer_count_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **&#160;</td>
          <td class="paramname"><em>pkts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>unsent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function for tracking unsent buffered packets.</p>
<p>This function can be passed to <a class="el" href="rte__ethdev_8h.html#aacd4952d9f45acd463e203c21db9a7bb">rte_eth_tx_buffer_set_err_callback()</a> to adjust the default behavior when buffered packets cannot be sent. This function drops any unsent packets, but also updates a user-supplied counter to track the overall number of packets dropped. The counter should be an uint64_t variable.</p>
<p>NOTE: this function should not be called directly, instead it should be used as a callback for packet buffering.</p>
<p>NOTE: when configuring this function as a callback with <a class="el" href="rte__ethdev_8h.html#aacd4952d9f45acd463e203c21db9a7bb">rte_eth_tx_buffer_set_err_callback()</a>, the final, userdata parameter should point to an uint64_t value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkts</td><td>The previously buffered packets which could not be sent </td></tr>
    <tr><td class="paramname">unsent</td><td>The number of unsent packets in the pkts array </td></tr>
    <tr><td class="paramname">userdata</td><td>Pointer to an uint64_t value, which will be incremented by unsent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08d26dc7414a83a01c2a581f12a6c381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d26dc7414a83a01c2a581f12a6c381">&#9670;&nbsp;</a></span>rte_eth_tx_done_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_tx_done_cleanup </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>free_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request the driver to free mbufs currently cached by the driver. The driver will only free the mbuf if it is no longer in use. It is the application's responsibility to ensure rte_eth_tx_buffer_flush(..) is called if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the transmit queue through which output packets must be sent. The value must be in the range [0, nb_tx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">free_cnt</td><td>Maximum number of packets to free. Use 0 to indicate all possible packets should be freed. Note that a packet may be using multiple mbufs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Failure: &lt; 0 -ENODEV: Invalid interface -EIO: device is removed -ENOTSUP: Driver does not support function Success: &gt;= 0 0-n: Number of packets freed. More packets may still remain in ring that are in use. </dd></dl>

</div>
</div>
<a id="ac0bef2920a6ade4041cab5103f4700d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0bef2920a6ade4041cab5103f4700d9">&#9670;&nbsp;</a></span>rte_eth_dev_callback_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_callback_register </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779d">rte_eth_event_type</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__ethdev_8h.html#a868605d09373258672f598e8bf4dab82">rte_eth_dev_cb_fn</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a callback function for port event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>Port ID. RTE_ETH_ALL means register the event for all port ids. </td></tr>
    <tr><td class="paramname">event</td><td>Event interested. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>User supplied callback function to be called. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Pointer to the parameters for the registered callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, zero.</li>
<li>On failure, a negative value. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9ac24c5a883555ffe08143ff8e277161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac24c5a883555ffe08143ff8e277161">&#9670;&nbsp;</a></span>rte_eth_dev_callback_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_callback_unregister </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779d">rte_eth_event_type</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__ethdev_8h.html#a868605d09373258672f598e8bf4dab82">rte_eth_dev_cb_fn</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for port event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>Port ID. RTE_ETH_ALL means unregister the event for all port ids. </td></tr>
    <tr><td class="paramname">event</td><td>Event interested. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>User supplied callback function to be called. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Pointer to the parameters for the registered callback. -1 means to remove all for the same callback address and same event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, zero.</li>
<li>On failure, a negative value. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a88371c8cf4b2ec9e3e2e7c9adae2fe9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88371c8cf4b2ec9e3e2e7c9adae2fe9a">&#9670;&nbsp;</a></span>rte_eth_dev_rx_intr_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_rx_intr_enable </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When there is no Rx packet coming in Rx Queue for a long time, we can sleep lcore related to Rx Queue for power saving, and enable Rx interrupt to be triggered when Rx packet arrives.</p>
<p>The <a class="el" href="rte__ethdev_8h.html#a88371c8cf4b2ec9e3e2e7c9adae2fe9a">rte_eth_dev_rx_intr_enable()</a> function enables Rx queue interrupt on specific Rx queue of a port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the receive queue from which to retrieve input packets. The value must be in the range [0, nb_rx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if underlying hardware OR driver doesn't support that operation.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7c30fbc44657558d5ebef03f6b6a8bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c30fbc44657558d5ebef03f6b6a8bbc">&#9670;&nbsp;</a></span>rte_eth_dev_rx_intr_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_rx_intr_disable </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When lcore wakes up from Rx interrupt indicating packet coming, disable Rx interrupt and returns to polling mode.</p>
<p>The <a class="el" href="rte__ethdev_8h.html#a7c30fbc44657558d5ebef03f6b6a8bbc">rte_eth_dev_rx_intr_disable()</a> function disables Rx queue interrupt on specific Rx queue of a port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the receive queue from which to retrieve input packets. The value must be in the range [0, nb_rx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if underlying hardware OR driver doesn't support that operation.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="abd10b586923569451fd7370280e2a36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd10b586923569451fd7370280e2a36d">&#9670;&nbsp;</a></span>rte_eth_dev_rx_intr_ctl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_rx_intr_ctl </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>epfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rx Interrupt control per port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">epfd</td><td>Epoll instance fd which the intr vector associated to. Using RTE_EPOLL_PER_THREAD allows to use per thread epoll instance. </td></tr>
    <tr><td class="paramname">op</td><td>The operation be performed for the vector. Operation type of {RTE_INTR_EVENT_ADD, RTE_INTR_EVENT_DEL}. </td></tr>
    <tr><td class="paramname">data</td><td>User raw data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, zero.</li>
<li>On failure, a negative value. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1b48c883e8e25f35a653aa88fbf5ae62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b48c883e8e25f35a653aa88fbf5ae62">&#9670;&nbsp;</a></span>rte_eth_dev_rx_intr_ctl_q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_rx_intr_ctl_q </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>epfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rx Interrupt control per queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the receive queue from which to retrieve input packets. The value must be in the range [0, nb_rx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">epfd</td><td>Epoll instance fd which the intr vector associated to. Using RTE_EPOLL_PER_THREAD allows to use per thread epoll instance. </td></tr>
    <tr><td class="paramname">op</td><td>The operation be performed for the vector. Operation type of {RTE_INTR_EVENT_ADD, RTE_INTR_EVENT_DEL}. </td></tr>
    <tr><td class="paramname">data</td><td>User raw data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, zero.</li>
<li>On failure, a negative value. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a842134147a67ac903f9cfe0aeabf1064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842134147a67ac903f9cfe0aeabf1064">&#9670;&nbsp;</a></span>rte_eth_dev_rx_intr_ctl_q_get_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_rx_intr_ctl_q_get_fd </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get interrupt fd per Rx queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the receive queue from which to retrieve input packets. The value must be in the range [0, nb_rx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(&gt;=0) the interrupt fd associated to the requested Rx queue if successful.</li>
<li>(-1) on error. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9fbd0361b479f33762b4b24354f373f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fbd0361b479f33762b4b24354f373f1">&#9670;&nbsp;</a></span>rte_eth_led_on()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_led_on </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turn on the LED on the Ethernet device. This function turns on the LED on the Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if underlying hardware OR driver doesn't support that operation.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4c0cb9d142d16d8b8cfe39aa4fb8a3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0cb9d142d16d8b8cfe39aa4fb8a3c0">&#9670;&nbsp;</a></span>rte_eth_led_off()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_led_off </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turn off the LED on the Ethernet device. This function turns off the LED on the Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if underlying hardware OR driver doesn't support that operation.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afef356da666852b06301ab92f29098b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef356da666852b06301ab92f29098b5">&#9670;&nbsp;</a></span>rte_eth_fec_get_capability()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_fec_get_capability </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct rte_eth_fec_capa *&#160;</td>
          <td class="paramname"><em>speed_fec_capa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice</dd></dl>
<p>Get Forward Error Correction(FEC) capability.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">speed_fec_capa</td><td>speed_fec_capa is out only with per-speed capabilities. If set to NULL, the function returns the required number of required array entries. </td></tr>
    <tr><td class="paramname">num</td><td>a number of elements in an speed_fec_capa array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>A non-negative value lower or equal to num: success. The return value is the number of entries filled in the fec capa array.</li>
<li>A non-negative value higher than num: error, the given fec capa array is too small. The return value corresponds to the num that should be given to succeed. The entries in fec capa array are not valid and shall not be used by the caller.</li>
<li>(-ENOTSUP) if underlying hardware OR driver doesn't support. that operation.</li>
<li>(-EIO) if device is removed.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if <em>num</em> or <em>speed_fec_capa</em> invalid </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9b1cfa84ae39dd8f878affd97339291c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1cfa84ae39dd8f878affd97339291c">&#9670;&nbsp;</a></span>rte_eth_fec_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_fec_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>fec_capa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice</dd></dl>
<p>Get current Forward Error Correction(FEC) mode. If link is down and AUTO is enabled, AUTO is returned, otherwise, configured FEC mode is returned. If link is up, current FEC mode is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">fec_capa</td><td>A bitmask with the current FEC mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if underlying hardware OR driver doesn't support. that operation.</li>
<li>(-EIO) if device is removed.</li>
<li>(-ENODEV) if <em>port_id</em> invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a527bc13f6c7fada902cb598c050782ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527bc13f6c7fada902cb598c050782ee">&#9670;&nbsp;</a></span>rte_eth_fec_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_fec_set </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fec_capa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice</dd></dl>
<p>Set Forward Error Correction(FEC) mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">fec_capa</td><td>A bitmask of allowed FEC modes. If only the AUTO bit is set, the decision on which FEC mode to use will be made by HW/FW or driver. If the AUTO bit is set with some FEC modes, only specified FEC modes can be set. If AUTO bit is clear, specify FEC mode to be used (only one valid mode per speed may be set). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-EINVAL) if the FEC mode is not valid.</li>
<li>(-ENOTSUP) if underlying hardware OR driver doesn't support.</li>
<li>(-EIO) if device is removed.</li>
<li>(-ENODEV) if <em>port_id</em> invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a511f239b9199de49474a5705ca0bdf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511f239b9199de49474a5705ca0bdf27">&#9670;&nbsp;</a></span>rte_eth_dev_flow_ctrl_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_flow_ctrl_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__fc__conf.html">rte_eth_fc_conf</a> *&#160;</td>
          <td class="paramname"><em>fc_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get current status of the Ethernet link flow control for Ethernet device</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">fc_conf</td><td>The pointer to the structure where to store the flow control parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support flow control.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a3abc01863cf282ac707faf4a2782392a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3abc01863cf282ac707faf4a2782392a">&#9670;&nbsp;</a></span>rte_eth_dev_flow_ctrl_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_flow_ctrl_set </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__fc__conf.html">rte_eth_fc_conf</a> *&#160;</td>
          <td class="paramname"><em>fc_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure the Ethernet link flow control for Ethernet device</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">fc_conf</td><td>The pointer to the structure of the flow control parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support flow control mode.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter</li>
<li>(-EIO) if flow control setup failure or device is removed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a63e47e0d2a4837966f8d407bad03d29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e47e0d2a4837966f8d407bad03d29e">&#9670;&nbsp;</a></span>rte_eth_dev_priority_flow_ctrl_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_priority_flow_ctrl_set </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__pfc__conf.html">rte_eth_pfc_conf</a> *&#160;</td>
          <td class="paramname"><em>pfc_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure the Ethernet priority flow control under DCB environment for Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">pfc_conf</td><td>The pointer to the structure of the priority flow control parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support priority flow control mode.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter</li>
<li>(-EIO) if flow control setup failure or device is removed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aae1a98a4ba67296647a29abb8cce1031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae1a98a4ba67296647a29abb8cce1031">&#9670;&nbsp;</a></span>rte_eth_dev_mac_addr_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_mac_addr_add </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ether__addr.html">rte_ether_addr</a> *&#160;</td>
          <td class="paramname"><em>mac_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a MAC address to the set used for filtering incoming packets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">mac_addr</td><td>The MAC address to add. </td></tr>
    <tr><td class="paramname">pool</td><td>VMDq pool index to associate address with (if VMDq is enabled). If VMDq is not enabled, this should be set to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successfully added or <em>mac_addr</em> was already added.</li>
<li>(-ENOTSUP) if hardware doesn't support this feature.</li>
<li>(-ENODEV) if <em>port</em> is invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>(-ENOSPC) if no more MAC addresses can be added.</li>
<li>(-EINVAL) if MAC address is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a91d7805f7a401618814461ff3cfb4e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d7805f7a401618814461ff3cfb4e94">&#9670;&nbsp;</a></span>rte_eth_dev_priority_flow_ctrl_queue_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_dev_priority_flow_ctrl_queue_info_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__pfc__queue__info.html">rte_eth_pfc_queue_info</a> *&#160;</td>
          <td class="paramname"><em>pfc_queue_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Retrieve the information for queue based PFC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">pfc_queue_info</td><td>A pointer to a structure of type <em><a class="el" href="structrte__eth__pfc__queue__info.html">rte_eth_pfc_queue_info</a></em> to be filled with the information about queue based PFC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if support for priority_flow_ctrl_queue_info_get does not exist.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab2657f029c1e6a37b8ceccbf2f6dea26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2657f029c1e6a37b8ceccbf2f6dea26">&#9670;&nbsp;</a></span>rte_eth_dev_priority_flow_ctrl_queue_configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_dev_priority_flow_ctrl_queue_configure </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__pfc__queue__conf.html">rte_eth_pfc_queue_conf</a> *&#160;</td>
          <td class="paramname"><em>pfc_queue_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Configure the queue based priority flow control for a given queue for Ethernet device.</p>
<dl class="section note"><dt>Note</dt><dd>When an ethdev port switches to queue based PFC mode, the unconfigured queues shall be configured by the driver with default values such as lower priority value for TC etc.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">pfc_queue_conf</td><td>The pointer to the structure of the priority flow control parameters for the queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support queue based PFC mode.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter</li>
<li>(-EIO) if flow control setup queue failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad8c7016e17fb74bbea305604b31356cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c7016e17fb74bbea305604b31356cc">&#9670;&nbsp;</a></span>rte_eth_dev_mac_addr_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_mac_addr_remove </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ether__addr.html">rte_ether_addr</a> *&#160;</td>
          <td class="paramname"><em>mac_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a MAC address from the internal array of addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">mac_addr</td><td>MAC address to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful, or <em>mac_addr</em> didn't exist.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-ENODEV) if <em>port</em> invalid.</li>
<li>(-EADDRINUSE) if attempting to remove the default MAC address.</li>
<li>(-EINVAL) if MAC address is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8d1b91521b0308b3b462095e25ba521a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1b91521b0308b3b462095e25ba521a">&#9670;&nbsp;</a></span>rte_eth_dev_default_mac_addr_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_default_mac_addr_set </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ether__addr.html">rte_ether_addr</a> *&#160;</td>
          <td class="paramname"><em>mac_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the default MAC address. It replaces the address at index 0 of the MAC address list. If the address was already in the MAC address list, please remove it first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">mac_addr</td><td>New default MAC address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful, or <em>mac_addr</em> didn't exist.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-ENODEV) if <em>port</em> invalid.</li>
<li>(-EINVAL) if MAC address is invalid.</li>
<li>(-EEXIST) if MAC address was already in the address list. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a3c1540852c9cf1e576a883902c2e310d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1540852c9cf1e576a883902c2e310d">&#9670;&nbsp;</a></span>rte_eth_dev_rss_reta_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_rss_reta_update </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__rss__reta__entry64.html">rte_eth_rss_reta_entry64</a> *&#160;</td>
          <td class="paramname"><em>reta_conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>reta_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update Redirection Table(RETA) of Receive Side Scaling of Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">reta_conf</td><td>RETA to update. </td></tr>
    <tr><td class="paramname">reta_size</td><td>Redirection table size. The table size can be queried by <a class="el" href="rte__ethdev_8h.html#a7593f4fff04f4ae1b1d718db7ca7dc8c">rte_eth_dev_info_get()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENODEV) if <em>port_id</em> is invalid.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter.</li>
<li>(-EIO) if device is removed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa0a22596cff13d0c2c777383a9043feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a22596cff13d0c2c777383a9043feb">&#9670;&nbsp;</a></span>rte_eth_dev_rss_reta_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_rss_reta_query </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__rss__reta__entry64.html">rte_eth_rss_reta_entry64</a> *&#160;</td>
          <td class="paramname"><em>reta_conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>reta_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query Redirection Table(RETA) of Receive Side Scaling of Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">reta_conf</td><td>RETA to query. For each requested reta entry, corresponding bit in mask must be set. </td></tr>
    <tr><td class="paramname">reta_size</td><td>Redirection table size. The table size can be queried by <a class="el" href="rte__ethdev_8h.html#a7593f4fff04f4ae1b1d718db7ca7dc8c">rte_eth_dev_info_get()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENODEV) if <em>port_id</em> is invalid.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter.</li>
<li>(-EIO) if device is removed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aaec6ab973ff515cc8b07aaad2b3dddb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec6ab973ff515cc8b07aaad2b3dddb8">&#9670;&nbsp;</a></span>rte_eth_dev_uc_hash_table_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_uc_hash_table_set </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ether__addr.html">rte_ether_addr</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates unicast hash table for receiving packet with the given destination MAC address, and the packet is routed to all VFs for which the Rx mode is accept packets that match the unicast hash table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">addr</td><td>Unicast MAC address. </td></tr>
    <tr><td class="paramname">on</td><td>1 - Set an unicast hash bit for receiving packets with the MAC address. 0 - Clear an unicast hash bit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a41f0255ba0a08a74dcb0c1a5133ecaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f0255ba0a08a74dcb0c1a5133ecaf3">&#9670;&nbsp;</a></span>rte_eth_dev_uc_all_hash_table_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_uc_all_hash_table_set </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates all unicast hash bitmaps for receiving packet with any Unicast Ethernet MAC addresses,the packet is routed to all VFs for which the Rx mode is accept packets that match the unicast hash table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">on</td><td>1 - Set all unicast hash bitmaps for receiving all the Ethernet MAC addresses 0 - Clear all unicast hash bitmaps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae0a43c745bd11679ad3cf736317a84aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a43c745bd11679ad3cf736317a84aa">&#9670;&nbsp;</a></span>rte_eth_set_queue_rate_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_set_queue_rate_limit </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tx_rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the rate limitation for a queue on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_idx</td><td>The queue ID. </td></tr>
    <tr><td class="paramname">tx_rate</td><td>The Tx rate in Mbps. Allocated from the total port link speed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support this feature.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad6461a60f6592292d398bbd87dbdebc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6461a60f6592292d398bbd87dbdebc4">&#9670;&nbsp;</a></span>rte_eth_dev_rss_hash_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_rss_hash_update </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__rss__conf.html">rte_eth_rss_conf</a> *&#160;</td>
          <td class="paramname"><em>rss_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configuration of Receive Side Scaling hash computation of Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">rss_conf</td><td>The new configuration to use for RSS hash computation on the port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENODEV) if port identifier is invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6000dca62f9815414b3f3b9c5d8be62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6000dca62f9815414b3f3b9c5d8be62f">&#9670;&nbsp;</a></span>rte_eth_dev_rss_hash_conf_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_rss_hash_conf_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__rss__conf.html">rte_eth_rss_conf</a> *&#160;</td>
          <td class="paramname"><em>rss_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve current configuration of Receive Side Scaling hash computation of Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">rss_conf</td><td>Where to store the current RSS hash configuration of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENODEV) if port identifier is invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>(-ENOTSUP) if hardware doesn't support RSS.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="acd9b5de44a82809e291f6a2b4753ad7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9b5de44a82809e291f6a2b4753ad7e">&#9670;&nbsp;</a></span>rte_eth_dev_rss_algo_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental const char* rte_eth_dev_rss_algo_name </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="rte__ethdev_8h.html#aecb895db261266fa2a85cf518d007ed9">rte_eth_hash_function</a>&#160;</td>
          <td class="paramname"><em>rss_algo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice.</dd></dl>
<p>Get the name of RSS hash algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rss_algo</td><td>Hash algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hash algorithm name or 'UNKNOWN' if the rss_algo cannot be recognized. </dd></dl>

</div>
</div>
<a id="a6455af7a0ed7d417d443984181045464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6455af7a0ed7d417d443984181045464">&#9670;&nbsp;</a></span>rte_eth_dev_udp_tunnel_port_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_udp_tunnel_port_add </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__udp__tunnel.html">rte_eth_udp_tunnel</a> *&#160;</td>
          <td class="paramname"><em>tunnel_udp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add UDP tunneling port for a type of tunnel.</p>
<p>Some NICs may require such configuration to properly parse a tunnel with any standard or custom UDP port. The packets with this UDP port will be parsed for this type of tunnel. The device parser will also check the rest of the tunnel headers before classifying the packet.</p>
<p>With some devices, this API will affect packet classification, i.e.:</p><ul>
<li>mbuf.packet_type reported on Rx</li>
<li>rte_flow rules with tunnel items</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">tunnel_udp</td><td>UDP tunneling configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENODEV) if port identifier is invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>(-ENOTSUP) if hardware doesn't support tunnel type. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac49d9cf227f6190c502dfc53e6953d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49d9cf227f6190c502dfc53e6953d2d">&#9670;&nbsp;</a></span>rte_eth_dev_udp_tunnel_port_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_udp_tunnel_port_delete </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__udp__tunnel.html">rte_eth_udp_tunnel</a> *&#160;</td>
          <td class="paramname"><em>tunnel_udp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete UDP tunneling port for a type of tunnel.</p>
<p>The packets with this UDP port will not be classified as this type of tunnel anymore if the device use such mapping for tunnel packet classification.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__ethdev_8h.html#a6455af7a0ed7d417d443984181045464">rte_eth_dev_udp_tunnel_port_add</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">tunnel_udp</td><td>UDP tunneling configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENODEV) if port identifier is invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>(-ENOTSUP) if hardware doesn't support tunnel type. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad5d0e47c19784b52b5f711dcc5088ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d0e47c19784b52b5f711dcc5088ce6">&#9670;&nbsp;</a></span>rte_eth_dev_get_dcb_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_get_dcb_info </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__dcb__info.html">rte_eth_dcb_info</a> *&#160;</td>
          <td class="paramname"><em>dcb_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get DCB information on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">dcb_info</td><td>DCB information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENODEV) if port identifier is invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="adb70723c985c3ea177591b67cfc49178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb70723c985c3ea177591b67cfc49178">&#9670;&nbsp;</a></span>rte_eth_add_rx_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct rte_eth_rxtx_callback* rte_eth_add_rx_callback </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__ethdev_8h.html#a7400438ebc28f2343aa0453ad5a4a021">rte_rx_callback_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a callback to be called on packet Rx on a given port and queue.</p>
<p>This API configures a function to be called for each burst of packets received on a given NIC port queue. The return value is a pointer that can be used to later remove the callback using <a class="el" href="rte__ethdev_8h.html#a7b55620c8cafdbf383f24539ca8f01bb">rte_eth_remove_rx_callback()</a>.</p>
<p>Multiple functions are called in the order that they are added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The queue on the Ethernet device on which the callback is to be added. </td></tr>
    <tr><td class="paramname">fn</td><td>The callback function </td></tr>
    <tr><td class="paramname">user_param</td><td>A generic pointer parameter which will be passed to each invocation of the callback function on this port and queue. Inter-thread synchronization of any user data changes is the responsibility of the user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error. On success, a pointer value which can later be used to remove the callback. </dd></dl>

</div>
</div>
<a id="a4797e1f9ba75064bf0fbc4db8826d2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4797e1f9ba75064bf0fbc4db8826d2f3">&#9670;&nbsp;</a></span>rte_eth_add_first_rx_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct rte_eth_rxtx_callback* rte_eth_add_first_rx_callback </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__ethdev_8h.html#a7400438ebc28f2343aa0453ad5a4a021">rte_rx_callback_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a callback that must be called first on packet Rx on a given port and queue.</p>
<p>This API configures a first function to be called for each burst of packets received on a given NIC port queue. The return value is a pointer that can be used to later remove the callback using <a class="el" href="rte__ethdev_8h.html#a7b55620c8cafdbf383f24539ca8f01bb">rte_eth_remove_rx_callback()</a>.</p>
<p>Multiple functions are called in the order that they are added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The queue on the Ethernet device on which the callback is to be added. </td></tr>
    <tr><td class="paramname">fn</td><td>The callback function </td></tr>
    <tr><td class="paramname">user_param</td><td>A generic pointer parameter which will be passed to each invocation of the callback function on this port and queue. Inter-thread synchronization of any user data changes is the responsibility of the user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error. On success, a pointer value which can later be used to remove the callback. </dd></dl>

</div>
</div>
<a id="a1880bf92c5e7d1d6901807a431024490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1880bf92c5e7d1d6901807a431024490">&#9670;&nbsp;</a></span>rte_eth_add_tx_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct rte_eth_rxtx_callback* rte_eth_add_tx_callback </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__ethdev_8h.html#aeb995c6332dcda43bc0c551ea266d7fd">rte_tx_callback_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a callback to be called on packet Tx on a given port and queue.</p>
<p>This API configures a function to be called for each burst of packets sent on a given NIC port queue. The return value is a pointer that can be used to later remove the callback using <a class="el" href="rte__ethdev_8h.html#a60938179a2892235fd72f2827eacb2df">rte_eth_remove_tx_callback()</a>.</p>
<p>Multiple functions are called in the order that they are added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The queue on the Ethernet device on which the callback is to be added. </td></tr>
    <tr><td class="paramname">fn</td><td>The callback function </td></tr>
    <tr><td class="paramname">user_param</td><td>A generic pointer parameter which will be passed to each invocation of the callback function on this port and queue. Inter-thread synchronization of any user data changes is the responsibility of the user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error. On success, a pointer value which can later be used to remove the callback. </dd></dl>

</div>
</div>
<a id="a7b55620c8cafdbf383f24539ca8f01bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b55620c8cafdbf383f24539ca8f01bb">&#9670;&nbsp;</a></span>rte_eth_remove_rx_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_remove_rx_callback </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct rte_eth_rxtx_callback *&#160;</td>
          <td class="paramname"><em>user_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an Rx packet callback from a given port and queue.</p>
<p>This function is used to removed callbacks that were added to a NIC port queue using <a class="el" href="rte__ethdev_8h.html#adb70723c985c3ea177591b67cfc49178">rte_eth_add_rx_callback()</a>.</p>
<p>Note: the callback is removed from the callback list but it isn't freed since the it may still be in use. The memory for the callback can be subsequently freed back by the application by calling <a class="el" href="rte__malloc_8h.html#a1fc82f67711b13aca7e05dc9d58f9dbd">rte_free()</a>:</p>
<ul>
<li>Immediately - if the port is stopped, or the user knows that no callbacks are in flight e.g. if called from the thread doing Rx/Tx on that queue.</li>
<li>After a short delay - where the delay is sufficient to allow any in-flight callbacks to complete. Alternately, the RCU mechanism can be used to detect when data plane threads have ceased referencing the callback memory.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The queue on the Ethernet device from which the callback is to be removed. </td></tr>
    <tr><td class="paramname">user_cb</td><td>User supplied callback created via <a class="el" href="rte__ethdev_8h.html#adb70723c985c3ea177591b67cfc49178">rte_eth_add_rx_callback()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success. Callback was removed.</li>
<li>-ENODEV: If <em>port_id</em> is invalid.</li>
<li>-ENOTSUP: Callback support is not available.</li>
<li>-EINVAL: The queue_id is out of range, or the callback is NULL or not found for the port/queue. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a60938179a2892235fd72f2827eacb2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60938179a2892235fd72f2827eacb2df">&#9670;&nbsp;</a></span>rte_eth_remove_tx_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_remove_tx_callback </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct rte_eth_rxtx_callback *&#160;</td>
          <td class="paramname"><em>user_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a Tx packet callback from a given port and queue.</p>
<p>This function is used to removed callbacks that were added to a NIC port queue using <a class="el" href="rte__ethdev_8h.html#a1880bf92c5e7d1d6901807a431024490">rte_eth_add_tx_callback()</a>.</p>
<p>Note: the callback is removed from the callback list but it isn't freed since the it may still be in use. The memory for the callback can be subsequently freed back by the application by calling <a class="el" href="rte__malloc_8h.html#a1fc82f67711b13aca7e05dc9d58f9dbd">rte_free()</a>:</p>
<ul>
<li>Immediately - if the port is stopped, or the user knows that no callbacks are in flight e.g. if called from the thread doing Rx/Tx on that queue.</li>
<li>After a short delay - where the delay is sufficient to allow any in-flight callbacks to complete. Alternately, the RCU mechanism can be used to detect when data plane threads have ceased referencing the callback memory.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The queue on the Ethernet device from which the callback is to be removed. </td></tr>
    <tr><td class="paramname">user_cb</td><td>User supplied callback created via <a class="el" href="rte__ethdev_8h.html#a1880bf92c5e7d1d6901807a431024490">rte_eth_add_tx_callback()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success. Callback was removed.</li>
<li>-ENODEV: If <em>port_id</em> is invalid.</li>
<li>-ENOTSUP: Callback support is not available.</li>
<li>-EINVAL: The queue_id is out of range, or the callback is NULL or not found for the port/queue. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab6daa1713d569210c5ac4c8746b83169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6daa1713d569210c5ac4c8746b83169">&#9670;&nbsp;</a></span>rte_eth_rx_queue_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_rx_queue_info_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__rxq__info.html">rte_eth_rxq_info</a> *&#160;</td>
          <td class="paramname"><em>qinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve information about given port's Rx queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The Rx queue on the Ethernet device for which information will be retrieved. </td></tr>
    <tr><td class="paramname">qinfo</td><td>A pointer to a structure of type <em>rte_eth_rxq_info_info</em> to be filled with the information of the Ethernet device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success</li>
<li>-ENODEV: If <em>port_id</em> is invalid.</li>
<li>-ENOTSUP: routine is not supported by the device PMD.</li>
<li>-EINVAL: The queue_id is out of range, or the queue is hairpin queue. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac3c6f6f02c73e5c67967c1106758ca9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c6f6f02c73e5c67967c1106758ca9b">&#9670;&nbsp;</a></span>rte_eth_tx_queue_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_tx_queue_info_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__txq__info.html">rte_eth_txq_info</a> *&#160;</td>
          <td class="paramname"><em>qinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve information about given port's Tx queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The Tx queue on the Ethernet device for which information will be retrieved. </td></tr>
    <tr><td class="paramname">qinfo</td><td>A pointer to a structure of type <em>rte_eth_txq_info_info</em> to be filled with the information of the Ethernet device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success</li>
<li>-ENODEV: If <em>port_id</em> is invalid.</li>
<li>-ENOTSUP: routine is not supported by the device PMD.</li>
<li>-EINVAL: The queue_id is out of range, or the queue is hairpin queue. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2b1e1119f0a009aa9cd952984c91c389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1e1119f0a009aa9cd952984c91c389">&#9670;&nbsp;</a></span>rte_eth_recycle_rx_queue_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_recycle_rx_queue_info_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__recycle__rxq__info.html">rte_eth_recycle_rxq_info</a> *&#160;</td>
          <td class="paramname"><em>recycle_rxq_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice</dd></dl>
<p>Retrieve information about given ports's Rx queue for recycling mbufs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The Rx queue on the Ethernet devicefor which information will be retrieved. </td></tr>
    <tr><td class="paramname">recycle_rxq_info</td><td>A pointer to a structure of type <em><a class="el" href="structrte__eth__recycle__rxq__info.html">rte_eth_recycle_rxq_info</a></em> to be filled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success</li>
<li>-ENODEV: If <em>port_id</em> is invalid.</li>
<li>-ENOTSUP: routine is not supported by the device PMD.</li>
<li>-EINVAL: The queue_id is out of range. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1ef67562b2fe058913e5b4e3d2611758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef67562b2fe058913e5b4e3d2611758">&#9670;&nbsp;</a></span>rte_eth_rx_burst_mode_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_rx_burst_mode_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__burst__mode.html">rte_eth_burst_mode</a> *&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve information about the Rx packet burst mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The Rx queue on the Ethernet device for which information will be retrieved. </td></tr>
    <tr><td class="paramname">mode</td><td>A pointer to a structure of type <em><a class="el" href="structrte__eth__burst__mode.html">rte_eth_burst_mode</a></em> to be filled with the information of the packet burst mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success</li>
<li>-ENODEV: If <em>port_id</em> is invalid.</li>
<li>-ENOTSUP: routine is not supported by the device PMD.</li>
<li>-EINVAL: The queue_id is out of range. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aabe833160a5ab1f0c5c9769da3624e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe833160a5ab1f0c5c9769da3624e3a">&#9670;&nbsp;</a></span>rte_eth_tx_burst_mode_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_tx_burst_mode_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__burst__mode.html">rte_eth_burst_mode</a> *&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve information about the Tx packet burst mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The Tx queue on the Ethernet device for which information will be retrieved. </td></tr>
    <tr><td class="paramname">mode</td><td>A pointer to a structure of type <em><a class="el" href="structrte__eth__burst__mode.html">rte_eth_burst_mode</a></em> to be filled with the information of the packet burst mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success</li>
<li>-ENODEV: If <em>port_id</em> is invalid.</li>
<li>-ENOTSUP: routine is not supported by the device PMD.</li>
<li>-EINVAL: The queue_id is out of range. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac3814d3730833ea325a299778f1440cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3814d3730833ea325a299778f1440cf">&#9670;&nbsp;</a></span>rte_eth_get_monitor_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_get_monitor_addr </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct rte_power_monitor_cond *&#160;</td>
          <td class="paramname"><em>pmc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Retrieve the monitor condition for a given receive queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The Rx queue on the Ethernet device for which information will be retrieved. </td></tr>
    <tr><td class="paramname">pmc</td><td>The pointer to power-optimized monitoring condition structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success. -ENOTSUP: Operation not supported. -EINVAL: Invalid parameters. -ENODEV: Invalid port ID. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a00d10118286af88a01d3052e9b7ec400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d10118286af88a01d3052e9b7ec400">&#9670;&nbsp;</a></span>rte_eth_dev_get_reg_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_get_reg_info </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct rte_dev_reg_info *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve device registers and register attributes (number of registers and register size)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">info</td><td>Pointer to rte_dev_reg_info structure to fill in. If info-&gt;data is NULL the function fills in the width and length fields. If non-NULL the registers are put into the buffer pointed at by the data field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>others depends on the specific operations implementation. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8866e436d02aa2d73da24857ef3d23fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8866e436d02aa2d73da24857ef3d23fa">&#9670;&nbsp;</a></span>rte_eth_dev_get_eeprom_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_get_eeprom_length </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve size of device EEPROM</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(&gt;=0) EEPROM size if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>others depends on the specific operations implementation. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6564843e5bdd9efcfb86376ea553972a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6564843e5bdd9efcfb86376ea553972a">&#9670;&nbsp;</a></span>rte_eth_dev_get_eeprom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_get_eeprom </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct rte_dev_eeprom_info *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve EEPROM and EEPROM attribute</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">info</td><td>The template includes buffer for return EEPROM data and EEPROM attributes to be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>others depends on the specific operations implementation. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a781645f3ba42b7e2abf8c1e649f932d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781645f3ba42b7e2abf8c1e649f932d6">&#9670;&nbsp;</a></span>rte_eth_dev_set_eeprom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_eeprom </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct rte_dev_eeprom_info *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Program EEPROM with provided data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">info</td><td>The template includes EEPROM data for programming and EEPROM attributes to be filled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter.</li>
<li>(-EIO) if device is removed.</li>
<li>others depends on the specific operations implementation. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a21f2748e0887b5528fda8b667dedae91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f2748e0887b5528fda8b667dedae91">&#9670;&nbsp;</a></span>rte_eth_dev_get_module_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_dev_get_module_info </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__dev__module__info.html">rte_eth_dev_module_info</a> *&#160;</td>
          <td class="paramname"><em>modinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Retrieve the type and size of plugin module EEPROM</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">modinfo</td><td>The type and size of plugin module EEPROM. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter.</li>
<li>(-EIO) if device is removed.</li>
<li>others depends on the specific operations implementation. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6ba332478865156be084572b4893c0e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba332478865156be084572b4893c0e9">&#9670;&nbsp;</a></span>rte_eth_dev_get_module_eeprom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_dev_get_module_eeprom </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct rte_dev_eeprom_info *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Retrieve the data of plugin module EEPROM</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">info</td><td>The template includes the plugin module EEPROM attributes, and the buffer for return plugin module EEPROM data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>others depends on the specific operations implementation. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aab6d4ac37c4c3f2c25f97624a4ecad70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6d4ac37c4c3f2c25f97624a4ecad70">&#9670;&nbsp;</a></span>rte_eth_dev_set_mc_addr_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_mc_addr_list </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ether__addr.html">rte_ether_addr</a> *&#160;</td>
          <td class="paramname"><em>mc_addr_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nb_mc_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the list of multicast addresses to filter on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">mc_addr_set</td><td>The array of multicast addresses to set. Equal to NULL when the function is invoked to flush the set of filtered addresses. </td></tr>
    <tr><td class="paramname">nb_mc_addr</td><td>The number of multicast addresses in the <em>mc_addr_set</em> array. Equal to 0 when the function is invoked to flush the set of filtered addresses. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>(-ENOTSUP) if PMD of <em>port_id</em> doesn't support multicast filtering.</li>
<li>(-ENOSPC) if <em>port_id</em> has not enough multicast filtering resources.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5f45aabbfbb08ef986caddc70c48df4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f45aabbfbb08ef986caddc70c48df4c">&#9670;&nbsp;</a></span>rte_eth_timesync_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_timesync_enable </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable IEEE1588/802.1AS timestamping for an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success.</li>
<li>-ENODEV: The port ID is invalid.</li>
<li>-EIO: if device is removed.</li>
<li>-ENOTSUP: The function is not supported by the Ethernet driver. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a70953d8101144f803db78c2822a3dc37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70953d8101144f803db78c2822a3dc37">&#9670;&nbsp;</a></span>rte_eth_timesync_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_timesync_disable </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable IEEE1588/802.1AS timestamping for an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success.</li>
<li>-ENODEV: The port ID is invalid.</li>
<li>-EIO: if device is removed.</li>
<li>-ENOTSUP: The function is not supported by the Ethernet driver. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0b2e742e5a9410b35def23d9c01ecd0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2e742e5a9410b35def23d9c01ecd0f">&#9670;&nbsp;</a></span>rte_eth_timesync_read_rx_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_timesync_read_rx_timestamp </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read an IEEE1588/802.1AS Rx timestamp from an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">timestamp</td><td>Pointer to the timestamp struct. </td></tr>
    <tr><td class="paramname">flags</td><td>Device specific flags. Used to pass the Rx timesync register index to i40e. Unused in igb/ixgbe, pass 0 instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success.</li>
<li>-EINVAL: No timestamp is available.</li>
<li>-ENODEV: The port ID is invalid.</li>
<li>-EIO: if device is removed.</li>
<li>-ENOTSUP: The function is not supported by the Ethernet driver. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae42db8ae6951b141c67ae822c389197b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae42db8ae6951b141c67ae822c389197b">&#9670;&nbsp;</a></span>rte_eth_timesync_read_tx_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_timesync_read_tx_timestamp </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read an IEEE1588/802.1AS Tx timestamp from an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">timestamp</td><td>Pointer to the timestamp struct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success.</li>
<li>-EINVAL: No timestamp is available.</li>
<li>-ENODEV: The port ID is invalid.</li>
<li>-EIO: if device is removed.</li>
<li>-ENOTSUP: The function is not supported by the Ethernet driver. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a12f941a2006073a1df36009b0956dad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f941a2006073a1df36009b0956dad4">&#9670;&nbsp;</a></span>rte_eth_timesync_adjust_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_timesync_adjust_time </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adjust the timesync clock on an Ethernet device.</p>
<p>This is usually used in conjunction with other Ethdev timesync functions to synchronize the device time using the IEEE1588/802.1AS protocol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">delta</td><td>The adjustment in nanoseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success.</li>
<li>-ENODEV: The port ID is invalid.</li>
<li>-EIO: if device is removed.</li>
<li>-ENOTSUP: The function is not supported by the Ethernet driver. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad7aaa6d846a6e71edb4f6c737cdf60c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7aaa6d846a6e71edb4f6c737cdf60c7">&#9670;&nbsp;</a></span>rte_eth_timesync_read_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_timesync_read_time </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the time from the timesync clock on an Ethernet device.</p>
<p>This is usually used in conjunction with other Ethdev timesync functions to synchronize the device time using the IEEE1588/802.1AS protocol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">time</td><td>Pointer to the timespec struct that holds the time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success.</li>
<li>-EINVAL: Bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a049d73092cce34847ea3653916cae41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049d73092cce34847ea3653916cae41b">&#9670;&nbsp;</a></span>rte_eth_timesync_write_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_timesync_write_time </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the time of the timesync clock on an Ethernet device.</p>
<p>This is usually used in conjunction with other Ethdev timesync functions to synchronize the device time using the IEEE1588/802.1AS protocol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">time</td><td>Pointer to the timespec struct that holds the time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success.</li>
<li>-EINVAL: No timestamp is available.</li>
<li>-ENODEV: The port ID is invalid.</li>
<li>-EIO: if device is removed.</li>
<li>-ENOTSUP: The function is not supported by the Ethernet driver. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4346bf07a0d302c9ba4fe06baffd3196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4346bf07a0d302c9ba4fe06baffd3196">&#9670;&nbsp;</a></span>rte_eth_read_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_read_clock </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>clock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Read the current clock counter of an Ethernet device</p>
<p>This returns the current raw clock value of an Ethernet device. It is a raw amount of ticks, with no given time reference. The value returned here is from the same clock than the one filling timestamp field of Rx packets when using hardware timestamp offload. Therefore it can be used to compute a precise conversion of the device clock to the real time.</p>
<p>E.g, a simple heuristic to derivate the frequency would be: uint64_t start, end; rte_eth_read_clock(port, start); rte_delay_ms(100); rte_eth_read_clock(port, end); double freq = (end - start) * 10;</p>
<p>Compute a common reference with: uint64_t base_time_sec = current_time(); uint64_t base_clock; rte_eth_read_clock(port, base_clock);</p>
<p>Then, convert the raw mbuf timestamp with: base_time_sec + (double)(*timestamp_dynfield(mbuf) - base_clock) / freq;</p>
<p>This simple example will not provide a very good accuracy. One must at least measure multiple times the frequency and do a regression. To avoid deviation from the system time, the common reference can be repeated from time to time. The integer division can also be converted by a multiplication and a shift for better performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">clock</td><td>Pointer to the uint64_t that holds the raw clock value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success.</li>
<li>-ENODEV: The port ID is invalid.</li>
<li>-ENOTSUP: The function is not supported by the Ethernet driver.</li>
<li>-EINVAL: if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa972958b055560b44a6b2a38972d94c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa972958b055560b44a6b2a38972d94c3">&#9670;&nbsp;</a></span>rte_eth_dev_get_port_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_get_port_by_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>port_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the port ID from device name. The device name should be specified as below:</p><ul>
<li>PCIe address (Domain:Bus:Device.Function), for example- 0000:2:00.0</li>
<li>SoC device name, for example- fsl-gmac0</li>
<li>vdev dpdk name, for example- net_[pcap0|null0|tap0]</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>PCI address or name of the device. </td></tr>
    <tr><td class="paramname">port_id</td><td>Pointer to port identifier of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful and port_id is filled.</li>
<li>(-ENODEV or -EINVAL) on failure. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aefc43e2c17cd21cb3a27fbfc1d68f3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc43e2c17cd21cb3a27fbfc1d68f3a1">&#9670;&nbsp;</a></span>rte_eth_dev_get_name_by_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_get_name_by_port </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the device name from port ID. The device name is specified as below:</p><ul>
<li>PCIe address (Domain:Bus:Device.Function), for example- 0000:02:00.0</li>
<li>SoC device name, for example- fsl-gmac0</li>
<li>vdev dpdk name, for example- net_[pcap0|null0|tun0|tap0]</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>Port identifier of the device. </td></tr>
    <tr><td class="paramname">name</td><td>Buffer of size RTE_ETH_NAME_MAX_LEN to store the name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENODEV) if <em>port_id</em> is invalid.</li>
<li>(-EINVAL) on failure. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad31219b87a1733d5b367a7c04c7f7b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31219b87a1733d5b367a7c04c7f7b48">&#9670;&nbsp;</a></span>rte_eth_dev_adjust_nb_rx_tx_desc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_adjust_nb_rx_tx_desc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>nb_rx_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>nb_tx_desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check that numbers of Rx and Tx descriptors satisfy descriptors limits from the Ethernet device information, otherwise adjust them to boundaries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">nb_rx_desc</td><td>A pointer to a uint16_t where the number of receive descriptors stored. </td></tr>
    <tr><td class="paramname">nb_tx_desc</td><td>A pointer to a uint16_t where the number of transmit descriptors stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP, -ENODEV or -EINVAL) on failure. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a75">examples/ipv4_multicast/main.c</a>, and <a class="el" href="examples_2syntony_2main_8c-example.html#a75">examples/syntony/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="ab594dc8be07126874ef7139be51c8fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab594dc8be07126874ef7139be51c8fde">&#9670;&nbsp;</a></span>rte_eth_dev_pool_ops_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_pool_ops_supported </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if a port supports specific mempool ops.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">port_id</td><td>Port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The name of the pool operations to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: best mempool ops choice for this port.</li>
<li>1: mempool ops are supported for this port.</li>
<li>-ENOTSUP: mempool ops not supported for this port.</li>
<li>-ENODEV: Invalid port Identifier.</li>
<li>-EINVAL: Pool param is null. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a539fa8ee80c94d538a42d951e4bcb00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539fa8ee80c94d538a42d951e4bcb00e">&#9670;&nbsp;</a></span>rte_eth_dev_get_sec_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rte_eth_dev_get_sec_ctx </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the security context for the Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>Port identifier of the Ethernet device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NULL on error.</li>
<li>pointer to security context on success. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a07c8c334ea684ba08f052aa45735c917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c8c334ea684ba08f052aa45735c917">&#9670;&nbsp;</a></span>rte_eth_dev_hairpin_capability_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_dev_hairpin_capability_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__hairpin__cap.html">rte_eth_hairpin_cap</a> *&#160;</td>
          <td class="paramname"><em>cap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice</dd></dl>
<p>Query the device hairpin capabilities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">cap</td><td>Pointer to a structure that will hold the hairpin capabilities. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afcb24caf408218da527e40f4f89ccdaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb24caf408218da527e40f4f89ccdaf">&#9670;&nbsp;</a></span>rte_eth_representor_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_representor_info_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__representor__info.html">rte_eth_representor_info</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the representor info of the device.</p>
<p>Get device representor info to be able to calculate a unique representor ID. </p><dl class="section see"><dt>See also</dt><dd>rte_eth_representor_id_get helper.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the device. </td></tr>
    <tr><td class="paramname">info</td><td>A pointer to a representor info structure. NULL to return number of range entries and allocate memory for next call to store detail. The number of ranges that were written into this structure will be placed into its nb_ranges field. This number cannot be larger than the nb_ranges_alloc that by the user before calling this function. It can be smaller than the value returned by the function, however. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(-ENOTSUP) if operation is not supported.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>(&gt;=0) number of available representor range entries. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5db20d79921cad6ad83be1eea28cecee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db20d79921cad6ad83be1eea28cecee">&#9670;&nbsp;</a></span>rte_eth_rx_metadata_negotiate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_rx_metadata_negotiate </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>features</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Negotiate the NIC's ability to deliver specific kinds of metadata to the PMD.</p>
<p>Invoke this API before the first <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a> invocation to let the PMD make preparations that are inconvenient to do later.</p>
<p>The negotiation process is as follows:</p>
<ul>
<li>the application requests features intending to use at least some of them;</li>
<li>the PMD responds with the guaranteed subset of the requested feature set;</li>
<li>the application can retry negotiation with another set of features;</li>
<li>the application can pass zero to clear the negotiation result;</li>
<li>the last negotiated result takes effect upon the ethdev configure and start.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The PMD is supposed to first consider enabling the requested feature set in its entirety. Only if it fails to do so, does it have the right to respond with a smaller set of the originally requested features.</dd>
<dd>
Return code (-ENOTSUP) does not necessarily mean that the requested features are unsupported. In this case, the application should just assume that these features can be used without prior negotiations.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">port_id</td><td>Port (ethdev) identifier</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">features</td><td>Feature selection buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(-EBUSY) if the port can't handle this in its current state;</li>
<li>(-ENOTSUP) if the method itself is not supported by the PMD;</li>
<li>(-ENODEV) if <em>port_id</em> is invalid;</li>
<li>(-EINVAL) if <em>features</em> is NULL;</li>
<li>(-EIO) if the device is removed;</li>
<li>(0) on success </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6897d12b08de1aa7a9a6336527bd4c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6897d12b08de1aa7a9a6336527bd4c1f">&#9670;&nbsp;</a></span>rte_eth_ip_reassembly_capability_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_ip_reassembly_capability_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__ip__reassembly__params.html">rte_eth_ip_reassembly_params</a> *&#160;</td>
          <td class="paramname"><em>capa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Get IP reassembly capabilities supported by the PMD. This is the first API to be called for enabling the IP reassembly offload feature. PMD will return the maximum values of parameters that PMD can support and user can call <a class="el" href="rte__ethdev_8h.html#aa3973f055a644c18206e2478842fa432">rte_eth_ip_reassembly_conf_set()</a> with param values lower than capability.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the device. </td></tr>
    <tr><td class="paramname">capa</td><td>A pointer to <a class="el" href="structrte__eth__ip__reassembly__params.html">rte_eth_ip_reassembly_params</a> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(-ENOTSUP) if offload configuration is not supported by device.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>(-EINVAL) if device is not configured or <em>capa</em> passed is NULL.</li>
<li>(0) on success. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac33a29576956d540ecc6e9326389b22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33a29576956d540ecc6e9326389b22f">&#9670;&nbsp;</a></span>rte_eth_ip_reassembly_conf_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_ip_reassembly_conf_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__ip__reassembly__params.html">rte_eth_ip_reassembly_params</a> *&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Get IP reassembly configuration parameters currently set in PMD. The API will return error if the configuration is not already set using <a class="el" href="rte__ethdev_8h.html#aa3973f055a644c18206e2478842fa432">rte_eth_ip_reassembly_conf_set()</a> before calling this API or if the device is not configured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the device. </td></tr>
    <tr><td class="paramname">conf</td><td>A pointer to <a class="el" href="structrte__eth__ip__reassembly__params.html">rte_eth_ip_reassembly_params</a> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(-ENOTSUP) if offload configuration is not supported by device.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>(-EINVAL) if device is not configured or if <em>conf</em> passed is NULL or if configuration is not set using <a class="el" href="rte__ethdev_8h.html#aa3973f055a644c18206e2478842fa432">rte_eth_ip_reassembly_conf_set()</a>.</li>
<li>(0) on success. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa3973f055a644c18206e2478842fa432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3973f055a644c18206e2478842fa432">&#9670;&nbsp;</a></span>rte_eth_ip_reassembly_conf_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_ip_reassembly_conf_set </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__eth__ip__reassembly__params.html">rte_eth_ip_reassembly_params</a> *&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Set IP reassembly configuration parameters if the PMD supports IP reassembly offload. User should first call <a class="el" href="rte__ethdev_8h.html#a6897d12b08de1aa7a9a6336527bd4c1f">rte_eth_ip_reassembly_capability_get()</a> to check the maximum values supported by the PMD before setting the configuration. The use of this API is mandatory to enable this feature and should be called before <a class="el" href="rte__ethdev_8h.html#afdc834c1c52e9fb512301990468ca7c2">rte_eth_dev_start()</a>.</p>
<p>In datapath, PMD cannot guarantee that IP reassembly is always successful. Hence, PMD shall register mbuf dynamic field and dynamic flag using rte_eth_ip_reassembly_dynfield_register() to denote incomplete IP reassembly. If dynfield is not successfully registered, error will be returned and IP reassembly offload cannot be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the device. </td></tr>
    <tr><td class="paramname">conf</td><td>A pointer to <a class="el" href="structrte__eth__ip__reassembly__params.html">rte_eth_ip_reassembly_params</a> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(-ENOTSUP) if offload configuration is not supported by device.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EIO) if device is removed.</li>
<li>(-EINVAL) if device is not configured or if device is already started or if <em>conf</em> passed is NULL or if mbuf dynfield is not registered successfully by the PMD.</li>
<li>(0) on success. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2cc089b7ee8966e1b3ae367cb9694e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc089b7ee8966e1b3ae367cb9694e3a">&#9670;&nbsp;</a></span>rte_eth_dev_priv_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_dev_priv_dump </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice</dd></dl>
<p>Dump private info from device to a file. Provided data and the order depends on the PMD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">file</td><td>A pointer to a file for output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) on success.</li>
<li>(-ENODEV) if <em>port_id</em> is invalid.</li>
<li>(-EINVAL) if null file.</li>
<li>(-ENOTSUP) if the device does not support this function.</li>
<li>(-EIO) if device is removed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8595c621f1443ce7b690362556cd8b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8595c621f1443ce7b690362556cd8b69">&#9670;&nbsp;</a></span>rte_eth_rx_descriptor_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_rx_descriptor_dump </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice</dd></dl>
<p>Dump ethdev Rx descriptor info to a file.</p>
<p>This API is used for debugging, not a dataplane API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>A Rx queue identifier on this port. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset of the descriptor starting from tail. (0 is the next packet to be received by the driver). </td></tr>
    <tr><td class="paramname">num</td><td>The number of the descriptors to dump. </td></tr>
    <tr><td class="paramname">file</td><td>A pointer to a file for output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, zero.</li>
<li>On failure, a negative value. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac84ffcb6d9c042a5ebb1cc28e8ca4d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84ffcb6d9c042a5ebb1cc28e8ca4d8f">&#9670;&nbsp;</a></span>rte_eth_tx_descriptor_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_tx_descriptor_dump </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice</dd></dl>
<p>Dump ethdev Tx descriptor info to a file.</p>
<p>This API is used for debugging, not a dataplane API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>A Tx queue identifier on this port. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset of the descriptor starting from tail. (0 is the place where the next packet will be send). </td></tr>
    <tr><td class="paramname">num</td><td>The number of the descriptors to dump. </td></tr>
    <tr><td class="paramname">file</td><td>A pointer to a file for output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, zero.</li>
<li>On failure, a negative value. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa86cc8371ee0ccd37de1aac86de2001c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86cc8371ee0ccd37de1aac86de2001c">&#9670;&nbsp;</a></span>rte_eth_cman_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_cman_info_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__cman__info.html">rte_eth_cman_info</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice</dd></dl>
<p>Retrieve the information for ethdev congestion management</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">info</td><td>A pointer to a structure of type <em><a class="el" href="structrte__eth__cman__info.html">rte_eth_cman_info</a></em> to be filled with the information about congestion management. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if support for cman_info_get does not exist.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afb3a8189e26117c3bb32a5f958f58f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3a8189e26117c3bb32a5f958f58f06">&#9670;&nbsp;</a></span>rte_eth_cman_config_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_cman_config_init </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__cman__config.html">rte_eth_cman_config</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice</dd></dl>
<p>Initialize the ethdev congestion management configuration structure with default values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">config</td><td>A pointer to a structure of type <em><a class="el" href="structrte__eth__cman__config.html">rte_eth_cman_config</a></em> to be initialized with default value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if support for cman_config_init does not exist.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af9071b6429e82b7540180f5dbbee4a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9071b6429e82b7540180f5dbbee4a01">&#9670;&nbsp;</a></span>rte_eth_cman_config_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_cman_config_set </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__eth__cman__config.html">rte_eth_cman_config</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice</dd></dl>
<p>Configure ethdev congestion management</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">config</td><td>A pointer to a structure of type <em><a class="el" href="structrte__eth__cman__config.html">rte_eth_cman_config</a></em> to be configured. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if support for cman_config_set does not exist.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a05d4b5ac9ecaf8dec9c1471425476864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d4b5ac9ecaf8dec9c1471425476864">&#9670;&nbsp;</a></span>rte_eth_cman_config_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_cman_config_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__cman__config.html">rte_eth_cman_config</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice</dd></dl>
<p>Retrieve the applied ethdev congestion management parameters for the given port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">config</td><td>A pointer to a structure of type <em><a class="el" href="structrte__eth__cman__config.html">rte_eth_cman_config</a></em> to retrieve congestion management parameters for the given object. Application must fill all parameters except mode_param parameter in struct <a class="el" href="structrte__eth__cman__config.html">rte_eth_cman_config</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if support for cman_config_get does not exist.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a3e7d76a451b46348686ea97d6367f102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7d76a451b46348686ea97d6367f102">&#9670;&nbsp;</a></span>rte_eth_rx_burst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_eth_rx_burst </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **&#160;</td>
          <td class="paramname"><em>rx_pkts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nb_pkts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve a burst of input packets from a receive queue of an Ethernet device. The retrieved packets are stored in <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> structures whose pointers are supplied in the <em>rx_pkts</em> array.</p>
<p>The <a class="el" href="rte__ethdev_8h.html#a3e7d76a451b46348686ea97d6367f102">rte_eth_rx_burst()</a> function loops, parsing the Rx ring of the receive queue, up to <em>nb_pkts</em> packets, and for each completed Rx descriptor in the ring, it performs the following operations:</p>
<ul>
<li>Initialize the <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> data structure associated with the Rx descriptor according to the information provided by the NIC into that Rx descriptor.</li>
<li>Store the <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> data structure into the next entry of the <em>rx_pkts</em> array.</li>
<li>Replenish the Rx descriptor with a new <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> buffer allocated from the memory pool associated with the receive queue at initialization time.</li>
</ul>
<p>When retrieving an input packet that was scattered by the controller into multiple receive descriptors, the <a class="el" href="rte__ethdev_8h.html#a3e7d76a451b46348686ea97d6367f102">rte_eth_rx_burst()</a> function appends the associated <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> buffers to the first buffer of the packet.</p>
<p>The <a class="el" href="rte__ethdev_8h.html#a3e7d76a451b46348686ea97d6367f102">rte_eth_rx_burst()</a> function returns the number of packets actually retrieved, which is the number of <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> data structures effectively supplied into the <em>rx_pkts</em> array. A return value equal to <em>nb_pkts</em> indicates that the Rx queue contained at least <em>rx_pkts</em> packets, and this is likely to signify that other received packets remain in the input queue. Applications implementing a "retrieve as much received packets as possible" policy can check this specific case and keep invoking the <a class="el" href="rte__ethdev_8h.html#a3e7d76a451b46348686ea97d6367f102">rte_eth_rx_burst()</a> function until a value less than <em>nb_pkts</em> is returned.</p>
<p>This receive method has the following advantages:</p>
<ul>
<li>It allows a run-to-completion network stack engine to retrieve and to immediately process received packets in a fast burst-oriented approach, avoiding the overhead of unnecessary intermediate packet queue/dequeue operations.</li>
<li>Conversely, it also allows an asynchronous-oriented processing method to retrieve bursts of received packets and to immediately queue them for further parallel processing by another logical core, for instance. However, instead of having received packets being individually queued by the driver, this approach allows the caller of the <a class="el" href="rte__ethdev_8h.html#a3e7d76a451b46348686ea97d6367f102">rte_eth_rx_burst()</a> function to queue a burst of retrieved packets at a time and therefore dramatically reduce the cost of enqueue/dequeue operations per packet.</li>
<li>It allows the <a class="el" href="rte__ethdev_8h.html#a3e7d76a451b46348686ea97d6367f102">rte_eth_rx_burst()</a> function of the driver to take advantage of burst-oriented hardware features (CPU cache, prefetch instructions, and so on) to minimize the number of CPU cycles per packet.</li>
</ul>
<p>To summarize, the proposed receive API enables many burst-oriented optimizations in both synchronous and asynchronous packet processing environments with no overhead in both cases.</p>
<dl class="section note"><dt>Note</dt><dd>Some drivers using vector instructions require that <em>nb_pkts</em> is divisible by 4 or 8, depending on the driver implementation.</dd></dl>
<p>The <a class="el" href="rte__ethdev_8h.html#a3e7d76a451b46348686ea97d6367f102">rte_eth_rx_burst()</a> function does not provide any error notification to avoid the corresponding overhead. As a hint, the upper-level application might check the status of the device link once being systematically returned a 0 value for a given number of tries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the receive queue from which to retrieve input packets. The value must be in the range [0, nb_rx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">rx_pkts</td><td>The address of an array of pointers to <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> structures that must be large enough to store <em>nb_pkts</em> pointers in it. </td></tr>
    <tr><td class="paramname">nb_pkts</td><td>The maximum number of packets to retrieve. The value must be divisible by 8 in order to work with any driver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets actually retrieved, which is the number of pointers to <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> structures effectively supplied to the <em>rx_pkts</em> array. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a46">examples/ipv4_multicast/main.c</a>, <a class="el" href="examples_2receiver_2main_8c-example.html#a16">examples/receiver/main.c</a>, and <a class="el" href="examples_2syntony_2main_8c-example.html#a46">examples/syntony/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l06045">6045</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="af5e8c822c9c5f82879eb0c01ca50ea9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e8c822c9c5f82879eb0c01ca50ea9c">&#9670;&nbsp;</a></span>rte_eth_rx_queue_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_eth_rx_queue_count </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of used descriptors of a Rx queue</p>
<p>Since it's a dataplane function, no check is performed on port_id and queue_id. The caller must therefore ensure that the port is enabled and the queue is configured and running.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The queue ID on the specific port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of used descriptors in the specific queue, or:<ul>
<li>(-ENODEV) if <em>port_id</em> is invalid.</li>
<li>(-EINVAL) if <em>queue_id</em> is invalid</li>
<li>(-ENOTSUP) if the device does not support this function </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l06118">6118</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="ad3129ac553f76fd90d7e5eea46a63398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3129ac553f76fd90d7e5eea46a63398">&#9670;&nbsp;</a></span>rte_eth_rx_descriptor_status()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_eth_rx_descriptor_status </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check the status of a Rx descriptor in the queue</p>
<p>It should be called in a similar context than the Rx function:</p><ul>
<li>on a dataplane core</li>
<li>not concurrently on the same queue</li>
</ul>
<p>Since it's a dataplane function, no check is performed on port_id and queue_id. The caller must therefore ensure that the port is enabled and the queue is configured and running.</p>
<p>Note: accessing to a random descriptor in the ring may trigger cache misses and have a performance impact.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>A valid port identifier of the Ethernet device which. </td></tr>
    <tr><td class="paramname">queue_id</td><td>A valid Rx queue identifier on this port. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset of the descriptor starting from tail (0 is the next packet to be received by the driver).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(RTE_ETH_RX_DESC_AVAIL): Descriptor is available for the hardware to receive a packet.</li>
<li>(RTE_ETH_RX_DESC_DONE): Descriptor is done, it is filled by hw, but not yet processed by the driver (i.e. in the receive queue).</li>
<li>(RTE_ETH_RX_DESC_UNAVAIL): Descriptor is unavailable, either hold by the driver and not yet returned to hw, or reserved by the hw.</li>
<li>(-EINVAL) bad descriptor offset.</li>
<li>(-ENOTSUP) if the device does not support this function.</li>
<li>(-ENODEV) bad port or queue (only if compiled with debug). </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l06190">6190</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="ad43765b16539f14b46926235dccd0460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43765b16539f14b46926235dccd0460">&#9670;&nbsp;</a></span>rte_eth_tx_descriptor_status()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_eth_tx_descriptor_status </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check the status of a Tx descriptor in the queue.</p>
<p>It should be called in a similar context than the Tx function:</p><ul>
<li>on a dataplane core</li>
<li>not concurrently on the same queue</li>
</ul>
<p>Since it's a dataplane function, no check is performed on port_id and queue_id. The caller must therefore ensure that the port is enabled and the queue is configured and running.</p>
<p>Note: accessing to a random descriptor in the ring may trigger cache misses and have a performance impact.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>A valid port identifier of the Ethernet device which. </td></tr>
    <tr><td class="paramname">queue_id</td><td>A valid Tx queue identifier on this port. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset of the descriptor starting from tail (0 is the place where the next packet will be send).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(RTE_ETH_TX_DESC_FULL) Descriptor is being processed by the hw, i.e. in the transmit queue.</li>
<li>(RTE_ETH_TX_DESC_DONE) Hardware is done with this descriptor, it can be reused by the driver.</li>
<li>(RTE_ETH_TX_DESC_UNAVAIL): Descriptor is unavailable, reserved by the driver or the hardware.</li>
<li>(-EINVAL) bad descriptor offset.</li>
<li>(-ENOTSUP) if the device does not support this function.</li>
<li>(-ENODEV) bad port or queue (only if compiled with debug). </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l06261">6261</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a83e56cabbd31637efd648e3fc010392b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e56cabbd31637efd648e3fc010392b">&#9670;&nbsp;</a></span>rte_eth_tx_burst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_eth_tx_burst </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **&#160;</td>
          <td class="paramname"><em>tx_pkts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_pkts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send a burst of output packets on a transmit queue of an Ethernet device.</p>
<p>The <a class="el" href="rte__ethdev_8h.html#a83e56cabbd31637efd648e3fc010392b">rte_eth_tx_burst()</a> function is invoked to transmit output packets on the output queue <em>queue_id</em> of the Ethernet device designated by its <em>port_id</em>. The <em>nb_pkts</em> parameter is the number of packets to send which are supplied in the <em>tx_pkts</em> array of <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> structures, each of them allocated from a pool created with <a class="el" href="rte__mbuf_8h.html#a593921f13307803b94bbb4e0932db962">rte_pktmbuf_pool_create()</a>. The <a class="el" href="rte__ethdev_8h.html#a83e56cabbd31637efd648e3fc010392b">rte_eth_tx_burst()</a> function loops, sending <em>nb_pkts</em> packets, up to the number of transmit descriptors available in the Tx ring of the transmit queue. For each packet to send, the <a class="el" href="rte__ethdev_8h.html#a83e56cabbd31637efd648e3fc010392b">rte_eth_tx_burst()</a> function performs the following operations:</p>
<ul>
<li>Pick up the next available descriptor in the transmit ring.</li>
<li>Free the network buffer previously sent with that descriptor, if any.</li>
<li>Initialize the transmit descriptor with the information provided in the *rte_mbuf data structure.</li>
</ul>
<p>In the case of a segmented packet composed of a list of <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> buffers, the <a class="el" href="rte__ethdev_8h.html#a83e56cabbd31637efd648e3fc010392b">rte_eth_tx_burst()</a> function uses several transmit descriptors of the ring.</p>
<p>The <a class="el" href="rte__ethdev_8h.html#a83e56cabbd31637efd648e3fc010392b">rte_eth_tx_burst()</a> function returns the number of packets it actually sent. A return value equal to <em>nb_pkts</em> means that all packets have been sent, and this is likely to signify that other output packets could be immediately transmitted again. Applications that implement a "send as many packets to transmit as possible" policy can check this specific case and keep invoking the <a class="el" href="rte__ethdev_8h.html#a83e56cabbd31637efd648e3fc010392b">rte_eth_tx_burst()</a> function until a value less than <em>nb_pkts</em> is returned.</p>
<p>It is the responsibility of the <a class="el" href="rte__ethdev_8h.html#a83e56cabbd31637efd648e3fc010392b">rte_eth_tx_burst()</a> function to transparently free the memory buffers of packets previously sent. This feature is driven by the <em>tx_free_thresh</em> value supplied to the <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a> function at device configuration time. When the number of free Tx descriptors drops below this threshold, the <a class="el" href="rte__ethdev_8h.html#a83e56cabbd31637efd648e3fc010392b">rte_eth_tx_burst()</a> function must [attempt to] free the <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> buffers of those packets whose transmission was effectively completed.</p>
<p>If the PMD is RTE_ETH_TX_OFFLOAD_MT_LOCKFREE capable, multiple threads can invoke this function concurrently on the same Tx queue without SW lock. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__ethdev_8h.html#a7593f4fff04f4ae1b1d718db7ca7dc8c">rte_eth_dev_info_get</a>, struct <a class="el" href="structrte__eth__txconf.html#a6cfe3b3ee46e9a8b8c62a64294b0b564">rte_eth_txconf::offloads</a></dd>
<dd>
<a class="el" href="rte__ethdev_8h.html#a76ff3eecd29f6c2f26793bec8c2ecff6">rte_eth_tx_prepare</a> to perform some prior checks or adjustments for offloads.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function must not modify mbufs (including packets data) unless the refcnt is 1. An exception is the bonding PMD, which does not have "Tx prepare" support, in this case, mbufs may be modified.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the transmit queue through which output packets must be sent. The value must be in the range [0, nb_tx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">tx_pkts</td><td>The address of an array of <em>nb_pkts</em> pointers to <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> structures which contain the output packets. </td></tr>
    <tr><td class="paramname">nb_pkts</td><td>The maximum number of packets to transmit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of output packets actually stored in transmit descriptors of the transmit ring. The return value can be less than the value of the <em>tx_pkts</em> parameter when the transmit ring is full or has been filled up. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a16">examples/ipv4_multicast/main.c</a>, <a class="el" href="examples_2sender_2main_8c-example.html#a20">examples/sender/main.c</a>, and <a class="el" href="examples_2syntony_2main_8c-example.html#a16">examples/syntony/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l06385">6385</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a76ff3eecd29f6c2f26793bec8c2ecff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ff3eecd29f6c2f26793bec8c2ecff6">&#9670;&nbsp;</a></span>rte_eth_tx_prepare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_eth_tx_prepare </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **&#160;</td>
          <td class="paramname"><em>tx_pkts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_pkts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Process a burst of output packets on a transmit queue of an Ethernet device.</p>
<p>The <a class="el" href="rte__ethdev_8h.html#a76ff3eecd29f6c2f26793bec8c2ecff6">rte_eth_tx_prepare()</a> function is invoked to prepare output packets to be transmitted on the output queue <em>queue_id</em> of the Ethernet device designated by its <em>port_id</em>. The <em>nb_pkts</em> parameter is the number of packets to be prepared which are supplied in the <em>tx_pkts</em> array of <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> structures, each of them allocated from a pool created with <a class="el" href="rte__mbuf_8h.html#a593921f13307803b94bbb4e0932db962">rte_pktmbuf_pool_create()</a>. For each packet to send, the <a class="el" href="rte__ethdev_8h.html#a76ff3eecd29f6c2f26793bec8c2ecff6">rte_eth_tx_prepare()</a> function performs the following operations:</p>
<ul>
<li>Check if packet meets devices requirements for Tx offloads.</li>
<li>Check limitations about number of segments.</li>
<li>Check additional requirements when debug is enabled.</li>
<li>Update and/or reset required checksums when Tx offload is set for packet.</li>
</ul>
<p>Since this function can modify packet data, provided mbufs must be safely writable (e.g. modified data cannot be in shared segment).</p>
<p>The <a class="el" href="rte__ethdev_8h.html#a76ff3eecd29f6c2f26793bec8c2ecff6">rte_eth_tx_prepare()</a> function returns the number of packets ready to be sent. A return value equal to <em>nb_pkts</em> means that all packets are valid and ready to be sent, otherwise stops processing on the first invalid packet and leaves the rest packets untouched.</p>
<p>When this functionality is not implemented in the driver, all packets are are returned untouched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. The value must be a valid port ID. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the transmit queue through which output packets must be sent. The value must be in the range [0, nb_tx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">tx_pkts</td><td>The address of an array of <em>nb_pkts</em> pointers to <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> structures which contain the output packets. </td></tr>
    <tr><td class="paramname">nb_pkts</td><td>The maximum number of packets to process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets correct and ready to be sent. The return value can be less than the value of the <em>tx_pkts</em> parameter when some packet doesn't meet devices requirements with rte_errno set appropriately:<ul>
<li>EINVAL: offload flags are not correctly set</li>
<li>ENOTSUP: the offload feature is not supported by the hardware</li>
<li>ENODEV: if <em>port_id</em> is invalid (with debug enabled only) </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l06495">6495</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="ace8779bcecccb86c94ce3638f35c9254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8779bcecccb86c94ce3638f35c9254">&#9670;&nbsp;</a></span>rte_eth_tx_buffer_flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_eth_tx_buffer_flush </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__dev__tx__buffer.html">rte_eth_dev_tx_buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send any packets queued up for transmission on a port and HW queue</p>
<p>This causes an explicit flush of packets previously buffered via the <a class="el" href="rte__ethdev_8h.html#a0e941a74ae1b1b886764bc282458d946">rte_eth_tx_buffer()</a> function. It returns the number of packets successfully sent to the NIC, and calls the error callback for any unsent packets. Unless explicitly set up otherwise, the default callback simply frees the unsent packets back to the owning mempool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the transmit queue through which output packets must be sent. The value must be in the range [0, nb_tx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">buffer</td><td>Buffer of packets to be transmit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets successfully sent to the Ethernet device. The error callback is called for any packets which could not be sent. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l06580">6580</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a0e941a74ae1b1b886764bc282458d946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e941a74ae1b1b886764bc282458d946">&#9670;&nbsp;</a></span>rte_eth_tx_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> uint16_t rte_eth_tx_buffer </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__dev__tx__buffer.html">rte_eth_dev_tx_buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>tx_pkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Buffer a single packet for future transmission on a port and queue</p>
<p>This function takes a single mbuf/packet and buffers it for later transmission on the particular port and queue specified. Once the buffer is full of packets, an attempt will be made to transmit all the buffered packets. In case of error, where not all packets can be transmitted, a callback is called with the unsent packets as a parameter. If no callback is explicitly set up, the unsent packets are just freed back to the owning mempool. The function returns the number of packets actually sent i.e. 0 if no buffer flush occurred, otherwise the number of packets successfully flushed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the transmit queue through which output packets must be sent. The value must be in the range [0, nb_tx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">buffer</td><td>Buffer used to collect packets to be sent. </td></tr>
    <tr><td class="paramname">tx_pkt</td><td>Pointer to the packet mbuf to be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 = packet has been buffered for later transmission N &gt; 0 = packet has been buffered, and the buffer was subsequently flushed, causing N packets to be sent, and the error callback to be called for the rest. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l06633">6633</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="ad5f3fc7c24dff3df06b2927d01b5339d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f3fc7c24dff3df06b2927d01b5339d">&#9670;&nbsp;</a></span>rte_eth_recycle_mbufs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __rte_experimental uint16_t rte_eth_recycle_mbufs </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rx_port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rx_queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tx_port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tx_queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__recycle__rxq__info.html">rte_eth_recycle_rxq_info</a> *&#160;</td>
          <td class="paramname"><em>recycle_rxq_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice</dd></dl>
<p>Recycle used mbufs from a transmit queue of an Ethernet device, and move these mbufs into a mbuf ring for a receive queue of an Ethernet device. This can bypass mempool path to save CPU cycles.</p>
<p>The <a class="el" href="rte__ethdev_8h.html#ad5f3fc7c24dff3df06b2927d01b5339d">rte_eth_recycle_mbufs()</a> function loops, with <a class="el" href="rte__ethdev_8h.html#a3e7d76a451b46348686ea97d6367f102">rte_eth_rx_burst()</a> and <a class="el" href="rte__ethdev_8h.html#a83e56cabbd31637efd648e3fc010392b">rte_eth_tx_burst()</a> functions, freeing Tx used mbufs and replenishing Rx descriptors. The number of recycling mbufs depends on the request of Rx mbuf ring, with the constraint of enough used mbufs from Tx mbuf ring.</p>
<p>For each recycling mbufs, the <a class="el" href="rte__ethdev_8h.html#ad5f3fc7c24dff3df06b2927d01b5339d">rte_eth_recycle_mbufs()</a> function performs the following operations:</p>
<ul>
<li>Copy used <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> buffer pointers from Tx mbuf ring into Rx mbuf ring.</li>
<li>Replenish the Rx descriptors with the recycling <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> mbufs freed from the Tx mbuf ring.</li>
</ul>
<p>This function spilts Rx and Tx path with different callback functions. The callback function recycle_tx_mbufs_reuse is for Tx driver. The callback function recycle_rx_descriptors_refill is for Rx driver. <a class="el" href="rte__ethdev_8h.html#ad5f3fc7c24dff3df06b2927d01b5339d">rte_eth_recycle_mbufs()</a> can support the case that Rx Ethernet device is different from Tx Ethernet device.</p>
<p>It is the responsibility of users to select the Rx/Tx queue pair to recycle mbufs. Before call this function, users must call rte_eth_recycle_rxq_info_get function to retrieve selected Rx queue information. </p><dl class="section see"><dt>See also</dt><dd>rte_eth_recycle_rxq_info_get, struct <a class="el" href="structrte__eth__recycle__rxq__info.html">rte_eth_recycle_rxq_info</a></dd></dl>
<p>Currently, the <a class="el" href="rte__ethdev_8h.html#ad5f3fc7c24dff3df06b2927d01b5339d">rte_eth_recycle_mbufs()</a> function can support to feed 1 Rx queue from 2 Tx queues in the same thread. Do not pair the Rx queue and Tx queue in different threads, in order to avoid memory error rewriting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rx_port_id</td><td>Port identifying the receive side. </td></tr>
    <tr><td class="paramname">rx_queue_id</td><td>The index of the receive queue identifying the receive side. The value must be in the range [0, nb_rx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">tx_port_id</td><td>Port identifying the transmit side. </td></tr>
    <tr><td class="paramname">tx_queue_id</td><td>The index of the transmit queue identifying the transmit side. The value must be in the range [0, nb_tx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#a1a7d3a20b102fee222541fda50fd87bd">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">recycle_rxq_info</td><td>A pointer to a structure of type <em><a class="el" href="structrte__eth__recycle__rxq__info.html">rte_eth_recycle_rxq_info</a></em> which contains the information of the Rx queue mbuf ring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of recycling mbufs. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l06698">6698</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a91f7771caa2f14871b8d33571428a7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f7771caa2f14871b8d33571428a7d4">&#9670;&nbsp;</a></span>rte_eth_buffer_split_get_supported_hdr_ptypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_eth_buffer_split_get_supported_hdr_ptypes </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ptypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Get supported header protocols to split on Rx.</p>
<p>When a packet type is announced to be split, it <em>must</em> be supported by the PMD. For instance, if eth-ipv4, eth-ipv4-udp is announced, the PMD must return the following packet types for these packets:</p><ul>
<li>Ether/IPv4 -&gt; RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4</li>
<li>Ether/IPv4/UDP -&gt; RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4 | RTE_PTYPE_L4_UDP</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">port_id</td><td>The port identifier of the device. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ptypes</td><td>An array pointer to store supported protocol headers, allocated by caller. These ptypes are composed with RTE_PTYPE_*. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Size of the array pointed by param ptypes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(&gt;=0) Number of supported ptypes. If the number of types exceeds num, only num entries will be filled into the ptypes array, but the full count of supported ptypes will be returned.</li>
<li>(-ENOTSUP) if header protocol is not supported by device.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aae24fc4f200e75aa8215f797b2561dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae24fc4f200e75aa8215f797b2561dbf">&#9670;&nbsp;</a></span>link_speed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t link_speed</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTE_ETH_SPEED_NUM_ </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00000">0</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a8a9a73e9e688ae4d72cf319872c0bdf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9a73e9e688ae4d72cf319872c0bdf1">&#9670;&nbsp;</a></span>link_duplex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t link_duplex</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTE_ETH_LINK_[HALF/FULL]_DUPLEX </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00001">1</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="aab62bf07f7dec65838124372503f7d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab62bf07f7dec65838124372503f7d09">&#9670;&nbsp;</a></span>link_autoneg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t link_autoneg</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTE_ETH_LINK_[AUTONEG/FIXED] </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00002">2</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
<a id="a226d9406cdd84b64b3c3701e5ab8be88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226d9406cdd84b64b3c3701e5ab8be88">&#9670;&nbsp;</a></span>link_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t link_status</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTE_ETH_LINK_[DOWN/UP] </p>

<p class="definition">Definition at line <a class="el" href="rte__ethdev_8h_source.html#l00003">3</a> of file <a class="el" href="rte__ethdev_8h_source.html">rte_ethdev.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
