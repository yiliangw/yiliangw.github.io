<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/pipeline/rte_swx_pipeline.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">23.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_d73c785d64cf20f491fb8bfb6f272940.html">pipeline</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_swx_pipeline.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;rte_compat.h&gt;</code><br />
<code>#include &quot;<a class="el" href="rte__swx__port_8h_source.html">rte_swx_port.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rte__swx__table_8h_source.html">rte_swx_table.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rte__swx__extern_8h_source.html">rte_swx_extern.h</a>&quot;</code><br />
</div>
<p><a href="rte__swx__pipeline_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__swx__pipeline__mirroring__params.html">rte_swx_pipeline_mirroring_params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__swx__field__params.html">rte_swx_field_params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__swx__match__field__params.html">rte_swx_match_field_params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__swx__pipeline__table__params.html">rte_swx_pipeline_table_params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__swx__pipeline__selector__params.html">rte_swx_pipeline_selector_params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__swx__pipeline__learner__params.html">rte_swx_pipeline_learner_params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8cbd081d1d1eae4d98db265e929fa3ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#a8cbd081d1d1eae4d98db265e929fa3ad">RTE_SWX_NAME_SIZE</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:a8cbd081d1d1eae4d98db265e929fa3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73bde02948df95aba08f72e5fad4dd44"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#a73bde02948df95aba08f72e5fad4dd44">RTE_SWX_INSTRUCTION_SIZE</a>&#160;&#160;&#160;256</td></tr>
<tr class="separator:a73bde02948df95aba08f72e5fad4dd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922e888accb44df9f638fba773248597"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#a922e888accb44df9f638fba773248597">RTE_SWX_INSTRUCTION_TOKENS_MAX</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a922e888accb44df9f638fba773248597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa938f2b5cfea58ed55c1f686515d615b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#aa938f2b5cfea58ed55c1f686515d615b">RTE_SWX_PACKET_MIRRORING_SLOTS_DEFAULT</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:aa938f2b5cfea58ed55c1f686515d615b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f6a5c4b68ba975a56b6a2409934622"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#a09f6a5c4b68ba975a56b6a2409934622">RTE_SWX_PACKET_MIRRORING_SESSIONS_DEFAULT</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:a09f6a5c4b68ba975a56b6a2409934622"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac318f1caccefcd35b8d2fab48eb7b41f"><td class="memItemLeft" align="right" valign="top">__rte_experimental struct rte_swx_pipeline *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#ac318f1caccefcd35b8d2fab48eb7b41f">rte_swx_pipeline_find</a> (const char *name)</td></tr>
<tr class="separator:ac318f1caccefcd35b8d2fab48eb7b41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6675f7406960c27c9914cc9d50d5f59c"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#a6675f7406960c27c9914cc9d50d5f59c">rte_swx_pipeline_config</a> (struct rte_swx_pipeline **p, const char *name, int numa_node)</td></tr>
<tr class="separator:a6675f7406960c27c9914cc9d50d5f59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39763c4a2f86182567428c9ef87e9ef9"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#a39763c4a2f86182567428c9ef87e9ef9">rte_swx_pipeline_port_in_type_register</a> (struct rte_swx_pipeline *p, const char *name, struct <a class="el" href="structrte__swx__port__in__ops.html">rte_swx_port_in_ops</a> *ops)</td></tr>
<tr class="separator:a39763c4a2f86182567428c9ef87e9ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6036e26529510d4ac56bc60350bf385a"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#a6036e26529510d4ac56bc60350bf385a">rte_swx_pipeline_port_in_config</a> (struct rte_swx_pipeline *p, uint32_t port_id, const char *port_type_name, void *args)</td></tr>
<tr class="separator:a6036e26529510d4ac56bc60350bf385a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecd230083f2891513d806a483ff839c"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#a7ecd230083f2891513d806a483ff839c">rte_swx_pipeline_port_out_type_register</a> (struct rte_swx_pipeline *p, const char *name, struct <a class="el" href="structrte__swx__port__out__ops.html">rte_swx_port_out_ops</a> *ops)</td></tr>
<tr class="separator:a7ecd230083f2891513d806a483ff839c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4346c8f10fac6984bba35ab6f4b17ded"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#a4346c8f10fac6984bba35ab6f4b17ded">rte_swx_pipeline_port_out_config</a> (struct rte_swx_pipeline *p, uint32_t port_id, const char *port_type_name, void *args)</td></tr>
<tr class="separator:a4346c8f10fac6984bba35ab6f4b17ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481a67666ad8c7fd3f4b819e882f85d3"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#a481a67666ad8c7fd3f4b819e882f85d3">rte_swx_pipeline_mirroring_config</a> (struct rte_swx_pipeline *p, struct <a class="el" href="structrte__swx__pipeline__mirroring__params.html">rte_swx_pipeline_mirroring_params</a> *params)</td></tr>
<tr class="separator:a481a67666ad8c7fd3f4b819e882f85d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac746f075e45c8fef05da9a5e23c6e542"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#ac746f075e45c8fef05da9a5e23c6e542">rte_swx_pipeline_extern_type_register</a> (struct rte_swx_pipeline *p, const char *name, const char *mailbox_struct_type_name, <a class="el" href="rte__swx__extern_8h.html#a44e3fc3a331fd1afd6bb79aa90354a3c">rte_swx_extern_type_constructor_t</a> constructor, <a class="el" href="rte__swx__extern_8h.html#a05e3f4561f84797f73a26631be08e69c">rte_swx_extern_type_destructor_t</a> destructor)</td></tr>
<tr class="separator:ac746f075e45c8fef05da9a5e23c6e542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b3c79f59fb78877b0b488bc0ce03fe"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#a35b3c79f59fb78877b0b488bc0ce03fe">rte_swx_pipeline_extern_type_member_func_register</a> (struct rte_swx_pipeline *p, const char *extern_type_name, const char *name, <a class="el" href="rte__swx__extern_8h.html#a8658e3115732b3d193e9adabd86d303b">rte_swx_extern_type_member_func_t</a> member_func)</td></tr>
<tr class="separator:a35b3c79f59fb78877b0b488bc0ce03fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5f5f65a453a497f6b30d701b374138"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#a9b5f5f65a453a497f6b30d701b374138">rte_swx_pipeline_extern_object_config</a> (struct rte_swx_pipeline *p, const char *extern_type_name, const char *name, const char *args)</td></tr>
<tr class="separator:a9b5f5f65a453a497f6b30d701b374138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76e81e10afba1bfadfcd9e94291f3e7"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#ad76e81e10afba1bfadfcd9e94291f3e7">rte_swx_pipeline_extern_func_register</a> (struct rte_swx_pipeline *p, const char *name, const char *mailbox_struct_type_name, <a class="el" href="rte__swx__extern_8h.html#a5348aee899737aa95f257636f8f3d771">rte_swx_extern_func_t</a> func)</td></tr>
<tr class="separator:ad76e81e10afba1bfadfcd9e94291f3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32764a3987bfafa10b97fba9ddd27cb"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#ab32764a3987bfafa10b97fba9ddd27cb">rte_swx_pipeline_hash_func_register</a> (struct rte_swx_pipeline *p, const char *name, <a class="el" href="rte__swx__hash__func_8h.html#a870692ec942996217fe0863ae0ee3e2d">rte_swx_hash_func_t</a> func)</td></tr>
<tr class="separator:ab32764a3987bfafa10b97fba9ddd27cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb11a0594e221c3feac9fbd20786a999"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#acb11a0594e221c3feac9fbd20786a999">rte_swx_pipeline_rss_config</a> (struct rte_swx_pipeline *p, const char *name)</td></tr>
<tr class="separator:acb11a0594e221c3feac9fbd20786a999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0642998e17e569d4682677dd1dad1b8"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#ac0642998e17e569d4682677dd1dad1b8">rte_swx_pipeline_struct_type_register</a> (struct rte_swx_pipeline *p, const char *name, struct <a class="el" href="structrte__swx__field__params.html">rte_swx_field_params</a> *fields, uint32_t n_fields, int last_field_has_variable_size)</td></tr>
<tr class="separator:ac0642998e17e569d4682677dd1dad1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b294989c54e1f80c59ad29a9a42c77"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#aa4b294989c54e1f80c59ad29a9a42c77">rte_swx_pipeline_packet_header_register</a> (struct rte_swx_pipeline *p, const char *name, const char *struct_type_name)</td></tr>
<tr class="separator:aa4b294989c54e1f80c59ad29a9a42c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a6af043904ad85efbc6abe2b310b43"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#a46a6af043904ad85efbc6abe2b310b43">rte_swx_pipeline_packet_metadata_register</a> (struct rte_swx_pipeline *p, const char *struct_type_name)</td></tr>
<tr class="separator:a46a6af043904ad85efbc6abe2b310b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7715fccb903f8eca8b000953b188cb"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#acf7715fccb903f8eca8b000953b188cb">rte_swx_pipeline_action_config</a> (struct rte_swx_pipeline *p, const char *name, const char *args_struct_type_name, const char **instructions, uint32_t n_instructions)</td></tr>
<tr class="separator:acf7715fccb903f8eca8b000953b188cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ab8c6afb87bc1597bdc0e4bca61e3c"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#a84ab8c6afb87bc1597bdc0e4bca61e3c">rte_swx_pipeline_table_type_register</a> (struct rte_swx_pipeline *p, const char *name, enum <a class="el" href="rte__swx__table_8h.html#a0615f78ffad9c86f6a4dac0282ebe677">rte_swx_table_match_type</a> match_type, struct <a class="el" href="structrte__swx__table__ops.html">rte_swx_table_ops</a> *ops)</td></tr>
<tr class="separator:a84ab8c6afb87bc1597bdc0e4bca61e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e558fb3ac5463a13c0ce04d31137a53"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#a4e558fb3ac5463a13c0ce04d31137a53">rte_swx_pipeline_table_config</a> (struct rte_swx_pipeline *p, const char *name, struct <a class="el" href="structrte__swx__pipeline__table__params.html">rte_swx_pipeline_table_params</a> *params, const char *recommended_table_type_name, const char *args, uint32_t size)</td></tr>
<tr class="separator:a4e558fb3ac5463a13c0ce04d31137a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab180528fe877ecca253831b1a1352f1d"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#ab180528fe877ecca253831b1a1352f1d">rte_swx_pipeline_selector_config</a> (struct rte_swx_pipeline *p, const char *name, struct <a class="el" href="structrte__swx__pipeline__selector__params.html">rte_swx_pipeline_selector_params</a> *params)</td></tr>
<tr class="separator:ab180528fe877ecca253831b1a1352f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c9fc3dea0b40222f1bce9f22b69a4c"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#ae7c9fc3dea0b40222f1bce9f22b69a4c">rte_swx_pipeline_learner_config</a> (struct rte_swx_pipeline *p, const char *name, struct <a class="el" href="structrte__swx__pipeline__learner__params.html">rte_swx_pipeline_learner_params</a> *params, uint32_t size, uint32_t *timeout, uint32_t n_timeouts)</td></tr>
<tr class="separator:ae7c9fc3dea0b40222f1bce9f22b69a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6efc80dae7472797db3fb34c002b36f9"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#a6efc80dae7472797db3fb34c002b36f9">rte_swx_pipeline_regarray_config</a> (struct rte_swx_pipeline *p, const char *name, uint32_t size, uint64_t init_val)</td></tr>
<tr class="separator:a6efc80dae7472797db3fb34c002b36f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12b39ace69c371ad4bc87a618edb52a"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#ae12b39ace69c371ad4bc87a618edb52a">rte_swx_pipeline_metarray_config</a> (struct rte_swx_pipeline *p, const char *name, uint32_t size)</td></tr>
<tr class="separator:ae12b39ace69c371ad4bc87a618edb52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0a1eb96a8d1ea3617e7431c6852d55"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#a3f0a1eb96a8d1ea3617e7431c6852d55">rte_swx_pipeline_instructions_config</a> (struct rte_swx_pipeline *p, const char **instructions, uint32_t n_instructions)</td></tr>
<tr class="separator:a3f0a1eb96a8d1ea3617e7431c6852d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0729024871b3d4c2b68f72efe63eab0b"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#a0729024871b3d4c2b68f72efe63eab0b">rte_swx_pipeline_build</a> (struct rte_swx_pipeline *p)</td></tr>
<tr class="separator:a0729024871b3d4c2b68f72efe63eab0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b798e0338b1c07d5a8d71f814bbacd"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#af6b798e0338b1c07d5a8d71f814bbacd">rte_swx_pipeline_codegen</a> (FILE *spec_file, FILE *code_file, uint32_t *err_line, const char **err_msg)</td></tr>
<tr class="separator:af6b798e0338b1c07d5a8d71f814bbacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180c0dcb613a2510d820072d23f7b861"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#a180c0dcb613a2510d820072d23f7b861">rte_swx_pipeline_build_from_lib</a> (struct rte_swx_pipeline **p, const char *name, const char *lib_file_name, FILE *iospec_file, int numa_node)</td></tr>
<tr class="separator:a180c0dcb613a2510d820072d23f7b861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbccbad59da013a4fb3c90f091964cca"><td class="memItemLeft" align="right" valign="top">__rte_experimental void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#abbccbad59da013a4fb3c90f091964cca">rte_swx_pipeline_run</a> (struct rte_swx_pipeline *p, uint32_t n_instructions)</td></tr>
<tr class="separator:abbccbad59da013a4fb3c90f091964cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63f3b92f9f33d215ffdd5c125ac2896"><td class="memItemLeft" align="right" valign="top">__rte_experimental void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#ab63f3b92f9f33d215ffdd5c125ac2896">rte_swx_pipeline_flush</a> (struct rte_swx_pipeline *p)</td></tr>
<tr class="separator:ab63f3b92f9f33d215ffdd5c125ac2896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5a6e7904b24149286cd31e428056bf"><td class="memItemLeft" align="right" valign="top">__rte_experimental void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__swx__pipeline_8h.html#abd5a6e7904b24149286cd31e428056bf">rte_swx_pipeline_free</a> (struct rte_swx_pipeline *p)</td></tr>
<tr class="separator:abd5a6e7904b24149286cd31e428056bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE SWX Pipeline </p>

<p class="definition">Definition in file <a class="el" href="rte__swx__pipeline_8h_source.html">rte_swx_pipeline.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a8cbd081d1d1eae4d98db265e929fa3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cbd081d1d1eae4d98db265e929fa3ad">&#9670;&nbsp;</a></span>RTE_SWX_NAME_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_SWX_NAME_SIZE&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Name size. </p>

<p class="definition">Definition at line <a class="el" href="rte__swx__pipeline_8h_source.html#l00027">27</a> of file <a class="el" href="rte__swx__pipeline_8h_source.html">rte_swx_pipeline.h</a>.</p>

</div>
</div>
<a id="a73bde02948df95aba08f72e5fad4dd44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73bde02948df95aba08f72e5fad4dd44">&#9670;&nbsp;</a></span>RTE_SWX_INSTRUCTION_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_SWX_INSTRUCTION_SIZE&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instruction size. </p>

<p class="definition">Definition at line <a class="el" href="rte__swx__pipeline_8h_source.html#l00032">32</a> of file <a class="el" href="rte__swx__pipeline_8h_source.html">rte_swx_pipeline.h</a>.</p>

</div>
</div>
<a id="a922e888accb44df9f638fba773248597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922e888accb44df9f638fba773248597">&#9670;&nbsp;</a></span>RTE_SWX_INSTRUCTION_TOKENS_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_SWX_INSTRUCTION_TOKENS_MAX&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instruction tokens. </p>

<p class="definition">Definition at line <a class="el" href="rte__swx__pipeline_8h_source.html#l00037">37</a> of file <a class="el" href="rte__swx__pipeline_8h_source.html">rte_swx_pipeline.h</a>.</p>

</div>
</div>
<a id="aa938f2b5cfea58ed55c1f686515d615b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa938f2b5cfea58ed55c1f686515d615b">&#9670;&nbsp;</a></span>RTE_SWX_PACKET_MIRRORING_SLOTS_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_SWX_PACKET_MIRRORING_SLOTS_DEFAULT&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default number of packet mirroring slots. </p>

<p class="definition">Definition at line <a class="el" href="rte__swx__pipeline_8h_source.html#l00184">184</a> of file <a class="el" href="rte__swx__pipeline_8h_source.html">rte_swx_pipeline.h</a>.</p>

</div>
</div>
<a id="a09f6a5c4b68ba975a56b6a2409934622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f6a5c4b68ba975a56b6a2409934622">&#9670;&nbsp;</a></span>RTE_SWX_PACKET_MIRRORING_SESSIONS_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_SWX_PACKET_MIRRORING_SESSIONS_DEFAULT&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default maximum number of packet mirroring sessions. </p>

<p class="definition">Definition at line <a class="el" href="rte__swx__pipeline_8h_source.html#l00189">189</a> of file <a class="el" href="rte__swx__pipeline_8h_source.html">rte_swx_pipeline.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac318f1caccefcd35b8d2fab48eb7b41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac318f1caccefcd35b8d2fab48eb7b41f">&#9670;&nbsp;</a></span>rte_swx_pipeline_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental struct rte_swx_pipeline* rte_swx_pipeline_find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline find</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Pipeline name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Valid pipeline handle if found or NULL otherwise. </dd></dl>

</div>
</div>
<a id="a6675f7406960c27c9914cc9d50d5f59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6675f7406960c27c9914cc9d50d5f59c">&#9670;&nbsp;</a></span>rte_swx_pipeline_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_config </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline **&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numa_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline configure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>Pipeline handle. Must point to valid memory. Contains valid pipeline handle when the function returns successfully. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Pipeline unique name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numa_node</td><td>Non-Uniform Memory Access (NUMA) node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -EEXIST: Pipeline with this name already exists. </dd></dl>

</div>
</div>
<a id="a39763c4a2f86182567428c9ef87e9ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39763c4a2f86182567428c9ef87e9ef9">&#9670;&nbsp;</a></span>rte_swx_pipeline_port_in_type_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_port_in_type_register </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__swx__port__in__ops.html">rte_swx_port_in_ops</a> *&#160;</td>
          <td class="paramname"><em>ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline input port type register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Input port type name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ops</td><td>Input port type operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -EEXIST: Input port type with this name already exists. </dd></dl>

</div>
</div>
<a id="a6036e26529510d4ac56bc60350bf385a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6036e26529510d4ac56bc60350bf385a">&#9670;&nbsp;</a></span>rte_swx_pipeline_port_in_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_port_in_config </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>port_type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline input port configure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_id</td><td>Input port ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_type_name</td><td>Existing input port type name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Input port creation arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -ENODEV: Input port object creation error. </dd></dl>

</div>
</div>
<a id="a7ecd230083f2891513d806a483ff839c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecd230083f2891513d806a483ff839c">&#9670;&nbsp;</a></span>rte_swx_pipeline_port_out_type_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_port_out_type_register </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__swx__port__out__ops.html">rte_swx_port_out_ops</a> *&#160;</td>
          <td class="paramname"><em>ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline output port type register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Output port type name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ops</td><td>Output port type operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -EEXIST: Output port type with this name already exists. </dd></dl>

</div>
</div>
<a id="a4346c8f10fac6984bba35ab6f4b17ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4346c8f10fac6984bba35ab6f4b17ded">&#9670;&nbsp;</a></span>rte_swx_pipeline_port_out_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_port_out_config </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>port_type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline output port configure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_id</td><td>Output port ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port_type_name</td><td>Existing output port type name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Output port creation arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -ENODEV: Output port object creation error. </dd></dl>

</div>
</div>
<a id="a481a67666ad8c7fd3f4b819e882f85d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481a67666ad8c7fd3f4b819e882f85d3">&#9670;&nbsp;</a></span>rte_swx_pipeline_mirroring_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_mirroring_config </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__swx__pipeline__mirroring__params.html">rte_swx_pipeline_mirroring_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Packet mirroring configure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Packet mirroring parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough memory; -EEXIST: Pipeline was already built successfully. </dd></dl>

</div>
</div>
<a id="ac746f075e45c8fef05da9a5e23c6e542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac746f075e45c8fef05da9a5e23c6e542">&#9670;&nbsp;</a></span>rte_swx_pipeline_extern_type_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_extern_type_register </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mailbox_struct_type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__swx__extern_8h.html#a44e3fc3a331fd1afd6bb79aa90354a3c">rte_swx_extern_type_constructor_t</a>&#160;</td>
          <td class="paramname"><em>constructor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__swx__extern_8h.html#a05e3f4561f84797f73a26631be08e69c">rte_swx_extern_type_destructor_t</a>&#160;</td>
          <td class="paramname"><em>destructor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline extern type register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Extern type name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mailbox_struct_type_name</td><td>Name of existing struct type used to define the mailbox size and layout for the extern objects that are instances of this type. Each extern object gets its own mailbox, which is used to pass the input arguments to the member functions and retrieve the output results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constructor</td><td>Function used to create the extern objects that are instances of this type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destructor</td><td>Function used to free the extern objects that are instances of this type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -EEXIST: Extern type with this name already exists. </dd></dl>

</div>
</div>
<a id="a35b3c79f59fb78877b0b488bc0ce03fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35b3c79f59fb78877b0b488bc0ce03fe">&#9670;&nbsp;</a></span>rte_swx_pipeline_extern_type_member_func_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_extern_type_member_func_register </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>extern_type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__swx__extern_8h.html#a8658e3115732b3d193e9adabd86d303b">rte_swx_extern_type_member_func_t</a>&#160;</td>
          <td class="paramname"><em>member_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline extern type member function register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extern_type_name</td><td>Existing extern type name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name for the new member function to be added to the extern type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">member_func</td><td>The new member function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -EEXIST: Member function with this name already exists for this type; -ENOSPC: Maximum number of member functions reached for this type. </dd></dl>

</div>
</div>
<a id="a9b5f5f65a453a497f6b30d701b374138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5f5f65a453a497f6b30d701b374138">&#9670;&nbsp;</a></span>rte_swx_pipeline_extern_object_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_extern_object_config </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>extern_type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline extern object configure</p>
<p>Instantiate a given extern type to create new extern object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extern_type_name</td><td>Existing extern type name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name for the new object instantiating the extern type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Extern object constructor arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -EEXIST: Extern object with this name already exists; -ENODEV: Extern object constructor error. </dd></dl>

</div>
</div>
<a id="ad76e81e10afba1bfadfcd9e94291f3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76e81e10afba1bfadfcd9e94291f3e7">&#9670;&nbsp;</a></span>rte_swx_pipeline_extern_func_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_extern_func_register </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mailbox_struct_type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__swx__extern_8h.html#a5348aee899737aa95f257636f8f3d771">rte_swx_extern_func_t</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline extern function register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Extern function name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mailbox_struct_type_name</td><td>Name of existing struct type used to define the mailbox size and layout for this extern function. The mailbox is used to pass the input arguments to the extern function and retrieve the output results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The extern function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -EEXIST: Extern function with this name already exists. </dd></dl>

</div>
</div>
<a id="ab32764a3987bfafa10b97fba9ddd27cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32764a3987bfafa10b97fba9ddd27cb">&#9670;&nbsp;</a></span>rte_swx_pipeline_hash_func_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_hash_func_register </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__swx__hash__func_8h.html#a870692ec942996217fe0863ae0ee3e2d">rte_swx_hash_func_t</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline hash function register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Hash function name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Hash function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -EEXIST: Hash function with this name already exists. </dd></dl>

</div>
</div>
<a id="acb11a0594e221c3feac9fbd20786a999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb11a0594e221c3feac9fbd20786a999">&#9670;&nbsp;</a></span>rte_swx_pipeline_rss_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_rss_config </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline Receive Side Scaling (RSS) object configure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name for the new RSS object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -EEXIST: RSS object with this name already exists. </dd></dl>

</div>
</div>
<a id="ac0642998e17e569d4682677dd1dad1b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0642998e17e569d4682677dd1dad1b8">&#9670;&nbsp;</a></span>rte_swx_pipeline_struct_type_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_struct_type_register </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__swx__field__params.html">rte_swx_field_params</a> *&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>last_field_has_variable_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline struct type register</p>
<p>Structs are used extensively in many part of the pipeline to define the size and layout of a specific memory piece such as: headers, meta-data, action data stored in a table entry, mailboxes for extern objects and functions. Similar to C language structs, they are a well defined sequence of fields, with each field having a unique name and a constant size.</p>
<p>In order to use structs to express variable size packet headers such as IPv4 with options, it is allowed for the last field of the struct type to have a variable size between 0 and <em>n_bits</em> bits, with the actual size of this field determined at run-time for each packet. This struct feature is restricted to just a few selected instructions that deal with packet headers, so a typical struct generally has a constant size that is fully known when its struct type is registered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Struct type name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fields</td><td>The sequence of struct fields. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_fields</td><td>The number of struct fields. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_field_has_variable_size</td><td>If non-zero (true), then the last field has a variable size between 0 and <em>n_bits</em> bits, with its actual size determined at run-time for each packet. If zero (false), then the last field has a constant size of <em>n_bits</em> bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -EEXIST: Struct type with this name already exists. </dd></dl>

</div>
</div>
<a id="aa4b294989c54e1f80c59ad29a9a42c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b294989c54e1f80c59ad29a9a42c77">&#9670;&nbsp;</a></span>rte_swx_pipeline_packet_header_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_packet_header_register </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>struct_type_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline packet header register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Header name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">struct_type_name</td><td>The struct type instantiated by this packet header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -EEXIST: Header with this name already exists; -ENOSPC: Maximum number of headers reached for the pipeline. </dd></dl>

</div>
</div>
<a id="a46a6af043904ad85efbc6abe2b310b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a6af043904ad85efbc6abe2b310b43">&#9670;&nbsp;</a></span>rte_swx_pipeline_packet_metadata_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_packet_metadata_register </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>struct_type_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline packet meta-data register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">struct_type_name</td><td>The struct type instantiated by the packet meta-data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument. </dd></dl>

</div>
</div>
<a id="acf7715fccb903f8eca8b000953b188cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf7715fccb903f8eca8b000953b188cb">&#9670;&nbsp;</a></span>rte_swx_pipeline_action_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_action_config </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>args_struct_type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>instructions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n_instructions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instruction operands:</p>
<pre>+-----+---------------------------+------------------+-----+-----+</pre> <pre>|     | Description               | Format           | DST | SRC |</pre> <pre>+-----+---------------------------+------------------+-----+-----+</pre> <pre>| hdr | Header                    | h.header         |     |     |</pre> <pre>+-----+---------------------------+------------------+-----+-----+</pre> <pre>| act | Action                    | ACTION           |     |     |</pre> <pre>+-----+---------------------------+------------------+-----+-----+</pre> <pre>| tbl | Table                     | TABLE            |     |     |</pre> <pre>+-----+---------------------------+------------------+-----+-----+</pre> <pre>| H   | Header field              | h.header.field   | YES | YES |</pre> <pre>+-----+---------------------------+------------------+-----+-----+</pre> <pre>| M   | Meta-data field           | m.field          | YES | YES |</pre> <pre>+-----+---------------------------+------------------+-----+-----+</pre> <pre>| E   | Extern obj mailbox field  | e.ext_obj.field  | YES | YES |</pre> <pre>+-----+---------------------------+------------------+-----+-----+</pre> <pre>| F   | Extern func mailbox field | f.ext_func.field | YES | YES |</pre> <pre>+-----+---------------------------+------------------+-----+-----+</pre> <pre>| T   | Table action data field   | t.header.field   | NO  | YES |</pre> <pre>+-----+---------------------------+------------------+-----+-----+</pre> <pre>| I   | Immediate value (64-bit)  | h.header.field   | NO  | YES |</pre> <pre>+-----+---------------------------+------------------+-----+-----+</pre><p>Instruction set:</p>
<pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| Instr.     | Instruction          | Instruction       | 1st  | 2nd    |</pre> <pre>| Name       | Description          | Format            | opnd.| opnd.  |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| rx         | Receive one pkt      | rx m.port_in      | M    |        |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| tx         | Transmit one pkt     | tx m.port_out     | M    |        |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| extract    | Extract one hdr      | extract h.hdr     | hdr  |        |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| emit       | Emit one hdr         | emit h.hdr        | hdr  |        |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| validate   | Validate one hdr     | validate h.hdr    | hdr  |        |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| invalidate | Invalidate one hdr   | invalidate h.hdr  | hdr  |        |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| mov        | dst = src            | mov dst src       | HMEF | HMEFTI |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| add        | dst += src           | add dst src       | HMEF | HMEFTI |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| sub        | dst -= src           | add dst src       | HMEF | HMEFTI |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| ckadd      | Checksum add: dst =  | add dst src       | HMEF | HMEFTI |</pre> <pre>|            | dst '+ src[0:1] '+   |                   |      | or hdr |</pre> <pre>|            | src[2:3] '+ ...      |                   |      |        |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| cksub      | Checksum subtract:   | add dst src       | HMEF | HMEFTI |</pre> <pre>|            | dst = dst '- src     |                   |      |        |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| and        | dst &amp;= src           | and dst src       | HMEF | HMEFTI |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| or         | dst |= src           | or  dst src       | HMEF | HMEFTI |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| xor        | dst ^= src           | xor dst src       | HMEF | HMEFTI |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| shl        | dst &lt;&lt;= src          | shl dst src       | HMEF | HMEFTI |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| shr        | dst &gt;&gt;= src          | shr dst src       | HMEF | HMEFTI |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| table      | Table lookup         | table TABLE       | tbl  |        |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| extern     | Ext obj member func  | extern e.obj.mfunc| ext  |        |</pre> <pre>|            | call or ext func call| extern f.func     |      |        |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| jmp        | Unconditional jump   | jmp LABEL         |      |        |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| jmpv       | Jump if hdr is valid | jmpv LABEL h.hdr  | hdr  |        |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| jmpnv      | Jump if hdr is inval | jmpnv LABEL h.hdr | hdr  |        |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| jmph       | Jump if tbl lkp hit  | jmph LABEL        |      |        |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| jmpnh      | Jump if tbl lkp miss | jmpnh LABEL       |      |        |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| jmpa       | Jump if action run   | jmpa LABEL ACTION | act  |        |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| jmpna      | Jump if act not run  | jmpna LABEL ACTION| act  |        |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| jmpeq      | Jump if (a == b)     | jmpeq LABEL a b   | HMEFT| HMEFTI |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| jmpneq     | Jump if (a != b)     | jmpneq LABEL a b  | HMEFT| HMEFTI |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| jmplt      | Jump if (a &lt; b)      | jmplt LABEL a b   | HMEFT| HMEFTI |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| jmpgt      | Jump if (a &gt; b)      | jmpgt LABEL a b   | HMEFT| HMEFTI |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre> <pre>| return     | Return from action   | return            |      |        |</pre> <pre>+------------+----------------------+-------------------+------+--------+</pre><p>At initialization time, the pipeline and action instructions (including the symbolic name operands) are translated to internal data structures that are used at run-time. Pipeline action configure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Action name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args_struct_type_name</td><td>The struct type instantiated by the action data. The action data represent the action arguments that are stored in the table entry together with the action ID. Set to NULL when the action does not have any arguments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">instructions</td><td>Action instructions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_instructions</td><td>Number of action instructions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -EEXIST: Action with this name already exists. </dd></dl>

</div>
</div>
<a id="a84ab8c6afb87bc1597bdc0e4bca61e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ab8c6afb87bc1597bdc0e4bca61e3c">&#9670;&nbsp;</a></span>rte_swx_pipeline_table_type_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_table_type_register </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__swx__table_8h.html#a0615f78ffad9c86f6a4dac0282ebe677">rte_swx_table_match_type</a>&#160;</td>
          <td class="paramname"><em>match_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__swx__table__ops.html">rte_swx_table_ops</a> *&#160;</td>
          <td class="paramname"><em>ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline table type register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Table type name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">match_type</td><td>Match type implemented by the new table type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ops</td><td>Table type operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -EEXIST: Table type with this name already exists. </dd></dl>

</div>
</div>
<a id="a4e558fb3ac5463a13c0ce04d31137a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e558fb3ac5463a13c0ce04d31137a53">&#9670;&nbsp;</a></span>rte_swx_pipeline_table_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_table_config </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__swx__pipeline__table__params.html">rte_swx_pipeline_table_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>recommended_table_type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline table configure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Table name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Table parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recommended_table_type_name</td><td>Recommended table type. Typically set to NULL. Useful as guidance when there are multiple table types registered for the match type of the table, as determined from the table match fields specification. Silently ignored if the recommended table type does not exist or it serves a different match type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Table creation arguments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Guideline on maximum number of table entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -EEXIST: Table with this name already exists; -ENODEV: Table creation error. </dd></dl>

</div>
</div>
<a id="ab180528fe877ecca253831b1a1352f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab180528fe877ecca253831b1a1352f1d">&#9670;&nbsp;</a></span>rte_swx_pipeline_selector_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_selector_config </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__swx__pipeline__selector__params.html">rte_swx_pipeline_selector_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline selector table configure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Selector table name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Selector table parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -EEXIST: Selector table with this name already exists; -ENODEV: Selector table creation error. </dd></dl>

</div>
</div>
<a id="ae7c9fc3dea0b40222f1bce9f22b69a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c9fc3dea0b40222f1bce9f22b69a4c">&#9670;&nbsp;</a></span>rte_swx_pipeline_learner_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_learner_config </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__swx__pipeline__learner__params.html">rte_swx_pipeline_learner_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n_timeouts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline learner table configure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Learner table name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Learner table parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The maximum number of table entries. Must be non-zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Array of possible table entry timeouts in seconds. Must be non-NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_timeouts</td><td>Number of elements in the <em>timeout</em> array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -EEXIST: Learner table with this name already exists; -ENODEV: Learner table creation error. </dd></dl>

</div>
</div>
<a id="a6efc80dae7472797db3fb34c002b36f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6efc80dae7472797db3fb34c002b36f9">&#9670;&nbsp;</a></span>rte_swx_pipeline_regarray_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_regarray_config </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>init_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline register array configure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Register array name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of registers in the array. Each register is 64-bit in size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_val</td><td>Initial value for every register in the array. The recommended value is 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -EEXIST: Register array with this name already exists. </dd></dl>

</div>
</div>
<a id="ae12b39ace69c371ad4bc87a618edb52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12b39ace69c371ad4bc87a618edb52a">&#9670;&nbsp;</a></span>rte_swx_pipeline_metarray_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_metarray_config </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline meter array configure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Meter array name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of meters in the array. Each meter in the array implements the Two Rate Three Color Marker (trTCM) algorithm, as specified by RFC 2698. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -EEXIST: Meter array with this name already exists. </dd></dl>

</div>
</div>
<a id="a3f0a1eb96a8d1ea3617e7431c6852d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0a1eb96a8d1ea3617e7431c6852d55">&#9670;&nbsp;</a></span>rte_swx_pipeline_instructions_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_instructions_config </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>instructions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n_instructions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline instructions configure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">instructions</td><td>Pipeline instructions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_instructions</td><td>Number of pipeline instructions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory. </dd></dl>

</div>
</div>
<a id="a0729024871b3d4c2b68f72efe63eab0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0729024871b3d4c2b68f72efe63eab0b">&#9670;&nbsp;</a></span>rte_swx_pipeline_build()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_build </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline build</p>
<p>Once called, the pipeline build operation marks the end of pipeline configuration. At this point, all the internal data structures needed to run the pipeline are built.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -EEXIST: Pipeline was already built successfully. </dd></dl>

</div>
</div>
<a id="af6b798e0338b1c07d5a8d71f814bbacd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b798e0338b1c07d5a8d71f814bbacd">&#9670;&nbsp;</a></span>rte_swx_pipeline_codegen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_codegen </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>spec_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>code_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>err_line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>err_msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline C code generate based on input specification file</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spec_file</td><td>Pipeline specification file (.spec) provided as input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code_file</td><td>Pipeline C language file (.c) to be generated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err_line</td><td>In case of error and non-NULL, the line number within the <em>spec</em> file where the error occurred. The first line number in the file is 1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err_msg</td><td>In case of error and non-NULL, the error message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -EEXIST: Resource with the same name already exists. </dd></dl>

</div>
</div>
<a id="a180c0dcb613a2510d820072d23f7b861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180c0dcb613a2510d820072d23f7b861">&#9670;&nbsp;</a></span>rte_swx_pipeline_build_from_lib()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_swx_pipeline_build_from_lib </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline **&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lib_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>iospec_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numa_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline build from shared object library</p>
<p>The shared object library must be built from the C language source code file previously generated by the <a class="el" href="rte__swx__pipeline_8h.html#af6b798e0338b1c07d5a8d71f814bbacd">rte_swx_pipeline_codegen()</a> API function.</p>
<p>The pipeline I/O specification file defines the I/O ports of the pipeline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>Pipeline handle. Must point to valid memory. Contains valid pipeline handle when the function returns successfully. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Pipeline unique name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lib_file_name</td><td>Shared object library file name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iospec_file</td><td>Pipeline I/O specification file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numa_node</td><td>Non-Uniform Memory Access (NUMA) node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or the following error codes otherwise: -EINVAL: Invalid argument; -ENOMEM: Not enough space/cannot allocate memory; -EEXIST: Pipeline with this name already exists; -ENODEV: Extern object or table creation error. </dd></dl>

</div>
</div>
<a id="abbccbad59da013a4fb3c90f091964cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbccbad59da013a4fb3c90f091964cca">&#9670;&nbsp;</a></span>rte_swx_pipeline_run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental void rte_swx_pipeline_run </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n_instructions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline run</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_instructions</td><td>Number of instructions to execute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab63f3b92f9f33d215ffdd5c125ac2896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63f3b92f9f33d215ffdd5c125ac2896">&#9670;&nbsp;</a></span>rte_swx_pipeline_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental void rte_swx_pipeline_flush </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline flush</p>
<p>Flush all output ports of the pipeline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. If p is NULL, no operation is performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd5a6e7904b24149286cd31e428056bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5a6e7904b24149286cd31e428056bf">&#9670;&nbsp;</a></span>rte_swx_pipeline_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental void rte_swx_pipeline_free </td>
          <td>(</td>
          <td class="paramtype">struct rte_swx_pipeline *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline free</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pipeline handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
