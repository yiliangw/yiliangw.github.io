<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/mldev/rte_mldev.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">23.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_b73939df4dddd401741125ae6cd93947.html">mldev</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_mldev.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="rte__common_8h_source.html">rte_common.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__log_8h_source.html">rte_log.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>&gt;</code><br />
</div>
<p><a href="rte__mldev_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__ml__dev__info.html">rte_ml_dev_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__ml__dev__config.html">rte_ml_dev_config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__ml__dev__qp__conf.html">rte_ml_dev_qp_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__ml__buff__seg.html">rte_ml_buff_seg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__ml__op.html">rte_ml_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__ml__op__error.html">rte_ml_op_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__ml__dev__stats.html">rte_ml_dev_stats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__ml__dev__xstats__map.html">rte_ml_dev_xstats_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__ml__model__params.html">rte_ml_model_params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__ml__io__info.html">rte_ml_io_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__ml__model__info.html">rte_ml_model_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a42f8c080077682ecef6df0d0f28777d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a42f8c080077682ecef6df0d0f28777d0">RTE_ML_STR_MAX</a>&#160;&#160;&#160;128</td></tr>
<tr class="separator:a42f8c080077682ecef6df0d0f28777d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae21b2ce3d4fe4483d1e985fc2c85e640"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#ae21b2ce3d4fe4483d1e985fc2c85e640">rte_ml_dev_stop_flush_t</a>) (int16_t dev_id, uint16_t qp_id, struct <a class="el" href="structrte__ml__op.html">rte_ml_op</a> *op)</td></tr>
<tr class="separator:ae21b2ce3d4fe4483d1e985fc2c85e640"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac94a968deaaf216abdab941792c87477"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#ac94a968deaaf216abdab941792c87477">rte_ml_op_status</a> { <a class="el" href="rte__mldev_8h.html#ac94a968deaaf216abdab941792c87477a3d1c84d4ff60af8d81d777d898227c21">RTE_ML_OP_STATUS_SUCCESS</a> = 0
, <a class="el" href="rte__mldev_8h.html#ac94a968deaaf216abdab941792c87477a97c0b08103be366d94a0a4dae63fc62e">RTE_ML_OP_STATUS_NOT_PROCESSED</a>
, <a class="el" href="rte__mldev_8h.html#ac94a968deaaf216abdab941792c87477a05d8685c0bfff9450ec78c73e167a680">RTE_ML_OP_STATUS_ERROR</a>
 }</td></tr>
<tr class="separator:ac94a968deaaf216abdab941792c87477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae36c341633f4c0c720575504b2110ee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#aae36c341633f4c0c720575504b2110ee">rte_ml_dev_xstats_mode</a> { <a class="el" href="rte__mldev_8h.html#aae36c341633f4c0c720575504b2110eeaf95584b9dc9470283dce35d7c965e9c3">RTE_ML_DEV_XSTATS_DEVICE</a>
, <a class="el" href="rte__mldev_8h.html#aae36c341633f4c0c720575504b2110eea146d80cd48d44def1fd79c1db2020027">RTE_ML_DEV_XSTATS_MODEL</a>
 }</td></tr>
<tr class="separator:aae36c341633f4c0c720575504b2110ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3eb6d23d36573262224389791cc2e1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#ada3eb6d23d36573262224389791cc2e1">rte_ml_io_type</a> { <br />
&#160;&#160;<a class="el" href="rte__mldev_8h.html#ada3eb6d23d36573262224389791cc2e1ada836f2aa4be5da420ab843b4ed5aa7c">RTE_ML_IO_TYPE_UNKNOWN</a> = 0
, <a class="el" href="rte__mldev_8h.html#ada3eb6d23d36573262224389791cc2e1ab9a01c952ffc314ebfbf2b6a0be1f180">RTE_ML_IO_TYPE_INT8</a>
, <a class="el" href="rte__mldev_8h.html#ada3eb6d23d36573262224389791cc2e1a36583b48f1e20f3bb1531acd506daa8e">RTE_ML_IO_TYPE_UINT8</a>
, <a class="el" href="rte__mldev_8h.html#ada3eb6d23d36573262224389791cc2e1a93150ba94083d9b603ba474b07f2b985">RTE_ML_IO_TYPE_INT16</a>
, <br />
&#160;&#160;<a class="el" href="rte__mldev_8h.html#ada3eb6d23d36573262224389791cc2e1a39d87cecb6eb8a3814abdf9ed82c9a42">RTE_ML_IO_TYPE_UINT16</a>
, <a class="el" href="rte__mldev_8h.html#ada3eb6d23d36573262224389791cc2e1ad7db1a937acdf4d0fc585fd6bf995de6">RTE_ML_IO_TYPE_INT32</a>
, <a class="el" href="rte__mldev_8h.html#ada3eb6d23d36573262224389791cc2e1aa956c8da11b2e65add0e98fd44f130dc">RTE_ML_IO_TYPE_UINT32</a>
, <a class="el" href="rte__mldev_8h.html#ada3eb6d23d36573262224389791cc2e1a177df4f7f4c00e6c0a22f014f787266a">RTE_ML_IO_TYPE_FP8</a>
, <br />
&#160;&#160;<a class="el" href="rte__mldev_8h.html#ada3eb6d23d36573262224389791cc2e1aed26440921920e30d7f91c2d1d4f4620">RTE_ML_IO_TYPE_FP16</a>
, <a class="el" href="rte__mldev_8h.html#ada3eb6d23d36573262224389791cc2e1aa8c0fdc6179567aaec1be2e500a5ed74">RTE_ML_IO_TYPE_FP32</a>
, <a class="el" href="rte__mldev_8h.html#ada3eb6d23d36573262224389791cc2e1a2ead6a29d12cadd0848b21cbcb81551a">RTE_ML_IO_TYPE_BFLOAT16</a>
<br />
 }</td></tr>
<tr class="separator:ada3eb6d23d36573262224389791cc2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220d2fea4f950ca0718fe1125e9a845d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a220d2fea4f950ca0718fe1125e9a845d">rte_ml_io_layout</a> { <a class="el" href="rte__mldev_8h.html#a220d2fea4f950ca0718fe1125e9a845daeb7a6895f077f09a161eba6e3027bd11">RTE_ML_IO_LAYOUT_PACKED</a>
, <a class="el" href="rte__mldev_8h.html#a220d2fea4f950ca0718fe1125e9a845dad1d722648a90a02c6d9b228c544cea3b">RTE_ML_IO_LAYOUT_SPLIT</a>
 }</td></tr>
<tr class="separator:a220d2fea4f950ca0718fe1125e9a845d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a11e2b9990975e1627205d8425c429a3a"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a11e2b9990975e1627205d8425c429a3a">rte_ml_dev_init</a> (size_t dev_max)</td></tr>
<tr class="separator:a11e2b9990975e1627205d8425c429a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85de66fcaf277f5d8987eab8db7961c8"><td class="memItemLeft" align="right" valign="top">__rte_experimental uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a85de66fcaf277f5d8987eab8db7961c8">rte_ml_dev_count</a> (void)</td></tr>
<tr class="separator:a85de66fcaf277f5d8987eab8db7961c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a1c9358198bf3ee8292feedc70db16"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a69a1c9358198bf3ee8292feedc70db16">rte_ml_dev_is_valid_dev</a> (int16_t dev_id)</td></tr>
<tr class="separator:a69a1c9358198bf3ee8292feedc70db16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46dbf545c4e2961906c156a5213184a9"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a46dbf545c4e2961906c156a5213184a9">rte_ml_dev_socket_id</a> (int16_t dev_id)</td></tr>
<tr class="separator:a46dbf545c4e2961906c156a5213184a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69ce78f77bd27bc5314cf520816924b"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#ac69ce78f77bd27bc5314cf520816924b">rte_ml_dev_info_get</a> (int16_t dev_id, struct <a class="el" href="structrte__ml__dev__info.html">rte_ml_dev_info</a> *dev_info)</td></tr>
<tr class="separator:ac69ce78f77bd27bc5314cf520816924b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0e8b0fedb6f68490631f20c7a2a4a5"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#afa0e8b0fedb6f68490631f20c7a2a4a5">rte_ml_dev_configure</a> (int16_t dev_id, const struct <a class="el" href="structrte__ml__dev__config.html">rte_ml_dev_config</a> *config)</td></tr>
<tr class="separator:afa0e8b0fedb6f68490631f20c7a2a4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f9f72a153813850b7a7f7f9ffc8f93"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a87f9f72a153813850b7a7f7f9ffc8f93">rte_ml_dev_queue_pair_setup</a> (int16_t dev_id, uint16_t queue_pair_id, const struct <a class="el" href="structrte__ml__dev__qp__conf.html">rte_ml_dev_qp_conf</a> *qp_conf, int socket_id)</td></tr>
<tr class="separator:a87f9f72a153813850b7a7f7f9ffc8f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300227552cfd9f19af6b2948bdb13d3f"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a300227552cfd9f19af6b2948bdb13d3f">rte_ml_dev_start</a> (int16_t dev_id)</td></tr>
<tr class="separator:a300227552cfd9f19af6b2948bdb13d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4c0889725b924e1df1eaa8ed45410a"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a6b4c0889725b924e1df1eaa8ed45410a">rte_ml_dev_stop</a> (int16_t dev_id)</td></tr>
<tr class="separator:a6b4c0889725b924e1df1eaa8ed45410a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280f9feb8365a9512c2037764a9c4525"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a280f9feb8365a9512c2037764a9c4525">rte_ml_dev_close</a> (int16_t dev_id)</td></tr>
<tr class="separator:a280f9feb8365a9512c2037764a9c4525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f510ea04d9513923e1e769921b8e832"><td class="memItemLeft" align="right" valign="top">__rte_experimental uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a6f510ea04d9513923e1e769921b8e832">rte_ml_enqueue_burst</a> (int16_t dev_id, uint16_t qp_id, struct <a class="el" href="structrte__ml__op.html">rte_ml_op</a> **ops, uint16_t nb_ops)</td></tr>
<tr class="separator:a6f510ea04d9513923e1e769921b8e832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e6a98bd2e7a858c083f3b4860e7a63"><td class="memItemLeft" align="right" valign="top">__rte_experimental uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a98e6a98bd2e7a858c083f3b4860e7a63">rte_ml_dequeue_burst</a> (int16_t dev_id, uint16_t qp_id, struct <a class="el" href="structrte__ml__op.html">rte_ml_op</a> **ops, uint16_t nb_ops)</td></tr>
<tr class="separator:a98e6a98bd2e7a858c083f3b4860e7a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e537b79a3696ef99da017c49b25b34"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#ab6e537b79a3696ef99da017c49b25b34">rte_ml_op_error_get</a> (int16_t dev_id, struct <a class="el" href="structrte__ml__op.html">rte_ml_op</a> *op, struct <a class="el" href="structrte__ml__op__error.html">rte_ml_op_error</a> *error)</td></tr>
<tr class="separator:ab6e537b79a3696ef99da017c49b25b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474978a1c98a3cf2974ec1cde55b38bc"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a474978a1c98a3cf2974ec1cde55b38bc">rte_ml_dev_stats_get</a> (int16_t dev_id, struct <a class="el" href="structrte__ml__dev__stats.html">rte_ml_dev_stats</a> *stats)</td></tr>
<tr class="separator:a474978a1c98a3cf2974ec1cde55b38bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9689f3a6903851444f638c9745922f"><td class="memItemLeft" align="right" valign="top">__rte_experimental void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a5c9689f3a6903851444f638c9745922f">rte_ml_dev_stats_reset</a> (int16_t dev_id)</td></tr>
<tr class="separator:a5c9689f3a6903851444f638c9745922f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b5946b2f88c3124cddd630e768822b"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#af6b5946b2f88c3124cddd630e768822b">rte_ml_dev_xstats_names_get</a> (int16_t dev_id, enum <a class="el" href="rte__mldev_8h.html#aae36c341633f4c0c720575504b2110ee">rte_ml_dev_xstats_mode</a> mode, int32_t model_id, struct <a class="el" href="structrte__ml__dev__xstats__map.html">rte_ml_dev_xstats_map</a> *xstats_map, uint32_t size)</td></tr>
<tr class="separator:af6b5946b2f88c3124cddd630e768822b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa340b1c0200feff92dc447fed580c2c"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#aaa340b1c0200feff92dc447fed580c2c">rte_ml_dev_xstats_by_name_get</a> (int16_t dev_id, const char *name, uint16_t *stat_id, uint64_t *value)</td></tr>
<tr class="separator:aaa340b1c0200feff92dc447fed580c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0521c7a0d029f41b54112bbcee7380"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a7f0521c7a0d029f41b54112bbcee7380">rte_ml_dev_xstats_get</a> (int16_t dev_id, enum <a class="el" href="rte__mldev_8h.html#aae36c341633f4c0c720575504b2110ee">rte_ml_dev_xstats_mode</a> mode, int32_t model_id, const uint16_t stat_ids[], uint64_t values[], uint16_t nb_ids)</td></tr>
<tr class="separator:a7f0521c7a0d029f41b54112bbcee7380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7450759d8b32bfba498bf4e3547574ae"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a7450759d8b32bfba498bf4e3547574ae">rte_ml_dev_xstats_reset</a> (int16_t dev_id, enum <a class="el" href="rte__mldev_8h.html#aae36c341633f4c0c720575504b2110ee">rte_ml_dev_xstats_mode</a> mode, int32_t model_id, const uint16_t stat_ids[], uint16_t nb_ids)</td></tr>
<tr class="separator:a7450759d8b32bfba498bf4e3547574ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c88bea918fe54a9e1b3e9d1b051598"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a57c88bea918fe54a9e1b3e9d1b051598">rte_ml_dev_dump</a> (int16_t dev_id, FILE *fd)</td></tr>
<tr class="separator:a57c88bea918fe54a9e1b3e9d1b051598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba6da616e0a7967e7e08a59c027f4c5"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a9ba6da616e0a7967e7e08a59c027f4c5">rte_ml_dev_selftest</a> (int16_t dev_id)</td></tr>
<tr class="separator:a9ba6da616e0a7967e7e08a59c027f4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b0c83c7c2931671892857d18a1e1aa"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#af1b0c83c7c2931671892857d18a1e1aa">rte_ml_model_load</a> (int16_t dev_id, struct <a class="el" href="structrte__ml__model__params.html">rte_ml_model_params</a> *params, uint16_t *model_id)</td></tr>
<tr class="separator:af1b0c83c7c2931671892857d18a1e1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c70c265be475397365cb68ba700505"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a92c70c265be475397365cb68ba700505">rte_ml_model_unload</a> (int16_t dev_id, uint16_t model_id)</td></tr>
<tr class="separator:a92c70c265be475397365cb68ba700505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bed6a93adf96ecda165d8f95e3e643c"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a1bed6a93adf96ecda165d8f95e3e643c">rte_ml_model_start</a> (int16_t dev_id, uint16_t model_id)</td></tr>
<tr class="separator:a1bed6a93adf96ecda165d8f95e3e643c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa93ccdf124e704884fd6d1b9de2e9bf"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#aaa93ccdf124e704884fd6d1b9de2e9bf">rte_ml_model_stop</a> (int16_t dev_id, uint16_t model_id)</td></tr>
<tr class="separator:aaa93ccdf124e704884fd6d1b9de2e9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2133d8fbe7e18e7a49d69fc19c0fdd30"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a2133d8fbe7e18e7a49d69fc19c0fdd30">rte_ml_model_info_get</a> (int16_t dev_id, uint16_t model_id, struct <a class="el" href="structrte__ml__model__info.html">rte_ml_model_info</a> *model_info)</td></tr>
<tr class="separator:a2133d8fbe7e18e7a49d69fc19c0fdd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95a8728d7a0dc4889d0f3f03eaa3727"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#af95a8728d7a0dc4889d0f3f03eaa3727">rte_ml_model_params_update</a> (int16_t dev_id, uint16_t model_id, void *buffer)</td></tr>
<tr class="separator:af95a8728d7a0dc4889d0f3f03eaa3727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0869c89c9c75b91e34acfcca3d3b2c0f"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a0869c89c9c75b91e34acfcca3d3b2c0f">rte_ml_io_quantize</a> (int16_t dev_id, uint16_t model_id, struct <a class="el" href="structrte__ml__buff__seg.html">rte_ml_buff_seg</a> **dbuffer, struct <a class="el" href="structrte__ml__buff__seg.html">rte_ml_buff_seg</a> **qbuffer)</td></tr>
<tr class="separator:a0869c89c9c75b91e34acfcca3d3b2c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671d966f71f1015444ebb478284b5491"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a671d966f71f1015444ebb478284b5491">rte_ml_io_dequantize</a> (int16_t dev_id, uint16_t model_id, struct <a class="el" href="structrte__ml__buff__seg.html">rte_ml_buff_seg</a> **qbuffer, struct <a class="el" href="structrte__ml__buff__seg.html">rte_ml_buff_seg</a> **dbuffer)</td></tr>
<tr class="separator:a671d966f71f1015444ebb478284b5491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2e4c2c30493ad9ec4ad4d0b972143b"><td class="memItemLeft" align="right" valign="top">__rte_experimental struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a9e2e4c2c30493ad9ec4ad4d0b972143b">rte_ml_op_pool_create</a> (const char *name, unsigned int nb_elts, unsigned int cache_size, uint16_t user_size, int socket_id)</td></tr>
<tr class="separator:a9e2e4c2c30493ad9ec4ad4d0b972143b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38636028db91b0329bdd55f45107a4a8"><td class="memItemLeft" align="right" valign="top">__rte_experimental void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mldev_8h.html#a38636028db91b0329bdd55f45107a4a8">rte_ml_op_pool_free</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mempool)</td></tr>
<tr class="separator:a38636028db91b0329bdd55f45107a4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> All functions in this file may be changed or removed without prior notice.</dd></dl>
<p>ML (Machine Learning) device API.</p>
<p>The ML framework is built on the following model:</p>
<pre class="fragment">+-----------------+               rte_ml_[en|de]queue_burst()
|                 |                          |
|     Machine     o------+     +--------+    |
|     Learning    |      |     | queue  |    |    +------+
|     Inference   o------+-----o        |&lt;===o===&gt;|Core 0|
|     Engine      |      |     | pair 0 |         +------+
|                 o----+ |     +--------+
|                 |    | |
+-----------------+    | |     +--------+
         ^             | |     | queue  |         +------+
         |             | +-----o        |&lt;=======&gt;|Core 1|
         |             |       | pair 1 |         +------+
         |             |       +--------+
+--------+--------+    |
| +-------------+ |    |       +--------+
| |   Model 0   | |    |       | queue  |         +------+
| +-------------+ |    +-------o        |&lt;=======&gt;|Core N|
| +-------------+ |            | pair N |         +------+
| |   Model 1   | |            +--------+
| +-------------+ |
| +-------------+ |&lt;------&gt; rte_ml_model_load()
| |   Model ..  | |-------&gt; rte_ml_model_info_get()
| +-------------+ |&lt;------- rte_ml_model_start()
| +-------------+ |&lt;------- rte_ml_model_stop()
| |   Model N   | |&lt;------- rte_ml_model_params_update()
| +-------------+ |&lt;------- rte_ml_model_unload()
+-----------------+
</pre><p> ML Device: A hardware or software-based implementation of ML device API for running inferences using a pre-trained ML model.</p>
<p>ML Model: An ML model is an algorithm trained over a dataset. A model consists of procedure/algorithm and data/pattern required to make predictions on live data. Once the model is created and trained outside of the DPDK scope, the model can be loaded via <a class="el" href="rte__mldev_8h.html#af1b0c83c7c2931671892857d18a1e1aa">rte_ml_model_load()</a> and then start it using <a class="el" href="rte__mldev_8h.html#a1bed6a93adf96ecda165d8f95e3e643c">rte_ml_model_start()</a> API. The <a class="el" href="rte__mldev_8h.html#af95a8728d7a0dc4889d0f3f03eaa3727">rte_ml_model_params_update()</a> can be used to update the model parameters such as weight and bias without unloading the model using <a class="el" href="rte__mldev_8h.html#a92c70c265be475397365cb68ba700505">rte_ml_model_unload()</a>.</p>
<p>ML Inference: ML inference is the process of feeding data to the model via <a class="el" href="rte__mldev_8h.html#a6f510ea04d9513923e1e769921b8e832">rte_ml_enqueue_burst()</a> API and use <a class="el" href="rte__mldev_8h.html#a98e6a98bd2e7a858c083f3b4860e7a63">rte_ml_dequeue_burst()</a> API to get the calculated outputs/predictions from the started model.</p>
<p>In all functions of the ML device API, the ML device is designated by an integer &gt;= 0 named as device identifier <em>dev_id</em>.</p>
<p>The functions exported by the ML device API to setup a device designated by its device identifier must be invoked in the following order: </p><pre class="fragment"> - rte_ml_dev_configure()
 - rte_ml_dev_queue_pair_setup()
 - rte_ml_dev_start()
</pre><p> A model is required to run the inference operations with the user specified inputs. Application needs to invoke the ML model API in the following order before queueing inference jobs. </p><pre class="fragment"> - rte_ml_model_load()
 - rte_ml_model_start()
</pre><p> A model can be loaded on a device only after the device has been configured and can be started or stopped only after a device has been started.</p>
<p>The <a class="el" href="rte__mldev_8h.html#a2133d8fbe7e18e7a49d69fc19c0fdd30">rte_ml_model_info_get()</a> API is provided to retrieve the information related to the model. The information would include the shape and type of input and output required for the inference.</p>
<p>Data quantization and dequantization is one of the main aspects in ML domain. This involves conversion of input data from a higher precision to a lower precision data type and vice-versa for the output. APIs are provided to enable quantization through <a class="el" href="rte__mldev_8h.html#a0869c89c9c75b91e34acfcca3d3b2c0f">rte_ml_io_quantize()</a> and dequantization through <a class="el" href="rte__mldev_8h.html#a671d966f71f1015444ebb478284b5491">rte_ml_io_dequantize()</a>. These APIs have the capability to handle input and output buffers holding data for multiple batches.</p>
<p>Two utility APIs rte_ml_io_input_size_get() and rte_ml_io_output_size_get() can used to get the size of quantized and de-quantized multi-batch input and output buffers.</p>
<p>User can optionally update the model parameters with <a class="el" href="rte__mldev_8h.html#af95a8728d7a0dc4889d0f3f03eaa3727">rte_ml_model_params_update()</a> after invoking <a class="el" href="rte__mldev_8h.html#aaa93ccdf124e704884fd6d1b9de2e9bf">rte_ml_model_stop()</a> API on a given model ID.</p>
<p>The application can invoke, in any order, the functions exported by the ML API to enqueue inference jobs and dequeue inference response.</p>
<p>If the application wants to change the device configuration (i.e., call <a class="el" href="rte__mldev_8h.html#afa0e8b0fedb6f68490631f20c7a2a4a5">rte_ml_dev_configure()</a> or <a class="el" href="rte__mldev_8h.html#a87f9f72a153813850b7a7f7f9ffc8f93">rte_ml_dev_queue_pair_setup()</a>), then application must stop the device using <a class="el" href="rte__mldev_8h.html#a6b4c0889725b924e1df1eaa8ed45410a">rte_ml_dev_stop()</a> API. Likewise, if model parameters need to be updated then the application must call <a class="el" href="rte__mldev_8h.html#aaa93ccdf124e704884fd6d1b9de2e9bf">rte_ml_model_stop()</a> followed by <a class="el" href="rte__mldev_8h.html#af95a8728d7a0dc4889d0f3f03eaa3727">rte_ml_model_params_update()</a> API for the given model. The application does not need to call <a class="el" href="rte__mldev_8h.html#a6b4c0889725b924e1df1eaa8ed45410a">rte_ml_dev_stop()</a> API for any model re-configuration such as <a class="el" href="rte__mldev_8h.html#af95a8728d7a0dc4889d0f3f03eaa3727">rte_ml_model_params_update()</a>, <a class="el" href="rte__mldev_8h.html#a92c70c265be475397365cb68ba700505">rte_ml_model_unload()</a> etc.</p>
<p>Once the device is in the start state after invoking <a class="el" href="rte__mldev_8h.html#a300227552cfd9f19af6b2948bdb13d3f">rte_ml_dev_start()</a> API and the model is in start state after invoking <a class="el" href="rte__mldev_8h.html#a1bed6a93adf96ecda165d8f95e3e643c">rte_ml_model_start()</a> API, then the application can call <a class="el" href="rte__mldev_8h.html#a6f510ea04d9513923e1e769921b8e832">rte_ml_enqueue_burst()</a> and <a class="el" href="rte__mldev_8h.html#a98e6a98bd2e7a858c083f3b4860e7a63">rte_ml_dequeue_burst()</a> API on the destined device and model ID.</p>
<p>Finally, an application can close an ML device by invoking the <a class="el" href="rte__mldev_8h.html#a280f9feb8365a9512c2037764a9c4525">rte_ml_dev_close()</a> function.</p>
<p>Typical application utilisation of the ML API will follow the following programming flow.</p>
<ul>
<li><a class="el" href="rte__mldev_8h.html#afa0e8b0fedb6f68490631f20c7a2a4a5">rte_ml_dev_configure()</a></li>
<li><a class="el" href="rte__mldev_8h.html#a87f9f72a153813850b7a7f7f9ffc8f93">rte_ml_dev_queue_pair_setup()</a></li>
<li><a class="el" href="rte__mldev_8h.html#af1b0c83c7c2931671892857d18a1e1aa">rte_ml_model_load()</a></li>
<li><a class="el" href="rte__mldev_8h.html#a300227552cfd9f19af6b2948bdb13d3f">rte_ml_dev_start()</a></li>
<li><a class="el" href="rte__mldev_8h.html#a1bed6a93adf96ecda165d8f95e3e643c">rte_ml_model_start()</a></li>
<li><a class="el" href="rte__mldev_8h.html#a2133d8fbe7e18e7a49d69fc19c0fdd30">rte_ml_model_info_get()</a></li>
<li><a class="el" href="rte__mldev_8h.html#a6f510ea04d9513923e1e769921b8e832">rte_ml_enqueue_burst()</a></li>
<li><a class="el" href="rte__mldev_8h.html#a98e6a98bd2e7a858c083f3b4860e7a63">rte_ml_dequeue_burst()</a></li>
<li><a class="el" href="rte__mldev_8h.html#aaa93ccdf124e704884fd6d1b9de2e9bf">rte_ml_model_stop()</a></li>
<li><a class="el" href="rte__mldev_8h.html#a92c70c265be475397365cb68ba700505">rte_ml_model_unload()</a></li>
<li><a class="el" href="rte__mldev_8h.html#a6b4c0889725b924e1df1eaa8ed45410a">rte_ml_dev_stop()</a></li>
<li><a class="el" href="rte__mldev_8h.html#a280f9feb8365a9512c2037764a9c4525">rte_ml_dev_close()</a></li>
</ul>
<p>Regarding multi-threading, by default, all the functions of the ML Device API exported by a PMD are lock-free functions which assume to not be invoked in parallel on different logical cores on the same target object. For instance, the dequeue function of a poll mode driver cannot be invoked in parallel on two logical cores to operate on same queue pair. Of course, this function can be invoked in parallel by different logical core on different queue pair. It is the responsibility of the user application to enforce this rule. </p>

<p class="definition">Definition in file <a class="el" href="rte__mldev_8h_source.html">rte_mldev.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a42f8c080077682ecef6df0d0f28777d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f8c080077682ecef6df0d0f28777d0">&#9670;&nbsp;</a></span>RTE_ML_STR_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ML_STR_MAX&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum length of name string </p>

<p class="definition">Definition at line <a class="el" href="rte__mldev_8h_source.html#l00152">152</a> of file <a class="el" href="rte__mldev_8h_source.html">rte_mldev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ae21b2ce3d4fe4483d1e985fc2c85e640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21b2ce3d4fe4483d1e985fc2c85e640">&#9670;&nbsp;</a></span>rte_ml_dev_stop_flush_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void(* rte_ml_dev_stop_flush_t) (int16_t dev_id, uint16_t qp_id, struct <a class="el" href="structrte__ml__op.html">rte_ml_op</a> *op)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function called during <a class="el" href="rte__mldev_8h.html#a6b4c0889725b924e1df1eaa8ed45410a">rte_ml_dev_stop()</a>, invoked once per flushed ML op </p>

<p class="definition">Definition at line <a class="el" href="rte__mldev_8h_source.html#l00301">301</a> of file <a class="el" href="rte__mldev_8h_source.html">rte_mldev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac94a968deaaf216abdab941792c87477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94a968deaaf216abdab941792c87477">&#9670;&nbsp;</a></span>rte_ml_op_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__mldev_8h.html#ac94a968deaaf216abdab941792c87477">rte_ml_op_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Status of ML operation </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac94a968deaaf216abdab941792c87477a3d1c84d4ff60af8d81d777d898227c21"></a>RTE_ML_OP_STATUS_SUCCESS&#160;</td><td class="fielddoc"><p>Operation completed successfully </p>
</td></tr>
<tr><td class="fieldname"><a id="ac94a968deaaf216abdab941792c87477a97c0b08103be366d94a0a4dae63fc62e"></a>RTE_ML_OP_STATUS_NOT_PROCESSED&#160;</td><td class="fielddoc"><p>Operation has not yet been processed by the device. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac94a968deaaf216abdab941792c87477a05d8685c0bfff9450ec78c73e167a680"></a>RTE_ML_OP_STATUS_ERROR&#160;</td><td class="fielddoc"><p>Operation completed with error. Application can invoke <a class="el" href="rte__mldev_8h.html#ab6e537b79a3696ef99da017c49b25b34">rte_ml_op_error_get()</a> to get PMD specific error code if needed. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__mldev_8h_source.html#l00390">390</a> of file <a class="el" href="rte__mldev_8h_source.html">rte_mldev.h</a>.</p>

</div>
</div>
<a id="aae36c341633f4c0c720575504b2110ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae36c341633f4c0c720575504b2110ee">&#9670;&nbsp;</a></span>rte_ml_dev_xstats_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__mldev_8h.html#aae36c341633f4c0c720575504b2110ee">rte_ml_dev_xstats_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selects the component of the mldev to retrieve statistics from. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aae36c341633f4c0c720575504b2110eeaf95584b9dc9470283dce35d7c965e9c3"></a>RTE_ML_DEV_XSTATS_DEVICE&#160;</td><td class="fielddoc"><p>Device xstats </p>
</td></tr>
<tr><td class="fieldname"><a id="aae36c341633f4c0c720575504b2110eea146d80cd48d44def1fd79c1db2020027"></a>RTE_ML_DEV_XSTATS_MODEL&#160;</td><td class="fielddoc"><p>Model xstats </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__mldev_8h_source.html#l00618">618</a> of file <a class="el" href="rte__mldev_8h_source.html">rte_mldev.h</a>.</p>

</div>
</div>
<a id="ada3eb6d23d36573262224389791cc2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3eb6d23d36573262224389791cc2e1">&#9670;&nbsp;</a></span>rte_ml_io_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__mldev_8h.html#ada3eb6d23d36573262224389791cc2e1">rte_ml_io_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Input and output data types. ML models can operate on reduced precision datatypes to achieve better power efficiency, lower network latency and lower memory footprint. This enum is used to represent the lower precision integer and floating point types used by ML models. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ada3eb6d23d36573262224389791cc2e1ada836f2aa4be5da420ab843b4ed5aa7c"></a>RTE_ML_IO_TYPE_UNKNOWN&#160;</td><td class="fielddoc"><p>Invalid or unknown type </p>
</td></tr>
<tr><td class="fieldname"><a id="ada3eb6d23d36573262224389791cc2e1ab9a01c952ffc314ebfbf2b6a0be1f180"></a>RTE_ML_IO_TYPE_INT8&#160;</td><td class="fielddoc"><p>8-bit integer </p>
</td></tr>
<tr><td class="fieldname"><a id="ada3eb6d23d36573262224389791cc2e1a36583b48f1e20f3bb1531acd506daa8e"></a>RTE_ML_IO_TYPE_UINT8&#160;</td><td class="fielddoc"><p>8-bit unsigned integer </p>
</td></tr>
<tr><td class="fieldname"><a id="ada3eb6d23d36573262224389791cc2e1a93150ba94083d9b603ba474b07f2b985"></a>RTE_ML_IO_TYPE_INT16&#160;</td><td class="fielddoc"><p>16-bit integer </p>
</td></tr>
<tr><td class="fieldname"><a id="ada3eb6d23d36573262224389791cc2e1a39d87cecb6eb8a3814abdf9ed82c9a42"></a>RTE_ML_IO_TYPE_UINT16&#160;</td><td class="fielddoc"><p>16-bit unsigned integer </p>
</td></tr>
<tr><td class="fieldname"><a id="ada3eb6d23d36573262224389791cc2e1ad7db1a937acdf4d0fc585fd6bf995de6"></a>RTE_ML_IO_TYPE_INT32&#160;</td><td class="fielddoc"><p>32-bit integer </p>
</td></tr>
<tr><td class="fieldname"><a id="ada3eb6d23d36573262224389791cc2e1aa956c8da11b2e65add0e98fd44f130dc"></a>RTE_ML_IO_TYPE_UINT32&#160;</td><td class="fielddoc"><p>32-bit unsigned integer </p>
</td></tr>
<tr><td class="fieldname"><a id="ada3eb6d23d36573262224389791cc2e1a177df4f7f4c00e6c0a22f014f787266a"></a>RTE_ML_IO_TYPE_FP8&#160;</td><td class="fielddoc"><p>8-bit floating point number </p>
</td></tr>
<tr><td class="fieldname"><a id="ada3eb6d23d36573262224389791cc2e1aed26440921920e30d7f91c2d1d4f4620"></a>RTE_ML_IO_TYPE_FP16&#160;</td><td class="fielddoc"><p>IEEE 754 16-bit floating point number </p>
</td></tr>
<tr><td class="fieldname"><a id="ada3eb6d23d36573262224389791cc2e1aa8c0fdc6179567aaec1be2e500a5ed74"></a>RTE_ML_IO_TYPE_FP32&#160;</td><td class="fielddoc"><p>IEEE 754 32-bit floating point number </p>
</td></tr>
<tr><td class="fieldname"><a id="ada3eb6d23d36573262224389791cc2e1a2ead6a29d12cadd0848b21cbcb81551a"></a>RTE_ML_IO_TYPE_BFLOAT16&#160;</td><td class="fielddoc"><p>16-bit brain floating point number. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__mldev_8h_source.html#l00861">861</a> of file <a class="el" href="rte__mldev_8h_source.html">rte_mldev.h</a>.</p>

</div>
</div>
<a id="a220d2fea4f950ca0718fe1125e9a845d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220d2fea4f950ca0718fe1125e9a845d">&#9670;&nbsp;</a></span>rte_ml_io_layout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__mldev_8h.html#a220d2fea4f950ca0718fe1125e9a845d">rte_ml_io_layout</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ML I/O buffer layout </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a220d2fea4f950ca0718fe1125e9a845daeb7a6895f077f09a161eba6e3027bd11"></a>RTE_ML_IO_LAYOUT_PACKED&#160;</td><td class="fielddoc"><p>All inputs for the model should packed in a single buffer with no padding between individual inputs. The buffer is expected to be aligned to <a class="el" href="structrte__ml__dev__info.html#a8d60ea48e2fb28564bab20c9d24c653c">rte_ml_dev_info::align_size</a>.</p>
<p>When I/O segmentation is supported by the device, the packed data can be split into multiple segments. In this case, each segment is expected to be aligned to <a class="el" href="structrte__ml__dev__info.html#a8d60ea48e2fb28564bab20c9d24c653c">rte_ml_dev_info::align_size</a></p>
<p>Same applies to output.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__ml__dev__info.html#a1818013785af8a719b33999eaaf680d9">rte_ml_dev_info::max_segments</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a220d2fea4f950ca0718fe1125e9a845dad1d722648a90a02c6d9b228c544cea3b"></a>RTE_ML_IO_LAYOUT_SPLIT&#160;</td><td class="fielddoc"><p>Each input for the model should be stored as separate buffers and each input should be aligned to <a class="el" href="structrte__ml__dev__info.html#a8d60ea48e2fb28564bab20c9d24c653c">rte_ml_dev_info::align_size</a>.</p>
<p>When I/O segmentation is supported, each input can be split into multiple segments. In this case, each segment is expected to be aligned to <a class="el" href="structrte__ml__dev__info.html#a8d60ea48e2fb28564bab20c9d24c653c">rte_ml_dev_info::align_size</a></p>
<p>Same applies to output.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__ml__dev__info.html#a1818013785af8a719b33999eaaf680d9">rte_ml_dev_info::max_segments</a> </dd></dl>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__mldev_8h_source.html#l00887">887</a> of file <a class="el" href="rte__mldev_8h_source.html">rte_mldev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a11e2b9990975e1627205d8425c429a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e2b9990975e1627205d8425c429a3a">&#9670;&nbsp;</a></span>rte_ml_dev_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_dev_init </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dev_max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of devices if <a class="el" href="rte__mldev_8h.html#a11e2b9990975e1627205d8425c429a3a">rte_ml_dev_init()</a> is not called. Initialize the device array before probing devices. If not called, the first device probed would initialize the array to a size of RTE_MLDEV_DEFAULT_MAX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_max</td><td>Maximum number of devices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -rte_errno otherwise:<ul>
<li>ENOMEM if out of memory</li>
<li>EINVAL if 0 size</li>
<li>EBUSY if already initialized </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a85de66fcaf277f5d8987eab8db7961c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85de66fcaf277f5d8987eab8db7961c8">&#9670;&nbsp;</a></span>rte_ml_dev_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental uint16_t rte_ml_dev_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the total number of ML devices that have been successfully initialised.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The total number of usable ML devices. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a69a1c9358198bf3ee8292feedc70db16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a1c9358198bf3ee8292feedc70db16">&#9670;&nbsp;</a></span>rte_ml_dev_is_valid_dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_dev_is_valid_dev </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the device is in ready state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if device state is not in ready state.</li>
<li>1 if device state is ready state. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a46dbf545c4e2961906c156a5213184a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46dbf545c4e2961906c156a5213184a9">&#9670;&nbsp;</a></span>rte_ml_dev_socket_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_dev_socket_id </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the NUMA socket to which a device is connected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The NUMA socket id to which the device is connected</li>
<li>0 If the socket could not be determined.</li>
<li>-EINVAL: if the dev_id value is not valid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac69ce78f77bd27bc5314cf520816924b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69ce78f77bd27bc5314cf520816924b">&#9670;&nbsp;</a></span>rte_ml_dev_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_dev_info_get </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ml__dev__info.html">rte_ml_dev_info</a> *&#160;</td>
          <td class="paramname"><em>dev_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the information of the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">dev_info</td><td>A pointer to a structure of type <em><a class="el" href="structrte__ml__dev__info.html">rte_ml_dev_info</a></em> to be filled with the info of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, driver updates the information of the ML device</li>
<li>&lt; 0: Error code returned by the driver info get function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afa0e8b0fedb6f68490631f20c7a2a4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0e8b0fedb6f68490631f20c7a2a4a5">&#9670;&nbsp;</a></span>rte_ml_dev_configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_dev_configure </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__ml__dev__config.html">rte_ml_dev_config</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure an ML device.</p>
<p>This function must be invoked first before any other function in the API.</p>
<p>ML Device can be re-configured, when in a stopped state. Device cannot be re-configured after <a class="el" href="rte__mldev_8h.html#a280f9feb8365a9512c2037764a9c4525">rte_ml_dev_close()</a> is called.</p>
<p>The caller may use <a class="el" href="rte__mldev_8h.html#ac69ce78f77bd27bc5314cf520816924b">rte_ml_dev_info_get()</a> to get the capability of each resources available for this ML device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device to configure. </td></tr>
    <tr><td class="paramname">config</td><td>The ML device configuration structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, device configured.</li>
<li>&lt; 0: Error code returned by the driver configuration function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a87f9f72a153813850b7a7f7f9ffc8f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f9f72a153813850b7a7f7f9ffc8f93">&#9670;&nbsp;</a></span>rte_ml_dev_queue_pair_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_dev_queue_pair_setup </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_pair_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__ml__dev__qp__conf.html">rte_ml_dev_qp_conf</a> *&#160;</td>
          <td class="paramname"><em>qp_conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set up a queue pair for a device. This should only be called when the device is stopped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_pair_id</td><td>The index of the queue pairs to set up. The value must be in the range [0, nb_queue_pairs - 1] previously supplied to <a class="el" href="rte__mldev_8h.html#afa0e8b0fedb6f68490631f20c7a2a4a5">rte_ml_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">qp_conf</td><td>The pointer to the configuration data to be used for the queue pair. </td></tr>
    <tr><td class="paramname">socket_id</td><td>The <em>socket_id</em> argument is the socket identifier in case of NUMA. The value can be <em>SOCKET_ID_ANY</em> if there is no NUMA constraint for the memory allocated for the queue pair.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, queue pair correctly set up.</li>
<li>&lt; 0: Queue pair configuration failed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a300227552cfd9f19af6b2948bdb13d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300227552cfd9f19af6b2948bdb13d3f">&#9670;&nbsp;</a></span>rte_ml_dev_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_dev_start </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an ML device.</p>
<p>The device start step consists of setting the configured features and enabling the ML device to accept inference jobs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, device started.</li>
<li>&lt;0: Error code of the driver device start function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6b4c0889725b924e1df1eaa8ed45410a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4c0889725b924e1df1eaa8ed45410a">&#9670;&nbsp;</a></span>rte_ml_dev_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_dev_stop </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop an ML device. A stopped device cannot accept inference jobs. The device can be restarted with a call to <a class="el" href="rte__mldev_8h.html#a300227552cfd9f19af6b2948bdb13d3f">rte_ml_dev_start()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, device stopped.</li>
<li>&lt;0: Error code of the driver device stop function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a280f9feb8365a9512c2037764a9c4525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280f9feb8365a9512c2037764a9c4525">&#9670;&nbsp;</a></span>rte_ml_dev_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_dev_close </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close an ML device. The device cannot be restarted!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on successfully closing device.</li>
<li>&lt;0 on failure to close device. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6f510ea04d9513923e1e769921b8e832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f510ea04d9513923e1e769921b8e832">&#9670;&nbsp;</a></span>rte_ml_enqueue_burst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental uint16_t rte_ml_enqueue_burst </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>qp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ml__op.html">rte_ml_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enqueue a burst of ML inferences for processing on an ML device.</p>
<p>The <a class="el" href="rte__mldev_8h.html#a6f510ea04d9513923e1e769921b8e832">rte_ml_enqueue_burst()</a> function is invoked to place ML inference operations on the queue <em>qp_id</em> of the device designated by its <em>dev_id</em>.</p>
<p>The <em>nb_ops</em> parameter is the number of inferences to process which are supplied in the <em>ops</em> array of <em><a class="el" href="structrte__ml__op.html">rte_ml_op</a></em> structures.</p>
<p>The <a class="el" href="rte__mldev_8h.html#a6f510ea04d9513923e1e769921b8e832">rte_ml_enqueue_burst()</a> function returns the number of inferences it actually enqueued for processing. A return value equal to <em>nb_ops</em> means that all packets have been enqueued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">qp_id</td><td>The index of the queue pair which inferences are to be enqueued for processing. The value must be in the range [0, nb_queue_pairs - 1] previously supplied to <em>rte_ml_dev_configure</em>. </td></tr>
    <tr><td class="paramname">ops</td><td>The address of an array of <em>nb_ops</em> pointers to <em><a class="el" href="structrte__ml__op.html">rte_ml_op</a></em> structures which contain the ML inferences to be processed. </td></tr>
    <tr><td class="paramname">nb_ops</td><td>The number of operations to process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of inference operations actually enqueued to the ML device. The return value can be less than the value of the <em>nb_ops</em> parameter when the ML device queue is full or if invalid parameters are specified in a <em><a class="el" href="structrte__ml__op.html">rte_ml_op</a></em>. </dd></dl>

</div>
</div>
<a id="a98e6a98bd2e7a858c083f3b4860e7a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e6a98bd2e7a858c083f3b4860e7a63">&#9670;&nbsp;</a></span>rte_ml_dequeue_burst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental uint16_t rte_ml_dequeue_burst </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>qp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ml__op.html">rte_ml_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dequeue a burst of processed ML inferences operations from a queue on the ML device. The dequeued operations are stored in <em><a class="el" href="structrte__ml__op.html">rte_ml_op</a></em> structures whose pointers are supplied in the <em>ops</em> array.</p>
<p>The <a class="el" href="rte__mldev_8h.html#a98e6a98bd2e7a858c083f3b4860e7a63">rte_ml_dequeue_burst()</a> function returns the number of inferences actually dequeued, which is the number of <em><a class="el" href="structrte__ml__op.html">rte_ml_op</a></em> data structures effectively supplied into the <em>ops</em> array.</p>
<p>A return value equal to <em>nb_ops</em> indicates that the queue contained at least nb_ops* operations, and this is likely to signify that other processed operations remain in the devices output queue. Application implementing a "retrieve as many processed operations as possible" policy can check this specific case and keep invoking the <a class="el" href="rte__mldev_8h.html#a98e6a98bd2e7a858c083f3b4860e7a63">rte_ml_dequeue_burst()</a> function until a value less than <em>nb_ops</em> is returned.</p>
<p>The <a class="el" href="rte__mldev_8h.html#a98e6a98bd2e7a858c083f3b4860e7a63">rte_ml_dequeue_burst()</a> function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">qp_id</td><td>The index of the queue pair from which to retrieve processed packets. The value must be in the range [0, nb_queue_pairs - 1] previously supplied to <a class="el" href="rte__mldev_8h.html#afa0e8b0fedb6f68490631f20c7a2a4a5">rte_ml_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">ops</td><td>The address of an array of pointers to <em><a class="el" href="structrte__ml__op.html">rte_ml_op</a></em> structures that must be large enough to store <em>nb_ops</em> pointers in it. </td></tr>
    <tr><td class="paramname">nb_ops</td><td>The maximum number of inferences to dequeue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually dequeued, which is the number of pointers to <em><a class="el" href="structrte__ml__op.html">rte_ml_op</a></em> structures effectively supplied to the <em>ops</em> array. </dd></dl>

</div>
</div>
<a id="ab6e537b79a3696ef99da017c49b25b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e537b79a3696ef99da017c49b25b34">&#9670;&nbsp;</a></span>rte_ml_op_error_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_op_error_get </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ml__op.html">rte_ml_op</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ml__op__error.html">rte_ml_op_error</a> *&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get PMD specific error information for an ML op.</p>
<p>When an ML operation completed with RTE_ML_OP_STATUS_ERROR as status, This API allows to get PMD specific error details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_id</td><td>Device identifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>Handle of ML operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error</td><td>Address of structure <a class="el" href="structrte__ml__op__error.html">rte_ml_op_error</a> to be filled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Returns 0 on success</li>
<li>Returns negative value on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a474978a1c98a3cf2974ec1cde55b38bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474978a1c98a3cf2974ec1cde55b38bc">&#9670;&nbsp;</a></span>rte_ml_dev_stats_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_dev_stats_get </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ml__dev__stats.html">rte_ml_dev_stats</a> *&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the general I/O statistics of a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">stats</td><td>Pointer to structure to where statistics will be copied. On error, this location may or may not have been modified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>-EINVAL: If invalid parameter pointer is provided. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5c9689f3a6903851444f638c9745922f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9689f3a6903851444f638c9745922f">&#9670;&nbsp;</a></span>rte_ml_dev_stats_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental void rte_ml_dev_stats_reset </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the statistics of a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6b5946b2f88c3124cddd630e768822b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b5946b2f88c3124cddd630e768822b">&#9670;&nbsp;</a></span>rte_ml_dev_xstats_names_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_dev_xstats_names_get </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__mldev_8h.html#aae36c341633f4c0c720575504b2110ee">rte_ml_dev_xstats_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>model_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ml__dev__xstats__map.html">rte_ml_dev_xstats_map</a> *&#160;</td>
          <td class="paramname"><em>xstats_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve names of extended statistics of an ML device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">mode</td><td>Mode of statistics to retrieve. Choices include the device statistics and model statistics. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">model_id</td><td>Used to specify the model number in model mode, and is ignored in device mode. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xstats_map</td><td>Block of memory to insert names and ids into. Must be at least size in capacity. If set to NULL, function returns required capacity. The id values returned can be passed to <em>rte_ml_dev_xstats_get</em> to select statistics. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size</td><td>Capacity of xstats_names (number of xstats_map). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Positive value lower or equal to size: success. The return value is the number of entries filled in the stats table.</li>
<li>Positive value higher than size: error, the given statistics table is too small. The return value corresponds to the size that should be given to succeed. The entries in the table are not valid and shall not be used by the caller.</li>
<li>Negative value on error: -ENODEV for invalid <em>dev_id</em>. -EINVAL for invalid mode, model parameters. -ENOTSUP if the device doesn't support this function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aaa340b1c0200feff92dc447fed580c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa340b1c0200feff92dc447fed580c2c">&#9670;&nbsp;</a></span>rte_ml_dev_xstats_by_name_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_dev_xstats_by_name_get </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>stat_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the value of a single stat by requesting it by name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>Name of stat name to retrieve. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stat_id</td><td>If non-NULL, the numerical id of the stat will be returned, so that further requests for the stat can be got using rte_ml_dev_xstats_get, which will be faster as it doesn't need to scan a list of names for the stat. If the stat cannot be found, the id returned will be (unsigned)-1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Value of the stat to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Zero: No error.</li>
<li>Negative value: -EINVAL if stat not found, -ENOTSUP if not supported. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7f0521c7a0d029f41b54112bbcee7380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0521c7a0d029f41b54112bbcee7380">&#9670;&nbsp;</a></span>rte_ml_dev_xstats_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_dev_xstats_get </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__mldev_8h.html#aae36c341633f4c0c720575504b2110ee">rte_ml_dev_xstats_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>model_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>stat_ids</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>values</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve extended statistics of an ML device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">mode</td><td>Mode of statistics to retrieve. Choices include the device statistics and model statistics. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">model_id</td><td>Used to specify the model id in model mode, and is ignored in device mode. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">stat_ids</td><td>ID numbers of the stats to get. The ids can be got from the stat position in the stat list from <a class="el" href="rte__mldev_8h.html#af6b5946b2f88c3124cddd630e768822b">rte_ml_dev_xstats_names_get()</a>, or by using <a class="el" href="rte__mldev_8h.html#aaa340b1c0200feff92dc447fed580c2c">rte_ml_dev_xstats_by_name_get()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Values for each stats request by ID. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nb_ids</td><td>Number of stats requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Positive value: number of stat entries filled into the values array</li>
<li>Negative value on error: -ENODEV for invalid <em>dev_id</em>. -EINVAL for invalid mode, model id or stat id parameters. -ENOTSUP if the device doesn't support this function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7450759d8b32bfba498bf4e3547574ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7450759d8b32bfba498bf4e3547574ae">&#9670;&nbsp;</a></span>rte_ml_dev_xstats_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_dev_xstats_reset </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__mldev_8h.html#aae36c341633f4c0c720575504b2110ee">rte_ml_dev_xstats_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>model_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>stat_ids</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the values of the xstats of the selected component in the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">mode</td><td>Mode of the statistics to reset. Choose from device or model. </td></tr>
    <tr><td class="paramname">model_id</td><td>Model stats to reset. 0 and positive values select models, while -1 indicates all models. </td></tr>
    <tr><td class="paramname">stat_ids</td><td>Selects specific statistics to be reset. When NULL, all statistics selected by <em>mode</em> will be reset. If non-NULL, must point to array of at least <em>nb_ids</em> size. </td></tr>
    <tr><td class="paramname">nb_ids</td><td>The number of ids available from the <em>ids</em> array. Ignored when ids is NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Zero: successfully reset the statistics.</li>
<li>Negative value: -EINVAL invalid parameters, -ENOTSUP if not supported. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a57c88bea918fe54a9e1b3e9d1b051598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c88bea918fe54a9e1b3e9d1b051598">&#9670;&nbsp;</a></span>rte_ml_dev_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_dev_dump </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump internal information about <em>dev_id</em> to the FILE* provided in <em>fd</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">fd</td><td>A pointer to a file for output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: on success.</li>
<li>&lt;0: on failure. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9ba6da616e0a7967e7e08a59c027f4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba6da616e0a7967e7e08a59c027f4c5">&#9670;&nbsp;</a></span>rte_ml_dev_selftest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_dev_selftest </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trigger the ML device self test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Selftest successful.</li>
<li>-ENOTSUP: if the device doesn't support selftest.</li>
<li>other values &lt; 0 on failure. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af1b0c83c7c2931671892857d18a1e1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b0c83c7c2931671892857d18a1e1aa">&#9670;&nbsp;</a></span>rte_ml_model_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_model_load </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ml__model__params.html">rte_ml_model_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>model_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load an ML model to the device.</p>
<p>Load an ML model to the device with parameters requested in the structure <a class="el" href="structrte__ml__model__params.html">rte_ml_model_params</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Parameters for the model to be loaded. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">model_id</td><td>Identifier of the model loaded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, Model loaded.</li>
<li>&lt; 0: Failure, Error code of the model load driver function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a92c70c265be475397365cb68ba700505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c70c265be475397365cb68ba700505">&#9670;&nbsp;</a></span>rte_ml_model_unload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_model_unload </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>model_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unload an ML model from the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_id</td><td>Identifier of the model to be unloaded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, Model unloaded.</li>
<li>&lt; 0: Failure, Error code of the model unload driver function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1bed6a93adf96ecda165d8f95e3e643c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bed6a93adf96ecda165d8f95e3e643c">&#9670;&nbsp;</a></span>rte_ml_model_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_model_start </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>model_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an ML model for the given device ID.</p>
<p>Start an ML model to accept inference requests.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_id</td><td>Identifier of the model to be started.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, Model loaded.</li>
<li>&lt; 0: Failure, Error code of the model start driver function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aaa93ccdf124e704884fd6d1b9de2e9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa93ccdf124e704884fd6d1b9de2e9bf">&#9670;&nbsp;</a></span>rte_ml_model_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_model_stop </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>model_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop an ML model for the given device ID.</p>
<p>Model stop would disable the ML model to be used for inference jobs. All inference jobs must have been completed before model stop is attempted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_id</td><td>Identifier of the model to be stopped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, Model unloaded.</li>
<li>&lt; 0: Failure, Error code of the model stop driver function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2133d8fbe7e18e7a49d69fc19c0fdd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2133d8fbe7e18e7a49d69fc19c0fdd30">&#9670;&nbsp;</a></span>rte_ml_model_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_model_info_get </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>model_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ml__model__info.html">rte_ml_model_info</a> *&#160;</td>
          <td class="paramname"><em>model_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get ML model information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_id</td><td>Identifier for the model created </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">model_info</td><td>Pointer to a model info structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Returns 0 on success</li>
<li>Returns negative value on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af95a8728d7a0dc4889d0f3f03eaa3727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95a8728d7a0dc4889d0f3f03eaa3727">&#9670;&nbsp;</a></span>rte_ml_model_params_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_model_params_update </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>model_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the model parameters without unloading model.</p>
<p>Update model parameters such as weights and bias without unloading the model. <a class="el" href="rte__mldev_8h.html#aaa93ccdf124e704884fd6d1b9de2e9bf">rte_ml_model_stop()</a> must be called before invoking this API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_id</td><td>Identifier for the model created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the model weights and bias buffer. Size of the buffer is equal to wb_size returned in <em><a class="el" href="structrte__ml__model__info.html">rte_ml_model_info</a></em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Returns 0 on success</li>
<li>Returns negative value on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0869c89c9c75b91e34acfcca3d3b2c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0869c89c9c75b91e34acfcca3d3b2c0f">&#9670;&nbsp;</a></span>rte_ml_io_quantize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_io_quantize </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>model_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ml__buff__seg.html">rte_ml_buff_seg</a> **&#160;</td>
          <td class="paramname"><em>dbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ml__buff__seg.html">rte_ml_buff_seg</a> **&#160;</td>
          <td class="paramname"><em>qbuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Quantize input data.</p>
<p>Quantization converts data from a higher precision types to a lower precision types to improve the throughput and efficiency of the model execution with minimal loss of accuracy. Types of dequantized data and quantized data are specified by the model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_id</td><td>Identifier for the model </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dbuffer</td><td>Address of dequantized input data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qbuffer</td><td>Address of quantized input data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Returns 0 on success</li>
<li>Returns negative value on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a671d966f71f1015444ebb478284b5491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671d966f71f1015444ebb478284b5491">&#9670;&nbsp;</a></span>rte_ml_io_dequantize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_ml_io_dequantize </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>model_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ml__buff__seg.html">rte_ml_buff_seg</a> **&#160;</td>
          <td class="paramname"><em>qbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ml__buff__seg.html">rte_ml_buff_seg</a> **&#160;</td>
          <td class="paramname"><em>dbuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dequantize output data.</p>
<p>Dequantization converts data from a lower precision type to a higher precision type. Types of quantized data and dequantized are specified by the model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_id</td><td>Identifier for the model </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qbuffer</td><td>Address of quantized output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dbuffer</td><td>Address of dequantized output data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Returns 0 on success</li>
<li>Returns negative value on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9e2e4c2c30493ad9ec4ad4d0b972143b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2e4c2c30493ad9ec4ad4d0b972143b">&#9670;&nbsp;</a></span>rte_ml_op_pool_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental struct <a class="el" href="structrte__mempool.html">rte_mempool</a>* rte_ml_op_pool_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nb_elts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cache_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>user_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an ML operation pool</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>ML operations pool name </td></tr>
    <tr><td class="paramname">nb_elts</td><td>Number of elements in pool </td></tr>
    <tr><td class="paramname">cache_size</td><td>Number of elements to cache on lcore, see <em>rte_mempool_create</em> for further details about cache size </td></tr>
    <tr><td class="paramname">user_size</td><td>Size of private data to allocate for user with each operation </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket to identifier allocate memory on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success pointer to mempool</li>
<li>On failure NULL </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a38636028db91b0329bdd55f45107a4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38636028db91b0329bdd55f45107a4a8">&#9670;&nbsp;</a></span>rte_ml_op_pool_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental void rte_ml_op_pool_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mempool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free an ML operation pool</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mempool</td><td>A pointer to the mempool structure. If NULL then, the function does nothing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
