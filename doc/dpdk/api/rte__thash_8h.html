<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/hash/rte_thash.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">23.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_eb138416be9f50ee0ac981c1ab1f5f6c.html">hash</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_thash.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__byteorder_8h_source.html">rte_byteorder.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__ip_8h_source.html">rte_ip.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__common_8h_source.html">rte_common.h</a>&gt;</code><br />
<code>#include &lt;rte_thash_gfni.h&gt;</code><br />
</div>
<p><a href="rte__thash_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__ipv4__tuple.html">rte_ipv4_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__ipv6__tuple.html">rte_ipv6_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab3bc792319dae9ae1dd65f70a1715101"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#ab3bc792319dae9ae1dd65f70a1715101">RTE_THASH_V4_L3_LEN</a></td></tr>
<tr class="separator:ab3bc792319dae9ae1dd65f70a1715101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc485fd380d5495b4ebf513b8a6540b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#a4bc485fd380d5495b4ebf513b8a6540b">RTE_THASH_V4_L4_LEN</a>&#160;&#160;&#160;((sizeof(struct <a class="el" href="structrte__ipv4__tuple.html">rte_ipv4_tuple</a>)) / 4)</td></tr>
<tr class="separator:a4bc485fd380d5495b4ebf513b8a6540b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba04c6149e45e9f06e314faac237633"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#a9ba04c6149e45e9f06e314faac237633">RTE_THASH_V6_L3_LEN</a></td></tr>
<tr class="separator:a9ba04c6149e45e9f06e314faac237633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e1546c072526b2c303b681aaafa0e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#ae4e1546c072526b2c303b681aaafa0e9">RTE_THASH_V6_L4_LEN</a>&#160;&#160;&#160;((sizeof(struct <a class="el" href="structrte__ipv6__tuple.html">rte_ipv6_tuple</a>)) / 4)</td></tr>
<tr class="separator:ae4e1546c072526b2c303b681aaafa0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f28793aef62481acdbfc32a08becba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#a36f28793aef62481acdbfc32a08becba">RTE_THASH_IGNORE_PERIOD_OVERFLOW</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="separator:a36f28793aef62481acdbfc32a08becba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f9bbaf5fc1d4aee3fabe87a23e5390"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#a40f9bbaf5fc1d4aee3fabe87a23e5390">RTE_THASH_MINIMAL_SEQ</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="separator:a40f9bbaf5fc1d4aee3fabe87a23e5390"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adcbf8828620e24717d417d3cfae8aa0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#adcbf8828620e24717d417d3cfae8aa0a">rte_thash_check_tuple_t</a>) (void *userdata, uint8_t *tuple)</td></tr>
<tr class="separator:adcbf8828620e24717d417d3cfae8aa0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a456567aa7b1a7cd2b5a2f26a064b1b77"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#a456567aa7b1a7cd2b5a2f26a064b1b77">rte_convert_rss_key</a> (const uint32_t *orig, uint32_t *targ, int len)</td></tr>
<tr class="separator:a456567aa7b1a7cd2b5a2f26a064b1b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ec1ef43be6fe4c48e9827cf32f2158"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#af3ec1ef43be6fe4c48e9827cf32f2158">rte_thash_load_v6_addrs</a> (const struct <a class="el" href="structrte__ipv6__hdr.html">rte_ipv6_hdr</a> *orig, union rte_thash_tuple *targ)</td></tr>
<tr class="separator:af3ec1ef43be6fe4c48e9827cf32f2158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afee34617158876c8946d7652450d35"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#a0afee34617158876c8946d7652450d35">rte_softrss</a> (uint32_t *input_tuple, uint32_t input_len, const uint8_t *rss_key)</td></tr>
<tr class="separator:a0afee34617158876c8946d7652450d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a9d49d177be1bf3ea42e0825b310bb"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#a00a9d49d177be1bf3ea42e0825b310bb">rte_softrss_be</a> (uint32_t *input_tuple, uint32_t input_len, const uint8_t *rss_key)</td></tr>
<tr class="separator:a00a9d49d177be1bf3ea42e0825b310bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd724caf8d1c428ab9f52a358659c38d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#abd724caf8d1c428ab9f52a358659c38d">rte_thash_gfni_supported</a> (void)</td></tr>
<tr class="separator:abd724caf8d1c428ab9f52a358659c38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7caa53d872a8a840d3003af57063f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#a3b7caa53d872a8a840d3003af57063f9">rte_thash_complete_matrix</a> (uint64_t *matrixes, const uint8_t *rss_key, int size)</td></tr>
<tr class="separator:a3b7caa53d872a8a840d3003af57063f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171c3bf4492e43c9e5bab99f904905aa"><td class="memItemLeft" align="right" valign="top">struct rte_thash_ctx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#a171c3bf4492e43c9e5bab99f904905aa">rte_thash_init_ctx</a> (const char *name, uint32_t key_len, uint32_t reta_sz, uint8_t *key, uint32_t flags)</td></tr>
<tr class="separator:a171c3bf4492e43c9e5bab99f904905aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bdd9b1633203dd57f1a4a68bfb3f6c"><td class="memItemLeft" align="right" valign="top">struct rte_thash_ctx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#a70bdd9b1633203dd57f1a4a68bfb3f6c">rte_thash_find_existing</a> (const char *name)</td></tr>
<tr class="separator:a70bdd9b1633203dd57f1a4a68bfb3f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cc40d008a77f68cedff418ac6416a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#af6cc40d008a77f68cedff418ac6416a3">rte_thash_free_ctx</a> (struct rte_thash_ctx *ctx)</td></tr>
<tr class="separator:af6cc40d008a77f68cedff418ac6416a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d362d53a412c45c30501ca655c51c35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#a8d362d53a412c45c30501ca655c51c35">rte_thash_add_helper</a> (struct rte_thash_ctx *ctx, const char *name, uint32_t len, uint32_t offset)</td></tr>
<tr class="separator:a8d362d53a412c45c30501ca655c51c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3cdfe8c62f0c15a0718fbb9fe4f87f"><td class="memItemLeft" align="right" valign="top">struct rte_thash_subtuple_helper *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#abc3cdfe8c62f0c15a0718fbb9fe4f87f">rte_thash_get_helper</a> (struct rte_thash_ctx *ctx, const char *name)</td></tr>
<tr class="separator:abc3cdfe8c62f0c15a0718fbb9fe4f87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c2dd8decbe9f0f933bf6ba52a25170"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#a01c2dd8decbe9f0f933bf6ba52a25170">rte_thash_get_complement</a> (struct rte_thash_subtuple_helper *h, uint32_t hash, uint32_t desired_hash)</td></tr>
<tr class="separator:a01c2dd8decbe9f0f933bf6ba52a25170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727eb1ce0275c1724edc8e55e0850971"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#a727eb1ce0275c1724edc8e55e0850971">rte_thash_get_key</a> (struct rte_thash_ctx *ctx)</td></tr>
<tr class="separator:a727eb1ce0275c1724edc8e55e0850971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d8909d878926b69d4c569c722e45fb"><td class="memItemLeft" align="right" valign="top">const uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#a68d8909d878926b69d4c569c722e45fb">rte_thash_get_gfni_matrices</a> (struct rte_thash_ctx *ctx)</td></tr>
<tr class="separator:a68d8909d878926b69d4c569c722e45fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dba2580e19e09f05b7ea0722fd8d462"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__thash_8h.html#a8dba2580e19e09f05b7ea0722fd8d462">rte_thash_adjust_tuple</a> (struct rte_thash_ctx *ctx, struct rte_thash_subtuple_helper *h, uint8_t *tuple, unsigned int tuple_len, uint32_t desired_value, unsigned int attempts, <a class="el" href="rte__thash_8h.html#adcbf8828620e24717d417d3cfae8aa0a">rte_thash_check_tuple_t</a> fn, void *userdata)</td></tr>
<tr class="separator:a8dba2580e19e09f05b7ea0722fd8d462"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Software implementation of the Toeplitz hash function used by RSS. Can be used either for packet distribution on single queue NIC or for simulating of RSS computation on specific NIC (for example after GRE header decapsulating) </p>

<p class="definition">Definition in file <a class="el" href="rte__thash_8h_source.html">rte_thash.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ab3bc792319dae9ae1dd65f70a1715101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3bc792319dae9ae1dd65f70a1715101">&#9670;&nbsp;</a></span>RTE_THASH_V4_L3_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_THASH_V4_L3_LEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">            ((<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structrte__ipv4__tuple.html">rte_ipv4_tuple</a>) -   \</div>
<div class="line">            sizeof(((struct <a class="code" href="structrte__ipv4__tuple.html">rte_ipv4_tuple</a> *)0)-&gt;sctp_tag)) / 4)</div>
<div class="ttc" id="astructrte__ipv4__tuple_html"><div class="ttname"><a href="structrte__ipv4__tuple.html">rte_ipv4_tuple</a></div><div class="ttdef"><b>Definition:</b> <a href="rte__thash_8h_source.html#l00073">rte_thash.h:73</a></div></div>
</div><!-- fragment --><p>length in dwords of input tuple to calculate hash of ipv4 header only </p>

<p class="definition">Definition at line <a class="el" href="rte__thash_8h_source.html#l00045">45</a> of file <a class="el" href="rte__thash_8h_source.html">rte_thash.h</a>.</p>

</div>
</div>
<a id="a4bc485fd380d5495b4ebf513b8a6540b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc485fd380d5495b4ebf513b8a6540b">&#9670;&nbsp;</a></span>RTE_THASH_V4_L4_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_THASH_V4_L4_LEN&#160;&#160;&#160;((sizeof(struct <a class="el" href="structrte__ipv4__tuple.html">rte_ipv4_tuple</a>)) / 4)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>length in dwords of input tuple to calculate hash of ipv4 header + transport header </p>

<p class="definition">Definition at line <a class="el" href="rte__thash_8h_source.html#l00053">53</a> of file <a class="el" href="rte__thash_8h_source.html">rte_thash.h</a>.</p>

</div>
</div>
<a id="a9ba04c6149e45e9f06e314faac237633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba04c6149e45e9f06e314faac237633">&#9670;&nbsp;</a></span>RTE_THASH_V6_L3_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_THASH_V6_L3_LEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">            ((<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structrte__ipv6__tuple.html">rte_ipv6_tuple</a>) -       \</div>
<div class="line">            sizeof(((struct <a class="code" href="structrte__ipv6__tuple.html">rte_ipv6_tuple</a> *)0)-&gt;sctp_tag)) / 4)</div>
<div class="ttc" id="astructrte__ipv6__tuple_html"><div class="ttname"><a href="structrte__ipv6__tuple.html">rte_ipv6_tuple</a></div><div class="ttdef"><b>Definition:</b> <a href="rte__thash_8h_source.html#l00090">rte_thash.h:90</a></div></div>
</div><!-- fragment --><p>length in dwords of input tuple to calculate hash of ipv6 header only </p>

<p class="definition">Definition at line <a class="el" href="rte__thash_8h_source.html#l00059">59</a> of file <a class="el" href="rte__thash_8h_source.html">rte_thash.h</a>.</p>

</div>
</div>
<a id="ae4e1546c072526b2c303b681aaafa0e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e1546c072526b2c303b681aaafa0e9">&#9670;&nbsp;</a></span>RTE_THASH_V6_L4_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_THASH_V6_L4_LEN&#160;&#160;&#160;((sizeof(struct <a class="el" href="structrte__ipv6__tuple.html">rte_ipv6_tuple</a>)) / 4)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>length in dwords of input tuple to calculate hash of ipv6 header + transport header </p>

<p class="definition">Definition at line <a class="el" href="rte__thash_8h_source.html#l00067">67</a> of file <a class="el" href="rte__thash_8h_source.html">rte_thash.h</a>.</p>

</div>
</div>
<a id="a36f28793aef62481acdbfc32a08becba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f28793aef62481acdbfc32a08becba">&#9670;&nbsp;</a></span>RTE_THASH_IGNORE_PERIOD_OVERFLOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_THASH_IGNORE_PERIOD_OVERFLOW&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LFSR will ignore if generated m-sequence has more than 2^n -1 bits, where n is the logarithm of the RSS ReTa size. </p>

<p class="definition">Definition at line <a class="el" href="rte__thash_8h_source.html#l00256">256</a> of file <a class="el" href="rte__thash_8h_source.html">rte_thash.h</a>.</p>

</div>
</div>
<a id="a40f9bbaf5fc1d4aee3fabe87a23e5390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f9bbaf5fc1d4aee3fabe87a23e5390">&#9670;&nbsp;</a></span>RTE_THASH_MINIMAL_SEQ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_THASH_MINIMAL_SEQ&#160;&#160;&#160;0x2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate minimal required bit (equal to ReTa LSB) sequence into the hash_key </p>

<p class="definition">Definition at line <a class="el" href="rte__thash_8h_source.html#l00261">261</a> of file <a class="el" href="rte__thash_8h_source.html">rte_thash.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="adcbf8828620e24717d417d3cfae8aa0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbf8828620e24717d417d3cfae8aa0a">&#9670;&nbsp;</a></span>rte_thash_check_tuple_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> int(* rte_thash_check_tuple_t) (void *userdata, uint8_t *tuple)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function prototype for the rte_thash_adjust_tuple to check if adjusted tuple could be used. Generally it is some kind of lookup function to check if adjusted tuple is already in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userdata</td><td>Pointer to the userdata. It could be a pointer to the table with used tuples to search. </td></tr>
    <tr><td class="paramname">tuple</td><td>Pointer to the tuple to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success 0 otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__thash_8h_source.html#l00415">415</a> of file <a class="el" href="rte__thash_8h_source.html">rte_thash.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a456567aa7b1a7cd2b5a2f26a064b1b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456567aa7b1a7cd2b5a2f26a064b1b77">&#9670;&nbsp;</a></span>rte_convert_rss_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_convert_rss_key </td>
          <td>(</td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>targ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepare special converted key to use with <a class="el" href="rte__thash_8h.html#a00a9d49d177be1bf3ea42e0825b310bb">rte_softrss_be()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig</td><td>pointer to original RSS key </td></tr>
    <tr><td class="paramname">targ</td><td>pointer to target RSS key </td></tr>
    <tr><td class="paramname">len</td><td>RSS key length </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__thash_8h_source.html#l00121">121</a> of file <a class="el" href="rte__thash_8h_source.html">rte_thash.h</a>.</p>

</div>
</div>
<a id="af3ec1ef43be6fe4c48e9827cf32f2158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ec1ef43be6fe4c48e9827cf32f2158">&#9670;&nbsp;</a></span>rte_thash_load_v6_addrs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_thash_load_v6_addrs </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__ipv6__hdr.html">rte_ipv6_hdr</a> *&#160;</td>
          <td class="paramname"><em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union rte_thash_tuple *&#160;</td>
          <td class="paramname"><em>targ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepare and load IPv6 addresses (src and dst) into target tuple </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig</td><td>Pointer to ipv6 header of the original packet </td></tr>
    <tr><td class="paramname">targ</td><td>Pointer to <a class="el" href="structrte__ipv6__tuple.html">rte_ipv6_tuple</a> structure </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__thash_8h_source.html#l00138">138</a> of file <a class="el" href="rte__thash_8h_source.html">rte_thash.h</a>.</p>

</div>
</div>
<a id="a0afee34617158876c8946d7652450d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0afee34617158876c8946d7652450d35">&#9670;&nbsp;</a></span>rte_softrss()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t rte_softrss </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>input_tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>input_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>rss_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generic implementation. Can be used with original rss_key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_tuple</td><td>Pointer to input tuple </td></tr>
    <tr><td class="paramname">input_len</td><td>Length of input_tuple in 4-bytes chunks </td></tr>
    <tr><td class="paramname">rss_key</td><td>Pointer to RSS hash key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated hash value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__thash_8h_source.html#l00176">176</a> of file <a class="el" href="rte__thash_8h_source.html">rte_thash.h</a>.</p>

</div>
</div>
<a id="a00a9d49d177be1bf3ea42e0825b310bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a9d49d177be1bf3ea42e0825b310bb">&#9670;&nbsp;</a></span>rte_softrss_be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t rte_softrss_be </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>input_tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>input_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>rss_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Optimized implementation. If you want the calculated hash value matches NIC RSS value you have to use special converted key with <a class="el" href="rte__thash_8h.html#a456567aa7b1a7cd2b5a2f26a064b1b77">rte_convert_rss_key()</a> fn. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_tuple</td><td>Pointer to input tuple </td></tr>
    <tr><td class="paramname">input_len</td><td>Length of input_tuple in 4-bytes chunks </td></tr>
    <tr><td class="paramname">*rss_key</td><td>Pointer to RSS hash key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated hash value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__thash_8h_source.html#l00206">206</a> of file <a class="el" href="rte__thash_8h_source.html">rte_thash.h</a>.</p>

</div>
</div>
<a id="abd724caf8d1c428ab9f52a358659c38d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd724caf8d1c428ab9f52a358659c38d">&#9670;&nbsp;</a></span>rte_thash_gfni_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_thash_gfni_supported </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates if GFNI implementations of the Toeplitz hash are supported.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if GFNI is supported 0 otherwise </dd></dl>

</div>
</div>
<a id="a3b7caa53d872a8a840d3003af57063f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7caa53d872a8a840d3003af57063f9">&#9670;&nbsp;</a></span>rte_thash_complete_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_thash_complete_matrix </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>matrixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>rss_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts Toeplitz hash key (RSS key) into matrixes required for GFNI implementation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrixes</td><td>pointer to the memory where matrices will be written. Note: the size of this memory must be equal to size * 8 </td></tr>
    <tr><td class="paramname">rss_key</td><td>pointer to the Toeplitz hash key </td></tr>
    <tr><td class="paramname">size</td><td>Size of the rss_key in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a171c3bf4492e43c9e5bab99f904905aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171c3bf4492e43c9e5bab99f904905aa">&#9670;&nbsp;</a></span>rte_thash_init_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rte_thash_ctx* rte_thash_init_ctx </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>key_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reta_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new thash context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Context name </td></tr>
    <tr><td class="paramname">key_len</td><td>Length of the toeplitz hash key </td></tr>
    <tr><td class="paramname">reta_sz</td><td>Logarithm of the NIC's Redirection Table (ReTa) size, i.e. number of the LSBs if the hash used to determine the reta entry. </td></tr>
    <tr><td class="paramname">key</td><td>Pointer to the key used to init an internal key state. Could be NULL, in this case internal key will be inited with random. </td></tr>
    <tr><td class="paramname">flags</td><td>Supported flags are: RTE_THASH_IGNORE_PERIOD_OVERFLOW RTE_THASH_MINIMAL_SEQ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the created context on success NULL otherwise </dd></dl>

</div>
</div>
<a id="a70bdd9b1633203dd57f1a4a68bfb3f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70bdd9b1633203dd57f1a4a68bfb3f6c">&#9670;&nbsp;</a></span>rte_thash_find_existing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rte_thash_ctx* rte_thash_find_existing </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find an existing thash context and return a pointer to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the thash context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the thash context or NULL if it was not found with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>ENOENT - required entry not available to return. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af6cc40d008a77f68cedff418ac6416a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6cc40d008a77f68cedff418ac6416a3">&#9670;&nbsp;</a></span>rte_thash_free_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_thash_free_ctx </td>
          <td>(</td>
          <td class="paramtype">struct rte_thash_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a thash context object</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Thash context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d362d53a412c45c30501ca655c51c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d362d53a412c45c30501ca655c51c35">&#9670;&nbsp;</a></span>rte_thash_add_helper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_thash_add_helper </td>
          <td>(</td>
          <td class="paramtype">struct rte_thash_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a special properties to the toeplitz hash key inside a thash context. Creates an internal helper struct which has a complementary table to calculate toeplitz hash collisions. This function is not multi-thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Thash context </td></tr>
    <tr><td class="paramname">name</td><td>Name of the helper </td></tr>
    <tr><td class="paramname">len</td><td>Length in bits of the target subtuple Must be no shorter than reta_sz passed on <a class="el" href="rte__thash_8h.html#a171c3bf4492e43c9e5bab99f904905aa">rte_thash_init_ctx()</a>. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in bits of the subtuple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success negative on error </dd></dl>

</div>
</div>
<a id="abc3cdfe8c62f0c15a0718fbb9fe4f87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3cdfe8c62f0c15a0718fbb9fe4f87f">&#9670;&nbsp;</a></span>rte_thash_get_helper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rte_thash_subtuple_helper* rte_thash_get_helper </td>
          <td>(</td>
          <td class="paramtype">struct rte_thash_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a helper in the context by the given name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Thash context </td></tr>
    <tr><td class="paramname">name</td><td>Name of the helper </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the thash helper or NULL if it was not found. </dd></dl>

</div>
</div>
<a id="a01c2dd8decbe9f0f933bf6ba52a25170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c2dd8decbe9f0f933bf6ba52a25170">&#9670;&nbsp;</a></span>rte_thash_get_complement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rte_thash_get_complement </td>
          <td>(</td>
          <td class="paramtype">struct rte_thash_subtuple_helper *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>desired_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a complementary value for the subtuple to produce a partial toeplitz hash collision. It must be XOR'ed with the subtuple to produce the hash value with the desired hash LSB's This function is multi-thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Pointer to the helper struct </td></tr>
    <tr><td class="paramname">hash</td><td>Toeplitz hash value calculated for the given tuple </td></tr>
    <tr><td class="paramname">desired_hash</td><td>Desired hash value to find a collision for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A complementary value which must be xored with the corresponding subtuple </dd></dl>

</div>
</div>
<a id="a727eb1ce0275c1724edc8e55e0850971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727eb1ce0275c1724edc8e55e0850971">&#9670;&nbsp;</a></span>rte_thash_get_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* rte_thash_get_key </td>
          <td>(</td>
          <td class="paramtype">struct rte_thash_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to the toeplitz hash contained in the context. It changes after each addition of a helper. It should be installed to the NIC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Thash context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the toeplitz hash key </dd></dl>

</div>
</div>
<a id="a68d8909d878926b69d4c569c722e45fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d8909d878926b69d4c569c722e45fb">&#9670;&nbsp;</a></span>rte_thash_get_gfni_matrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint64_t* rte_thash_get_gfni_matrices </td>
          <td>(</td>
          <td class="paramtype">struct rte_thash_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to the toeplitz hash matrices contained in the context. These matrices could be used with fast toeplitz hash implementation if CPU supports GFNI. Matrices changes after each addition of a helper.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Thash context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the toeplitz hash key matrices on success NULL if GFNI is not supported. </dd></dl>

</div>
</div>
<a id="a8dba2580e19e09f05b7ea0722fd8d462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dba2580e19e09f05b7ea0722fd8d462">&#9670;&nbsp;</a></span>rte_thash_adjust_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_thash_adjust_tuple </td>
          <td>(</td>
          <td class="paramtype">struct rte_thash_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct rte_thash_subtuple_helper *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tuple_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>desired_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>attempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__thash_8h.html#adcbf8828620e24717d417d3cfae8aa0a">rte_thash_check_tuple_t</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adjusts tuple in the way to make Toeplitz hash has desired least significant bits. This function is multi-thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Thash context </td></tr>
    <tr><td class="paramname">h</td><td>Pointer to the helper struct </td></tr>
    <tr><td class="paramname">tuple</td><td>Pointer to the tuple to be adjusted </td></tr>
    <tr><td class="paramname">tuple_len</td><td>Length of the tuple. Must be multiple of 4. </td></tr>
    <tr><td class="paramname">desired_value</td><td>Desired value of least significant bits of the hash </td></tr>
    <tr><td class="paramname">attempts</td><td>Number of attempts to adjust tuple with fn() calling </td></tr>
    <tr><td class="paramname">fn</td><td>Callback function to check adjusted tuple. Could be NULL </td></tr>
    <tr><td class="paramname">userdata</td><td>Pointer to the userdata to be passed to fn(). Could be NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success negative otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
