<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/pdcp/rte_pdcp.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">23.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_7037b1d0e5d5177c10a0b0724c48d1c6.html">pdcp</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_pdcp.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;rte_compat.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__common_8h_source.html">rte_common.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__pdcp__hdr_8h_source.html">rte_pdcp_hdr.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__security_8h_source.html">rte_security.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__pdcp__group_8h_source.html">rte_pdcp_group.h</a>&gt;</code><br />
</div>
<p><a href="rte__pdcp_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__pdcp__entity.html">rte_pdcp_entity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__pdcp__t__reordering.html">rte_pdcp_t_reordering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__pdcp__entity__conf.html">rte_pdcp_entity_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aeb7b4996e1db08a0696eb66e76d67e67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pdcp_8h.html#aeb7b4996e1db08a0696eb66e76d67e67">rte_pdcp_t_reordering_start_cb_t</a>) (void *timer, void *args)</td></tr>
<tr class="separator:aeb7b4996e1db08a0696eb66e76d67e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5e75111b5ed516ee68533c0e193c86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pdcp_8h.html#a7d5e75111b5ed516ee68533c0e193c86">rte_pdcp_t_reordering_stop_cb_t</a>) (void *timer, void *args)</td></tr>
<tr class="separator:a7d5e75111b5ed516ee68533c0e193c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a124cd576c49c66c831fb6425f2010364"><td class="memItemLeft" align="right" valign="top">__rte_experimental struct <a class="el" href="structrte__pdcp__entity.html">rte_pdcp_entity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pdcp_8h.html#a124cd576c49c66c831fb6425f2010364">rte_pdcp_entity_establish</a> (const struct <a class="el" href="structrte__pdcp__entity__conf.html">rte_pdcp_entity_conf</a> *conf)</td></tr>
<tr class="separator:a124cd576c49c66c831fb6425f2010364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfc89494a47d5d5df6afd830e73eb98"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pdcp_8h.html#a0cfc89494a47d5d5df6afd830e73eb98">rte_pdcp_entity_release</a> (struct <a class="el" href="structrte__pdcp__entity.html">rte_pdcp_entity</a> *pdcp_entity, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *out_mb[])</td></tr>
<tr class="separator:a0cfc89494a47d5d5df6afd830e73eb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a8059602b82f18a47dfcb1c85a5fc2"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pdcp_8h.html#a72a8059602b82f18a47dfcb1c85a5fc2">rte_pdcp_entity_suspend</a> (struct <a class="el" href="structrte__pdcp__entity.html">rte_pdcp_entity</a> *pdcp_entity, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *out_mb[])</td></tr>
<tr class="separator:a72a8059602b82f18a47dfcb1c85a5fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e33a19768bf5bc4df2483f3f6f7144"><td class="memItemLeft" align="right" valign="top">__rte_experimental struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pdcp_8h.html#a66e33a19768bf5bc4df2483f3f6f7144">rte_pdcp_control_pdu_create</a> (struct <a class="el" href="structrte__pdcp__entity.html">rte_pdcp_entity</a> *pdcp_entity, enum <a class="el" href="rte__pdcp__hdr_8h.html#a6b915cc04ad349710a0f13d2315dd616">rte_pdcp_ctrl_pdu_type</a> type)</td></tr>
<tr class="separator:a66e33a19768bf5bc4df2483f3f6f7144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108a848fed7ffedea82f2710c8991f7a"><td class="memItemLeft" align="right" valign="top">static __rte_experimental uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pdcp_8h.html#a108a848fed7ffedea82f2710c8991f7a">rte_pdcp_pkt_pre_process</a> (const struct <a class="el" href="structrte__pdcp__entity.html">rte_pdcp_entity</a> *entity, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *mb[], struct <a class="el" href="structrte__crypto__op.html">rte_crypto_op</a> *cop[], uint16_t num, uint16_t *nb_err)</td></tr>
<tr class="separator:a108a848fed7ffedea82f2710c8991f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5798f42dc3fb1a04ca7188ea47974ee"><td class="memItemLeft" align="right" valign="top">static __rte_experimental uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pdcp_8h.html#aa5798f42dc3fb1a04ca7188ea47974ee">rte_pdcp_pkt_post_process</a> (const struct <a class="el" href="structrte__pdcp__entity.html">rte_pdcp_entity</a> *entity, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *in_mb[], struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *out_mb[], uint16_t num, uint16_t *nb_err)</td></tr>
<tr class="separator:aa5798f42dc3fb1a04ca7188ea47974ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af167777030694ffdfaafca10baaac5c5"><td class="memItemLeft" align="right" valign="top">__rte_experimental uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pdcp_8h.html#af167777030694ffdfaafca10baaac5c5">rte_pdcp_t_reordering_expiry_handle</a> (const struct <a class="el" href="structrte__pdcp__entity.html">rte_pdcp_entity</a> *entity, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *out_mb[])</td></tr>
<tr class="separator:af167777030694ffdfaafca10baaac5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE PDCP support.</p>
<p>A framework for PDCP protocol processing. </p>

<p class="definition">Definition in file <a class="el" href="rte__pdcp_8h_source.html">rte_pdcp.h</a>.</p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aeb7b4996e1db08a0696eb66e76d67e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7b4996e1db08a0696eb66e76d67e67">&#9670;&nbsp;</a></span>rte_pdcp_t_reordering_start_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void(* rte_pdcp_t_reordering_start_cb_t) (void *timer, void *args)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function type for t-Reordering timer start, set during PDCP entity establish. This callback is invoked by PDCP library, during t-Reordering timer start event. Only one t-Reordering per receiving PDCP entity would be running at a given time.</p>
<dl class="section see"><dt>See also</dt><dd>struct rte_pdcp_timer </dd>
<dd>
<a class="el" href="rte__pdcp_8h.html#a124cd576c49c66c831fb6425f2010364">rte_pdcp_entity_establish()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>Pointer to timer. </td></tr>
    <tr><td class="paramname">args</td><td>Pointer to timer arguments. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__pdcp_8h_source.html#l00084">84</a> of file <a class="el" href="rte__pdcp_8h_source.html">rte_pdcp.h</a>.</p>

</div>
</div>
<a id="a7d5e75111b5ed516ee68533c0e193c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5e75111b5ed516ee68533c0e193c86">&#9670;&nbsp;</a></span>rte_pdcp_t_reordering_stop_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void(* rte_pdcp_t_reordering_stop_cb_t) (void *timer, void *args)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function type for t-Reordering timer stop, set during PDCP entity establish. This callback will be invoked by PDCP library, during t-Reordering timer stop event.</p>
<dl class="section see"><dt>See also</dt><dd>struct rte_pdcp_timer </dd>
<dd>
<a class="el" href="rte__pdcp_8h.html#a124cd576c49c66c831fb6425f2010364">rte_pdcp_entity_establish()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>Pointer to timer. </td></tr>
    <tr><td class="paramname">args</td><td>Pointer to timer arguments. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__pdcp_8h_source.html#l00098">98</a> of file <a class="el" href="rte__pdcp_8h_source.html">rte_pdcp.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a124cd576c49c66c831fb6425f2010364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124cd576c49c66c831fb6425f2010364">&#9670;&nbsp;</a></span>rte_pdcp_entity_establish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental struct <a class="el" href="structrte__pdcp__entity.html">rte_pdcp_entity</a>* rte_pdcp_entity_establish </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__pdcp__entity__conf.html">rte_pdcp_entity_conf</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>5.1.1 PDCP entity establishment</p>
<p>Establish PDCP entity based on provided input configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>Parameters to be used for initializing PDCP entity object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Valid handle if success</li>
<li>NULL in case of failure. rte_errno will be set to error code. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0cfc89494a47d5d5df6afd830e73eb98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfc89494a47d5d5df6afd830e73eb98">&#9670;&nbsp;</a></span>rte_pdcp_entity_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_pdcp_entity_release </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__pdcp__entity.html">rte_pdcp_entity</a> *&#160;</td>
          <td class="paramname"><em>pdcp_entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>out_mb</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>5.1.3 PDCP entity release</p>
<p>Release PDCP entity.</p>
<p>For UL/transmitting PDCP entity, all stored PDCP SDUs would be dropped. For DL/receiving PDCP entity, the stored PDCP SDUs would be returned in <em>out_mb</em> buffer. The buffer should be large enough to hold all cached packets in the entity.</p>
<p>Entity release would result in freeing all memory associated with the PDCP entity as well as any crypto/security sessions created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pdcp_entity</td><td>Pointer to the PDCP entity to be released. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_mb</td><td>The address of an array that can hold up to <em><a class="el" href="structrte__pdcp__entity.html#a4d760deb7f75ee0e1c556056368f39c7">rte_pdcp_entity.max_pkt_cache</a></em> pointers to <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> structures. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success and no cached packets to return</li>
<li>&gt;0: Success and the number of packets returned in out_mb</li>
<li>&lt;0: Error code in case of failures </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a72a8059602b82f18a47dfcb1c85a5fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a8059602b82f18a47dfcb1c85a5fc2">&#9670;&nbsp;</a></span>rte_pdcp_entity_suspend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_pdcp_entity_suspend </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__pdcp__entity.html">rte_pdcp_entity</a> *&#160;</td>
          <td class="paramname"><em>pdcp_entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>out_mb</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>5.1.4 PDCP entity suspend</p>
<p>Suspend PDCP entity.</p>
<p>For DL/receiving PDCP entity, the stored PDCP SDUs would be returned in <em>out_mb</em> buffer. The buffer should be large enough to hold all cached packets in the entity.</p>
<p>For UL/transmitting PDCP entity, <em>out_mb</em> buffer would be unused.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pdcp_entity</td><td>Pointer to the PDCP entity to be suspended. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_mb</td><td>The address of an array that can hold up to <em><a class="el" href="structrte__pdcp__entity.html#a4d760deb7f75ee0e1c556056368f39c7">rte_pdcp_entity.max_pkt_cache</a></em> pointers to <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> structures. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success and no cached packets to return.</li>
<li>&gt;0: Success and the number of packets returned in out_mb.</li>
<li>&lt;0: Error code in case of failures. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a66e33a19768bf5bc4df2483f3f6f7144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e33a19768bf5bc4df2483f3f6f7144">&#9670;&nbsp;</a></span>rte_pdcp_control_pdu_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a>* rte_pdcp_control_pdu_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__pdcp__entity.html">rte_pdcp_entity</a> *&#160;</td>
          <td class="paramname"><em>pdcp_entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__pdcp__hdr_8h.html#a6b915cc04ad349710a0f13d2315dd616">rte_pdcp_ctrl_pdu_type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Create control PDU packet of the <code>type</code> specified. The control PDU packet would be allocated from <em><a class="el" href="structrte__pdcp__entity__conf.html#a40d51bdfe057bee81722abf111e8efd7">rte_pdcp_entity_conf.ctrl_pdu_pool</a></em> by lib PDCP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdcp_entity</td><td>Pointer to the PDCP entity for which the control PDU need to be generated. </td></tr>
    <tr><td class="paramname">type</td><td>Type of control PDU to be generated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Control PDU generated, in case of success.</li>
<li>NULL in case of failure. rte_errno will be set to error code. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a108a848fed7ffedea82f2710c8991f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108a848fed7ffedea82f2710c8991f7a">&#9670;&nbsp;</a></span>rte_pdcp_pkt_pre_process()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __rte_experimental uint16_t rte_pdcp_pkt_pre_process </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__pdcp__entity.html">rte_pdcp_entity</a> *&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>mb</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__crypto__op.html">rte_crypto_op</a> *&#160;</td>
          <td class="paramname"><em>cop</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>nb_err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>For input mbufs and given PDCP entity pre-process the mbufs and prepare crypto ops that can be enqueued to the cryptodev associated with given session. Only error packets would be moved returned in the input buffer, <em>mb</em>, and it is the responsibility of the application to free the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">entity</td><td>Pointer to the <em><a class="el" href="structrte__pdcp__entity.html">rte_pdcp_entity</a></em> object the packets belong to. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mb</td><td>The address of an array of <em>num</em> pointers to <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> structures which contain the input packets. Any error packets would be returned in the same buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cop</td><td>The address of an array that can hold up to <em>num</em> pointers to <em><a class="el" href="structrte__crypto__op.html">rte_crypto_op</a></em> structures. Crypto ops would be allocated by <code>rte_pdcp_pkt_pre_process</code> API. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>The maximum number of packets to process. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nb_err</td><td>Pointer to return the number of error packets returned in <em>mb</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of crypto_ops prepared. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__pdcp_8h_source.html#l00293">293</a> of file <a class="el" href="rte__pdcp_8h_source.html">rte_pdcp.h</a>.</p>

</div>
</div>
<a id="aa5798f42dc3fb1a04ca7188ea47974ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5798f42dc3fb1a04ca7188ea47974ee">&#9670;&nbsp;</a></span>rte_pdcp_pkt_post_process()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __rte_experimental uint16_t rte_pdcp_pkt_post_process </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__pdcp__entity.html">rte_pdcp_entity</a> *&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>in_mb</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>out_mb</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>nb_err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>For input mbufs and given PDCP entity, perform PDCP post-processing of the mbufs.</p>
<p>Input mbufs are the ones retrieved from rte_crypto_ops dequeued from cryptodev and grouped by <em><a class="el" href="rte__pdcp__group_8h.html#a1e609fe5435fbc0633677247fdbe0251">rte_pdcp_pkt_crypto_group()</a></em>.</p>
<p>The post-processed packets would be returned in the <em>out_mb</em> buffer. The resultant mbufs would be grouped into success packets and error packets. Error packets would be grouped in the end of the array and it is the responsibility of the application to handle the same.</p>
<p>When in-order delivery is enabled, PDCP entity may buffer packets and would deliver packets only when all prior packets have been post-processed. That would result in returning more/less packets than enqueued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">entity</td><td>Pointer to the <em><a class="el" href="structrte__pdcp__entity.html">rte_pdcp_entity</a></em> object the packets belong to. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_mb</td><td>The address of an array of <em>num</em> pointers to <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> structures. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_mb</td><td>The address of an array that can hold up to <em><a class="el" href="structrte__pdcp__entity.html#a4d760deb7f75ee0e1c556056368f39c7">rte_pdcp_entity.max_pkt_cache</a></em> pointers to <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> structures to output packets after PDCP post-processing. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>The maximum number of packets to process. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nb_err</td><td>The number of error packets returned in <em>out_mb</em> buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of packets returned in <em>out_mb</em> buffer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__pdcp_8h_source.html#l00334">334</a> of file <a class="el" href="rte__pdcp_8h_source.html">rte_pdcp.h</a>.</p>

</div>
</div>
<a id="af167777030694ffdfaafca10baaac5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af167777030694ffdfaafca10baaac5c5">&#9670;&nbsp;</a></span>rte_pdcp_t_reordering_expiry_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental uint16_t rte_pdcp_t_reordering_expiry_handle </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__pdcp__entity.html">rte_pdcp_entity</a> *&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>out_mb</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>5.2.2.2 Actions when a t-Reordering expires</p>
<p>When t-Reordering timer expires, PDCP is required to slide the reception window by updating state variables such as RX_REORD &amp; RX_DELIV. PDCP would need to deliver some of the buffered packets based on the state variables and conditions described.</p>
<p>The expiry handle need to be invoked by the application when t-Reordering timer expires. In addition to returning buffered packets, it may also restart timer based on the state variables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">entity</td><td>Pointer to the <em><a class="el" href="structrte__pdcp__entity.html">rte_pdcp_entity</a></em> for which the timer expired. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_mb</td><td>The address of an array that can hold up to <em><a class="el" href="structrte__pdcp__entity.html#a4d760deb7f75ee0e1c556056368f39c7">rte_pdcp_entity.max_pkt_cache</a></em> pointers to <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> structures. Used to return buffered packets that are expired. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of packets returned in <em>out_mb</em> buffer. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
