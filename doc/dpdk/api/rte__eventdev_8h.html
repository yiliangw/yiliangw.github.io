<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/eventdev/rte_eventdev.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">23.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_a66127405287735c58fa95e3096a1dc5.html">eventdev</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">rte_eventdev.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;rte_compat.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__common_8h_source.html">rte_common.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__errno_8h_source.html">rte_errno.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__mbuf__pool__ops_8h_source.html">rte_mbuf_pool_ops.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>&gt;</code><br />
<code>#include &quot;<a class="el" href="rte__eventdev__trace__fp_8h_source.html">rte_eventdev_trace_fp.h</a>&quot;</code><br />
<code>#include &lt;rte_eventdev_core.h&gt;</code><br />
</div>
<p><a href="rte__eventdev_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__event__dev__info.html">rte_event_dev_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__event__dev__config.html">rte_event_dev_config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__event__queue__conf.html">rte_event_queue_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__event__port__conf.html">rte_event_port_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__event__vector.html">rte_event_vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__event.html">rte_event</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__event__dev__xstats__name.html">rte_event_dev_xstats_name</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:acd8e2def7069ede68d5d37031323f952"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#acd8e2def7069ede68d5d37031323f952">RTE_EVENT_DEV_CAP_QUEUE_QOS</a>&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td></tr>
<tr class="separator:acd8e2def7069ede68d5d37031323f952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba3fa8f6c8170889356bdf893ec3183"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aeba3fa8f6c8170889356bdf893ec3183">RTE_EVENT_DEV_CAP_EVENT_QOS</a>&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td></tr>
<tr class="separator:aeba3fa8f6c8170889356bdf893ec3183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d3efc148e69c47d8bfb16c71a7f72d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#af5d3efc148e69c47d8bfb16c71a7f72d">RTE_EVENT_DEV_CAP_DISTRIBUTED_SCHED</a>&#160;&#160;&#160;(1ULL &lt;&lt; 2)</td></tr>
<tr class="separator:af5d3efc148e69c47d8bfb16c71a7f72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74409c333b42420f7fb085ac79509a03"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a74409c333b42420f7fb085ac79509a03">RTE_EVENT_DEV_CAP_QUEUE_ALL_TYPES</a>&#160;&#160;&#160;(1ULL &lt;&lt; 3)</td></tr>
<tr class="separator:a74409c333b42420f7fb085ac79509a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64cc76b136d54ca0c86332ed3723b15"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ae64cc76b136d54ca0c86332ed3723b15">RTE_EVENT_DEV_CAP_BURST_MODE</a>&#160;&#160;&#160;(1ULL &lt;&lt; 4)</td></tr>
<tr class="separator:ae64cc76b136d54ca0c86332ed3723b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1353d48908ed22912d8cdeee018ae0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a4b1353d48908ed22912d8cdeee018ae0">RTE_EVENT_DEV_CAP_IMPLICIT_RELEASE_DISABLE</a>&#160;&#160;&#160;(1ULL &lt;&lt; 5)</td></tr>
<tr class="separator:a4b1353d48908ed22912d8cdeee018ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be33f24673d26d71a3695dfd62623fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a6be33f24673d26d71a3695dfd62623fa">RTE_EVENT_DEV_CAP_NONSEQ_MODE</a>&#160;&#160;&#160;(1ULL &lt;&lt; 6)</td></tr>
<tr class="separator:a6be33f24673d26d71a3695dfd62623fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2706ca7f81fc820e297b99e0e8c2583e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a2706ca7f81fc820e297b99e0e8c2583e">RTE_EVENT_DEV_CAP_RUNTIME_PORT_LINK</a>&#160;&#160;&#160;(1ULL &lt;&lt; 7)</td></tr>
<tr class="separator:a2706ca7f81fc820e297b99e0e8c2583e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa865eedbbd9dac71ac37321fa63ac8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#affa865eedbbd9dac71ac37321fa63ac8">RTE_EVENT_DEV_CAP_MULTIPLE_QUEUE_PORT</a>&#160;&#160;&#160;(1ULL &lt;&lt; 8)</td></tr>
<tr class="separator:affa865eedbbd9dac71ac37321fa63ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49215a9464a6825173251862149abab4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a49215a9464a6825173251862149abab4">RTE_EVENT_DEV_CAP_CARRY_FLOW_ID</a>&#160;&#160;&#160;(1ULL &lt;&lt; 9)</td></tr>
<tr class="separator:a49215a9464a6825173251862149abab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fbffafa7e06b1a005f2f6bdedf8532"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ad6fbffafa7e06b1a005f2f6bdedf8532">RTE_EVENT_DEV_CAP_MAINTENANCE_FREE</a>&#160;&#160;&#160;(1ULL &lt;&lt; 10)</td></tr>
<tr class="separator:ad6fbffafa7e06b1a005f2f6bdedf8532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd334dbc86d81cf06f91fc1530987cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aadd334dbc86d81cf06f91fc1530987cc">RTE_EVENT_DEV_CAP_RUNTIME_QUEUE_ATTR</a>&#160;&#160;&#160;(1ULL &lt;&lt; 11)</td></tr>
<tr class="separator:aadd334dbc86d81cf06f91fc1530987cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9a2569988d23fdeebae6acca1ce7e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a9b9a2569988d23fdeebae6acca1ce7e1">RTE_EVENT_DEV_CAP_PROFILE_LINK</a>&#160;&#160;&#160;(1ULL &lt;&lt; 12)</td></tr>
<tr class="separator:a9b9a2569988d23fdeebae6acca1ce7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a89072eb7078f8be0f9b0c2642e34ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a7a89072eb7078f8be0f9b0c2642e34ef">RTE_EVENT_DEV_PRIORITY_HIGHEST</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a7a89072eb7078f8be0f9b0c2642e34ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0110e34375b970cb883979a3c489e5c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a0110e34375b970cb883979a3c489e5c5">RTE_EVENT_DEV_PRIORITY_NORMAL</a>&#160;&#160;&#160;128</td></tr>
<tr class="separator:a0110e34375b970cb883979a3c489e5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba559138ff70b32510631ad1ce5b8da5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aba559138ff70b32510631ad1ce5b8da5">RTE_EVENT_DEV_PRIORITY_LOWEST</a>&#160;&#160;&#160;255</td></tr>
<tr class="separator:aba559138ff70b32510631ad1ce5b8da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bf321656bc4a3921385dcb2eca5766"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a22bf321656bc4a3921385dcb2eca5766">RTE_EVENT_QUEUE_WEIGHT_HIGHEST</a>&#160;&#160;&#160;255</td></tr>
<tr class="separator:a22bf321656bc4a3921385dcb2eca5766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121794eca66dc8700f40299e9c21cc7a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a121794eca66dc8700f40299e9c21cc7a">RTE_EVENT_QUEUE_WEIGHT_LOWEST</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a121794eca66dc8700f40299e9c21cc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941b7ed39c32fb59127a2ebfa8c83b23"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a941b7ed39c32fb59127a2ebfa8c83b23">RTE_EVENT_QUEUE_AFFINITY_HIGHEST</a>&#160;&#160;&#160;255</td></tr>
<tr class="separator:a941b7ed39c32fb59127a2ebfa8c83b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ccba1d3f7e99dd75352e578f2cd5e2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a65ccba1d3f7e99dd75352e578f2cd5e2">RTE_EVENT_QUEUE_AFFINITY_LOWEST</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a65ccba1d3f7e99dd75352e578f2cd5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e175391c335d69f4f488f0a8a08f69"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#af6e175391c335d69f4f488f0a8a08f69">RTE_EVENT_DEV_ATTR_PORT_COUNT</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:af6e175391c335d69f4f488f0a8a08f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346e82537d965576cfa4642da7ae66b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a346e82537d965576cfa4642da7ae66b2">RTE_EVENT_DEV_ATTR_QUEUE_COUNT</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a346e82537d965576cfa4642da7ae66b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd45d7b76782e02927ea966bd2d27b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a7dd45d7b76782e02927ea966bd2d27b1">RTE_EVENT_DEV_ATTR_STARTED</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a7dd45d7b76782e02927ea966bd2d27b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc71a4c2e35b5b23fe6fcf593c5909a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aedc71a4c2e35b5b23fe6fcf593c5909a">RTE_EVENT_DEV_CFG_PER_DEQUEUE_TIMEOUT</a>&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td></tr>
<tr class="separator:aedc71a4c2e35b5b23fe6fcf593c5909a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b417a1b2250685f2b583aa30a259241"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a6b417a1b2250685f2b583aa30a259241">RTE_EVENT_QUEUE_CFG_ALL_TYPES</a>&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td></tr>
<tr class="separator:a6b417a1b2250685f2b583aa30a259241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0d54b104105e6f861c6e41b0ca3f9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a3b0d54b104105e6f861c6e41b0ca3f9f">RTE_EVENT_QUEUE_CFG_SINGLE_LINK</a>&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td></tr>
<tr class="separator:a3b0d54b104105e6f861c6e41b0ca3f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b359fd06e58898590f9b5f3b8011f4a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a6b359fd06e58898590f9b5f3b8011f4a">RTE_EVENT_QUEUE_ATTR_PRIORITY</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a6b359fd06e58898590f9b5f3b8011f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f614827b00ced79a709be7b627e54c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ad5f614827b00ced79a709be7b627e54c">RTE_EVENT_QUEUE_ATTR_NB_ATOMIC_FLOWS</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ad5f614827b00ced79a709be7b627e54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115b78b02fc98a801bc62dd916ac9cf6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a115b78b02fc98a801bc62dd916ac9cf6">RTE_EVENT_QUEUE_ATTR_NB_ATOMIC_ORDER_SEQUENCES</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a115b78b02fc98a801bc62dd916ac9cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0ec3e9f90f3228a3ce31a548bed490"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a0d0ec3e9f90f3228a3ce31a548bed490">RTE_EVENT_QUEUE_ATTR_EVENT_QUEUE_CFG</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a0d0ec3e9f90f3228a3ce31a548bed490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe4b0cd9c9643f681b461938110156a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a5fe4b0cd9c9643f681b461938110156a">RTE_EVENT_QUEUE_ATTR_SCHEDULE_TYPE</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a5fe4b0cd9c9643f681b461938110156a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2591817922f4511b62ee7635067c7e18"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a2591817922f4511b62ee7635067c7e18">RTE_EVENT_QUEUE_ATTR_WEIGHT</a>&#160;&#160;&#160;5</td></tr>
<tr class="separator:a2591817922f4511b62ee7635067c7e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868d382567beeba509263e70141aacd9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a868d382567beeba509263e70141aacd9">RTE_EVENT_QUEUE_ATTR_AFFINITY</a>&#160;&#160;&#160;6</td></tr>
<tr class="separator:a868d382567beeba509263e70141aacd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc5d49a30616703a0f27f0c66f9b2ca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#afbc5d49a30616703a0f27f0c66f9b2ca">RTE_EVENT_PORT_CFG_DISABLE_IMPL_REL</a>&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td></tr>
<tr class="separator:afbc5d49a30616703a0f27f0c66f9b2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb50136dfac62bd29ddce2429b6c885"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aafb50136dfac62bd29ddce2429b6c885">RTE_EVENT_PORT_CFG_SINGLE_LINK</a>&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td></tr>
<tr class="separator:aafb50136dfac62bd29ddce2429b6c885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303abf06e3b4ac807137f8ff44cb3239"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a303abf06e3b4ac807137f8ff44cb3239">RTE_EVENT_PORT_CFG_HINT_PRODUCER</a>&#160;&#160;&#160;(1ULL &lt;&lt; 2)</td></tr>
<tr class="separator:a303abf06e3b4ac807137f8ff44cb3239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea09ff1e5833262f5cf1d378b30b58a4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aea09ff1e5833262f5cf1d378b30b58a4">RTE_EVENT_PORT_CFG_HINT_CONSUMER</a>&#160;&#160;&#160;(1ULL &lt;&lt; 3)</td></tr>
<tr class="separator:aea09ff1e5833262f5cf1d378b30b58a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add95e5b5732a00fd99b431d0a570209d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#add95e5b5732a00fd99b431d0a570209d">RTE_EVENT_PORT_CFG_HINT_WORKER</a>&#160;&#160;&#160;(1ULL &lt;&lt; 4)</td></tr>
<tr class="separator:add95e5b5732a00fd99b431d0a570209d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fc8695cb074e656ab5eadf286b0f08"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a40fc8695cb074e656ab5eadf286b0f08">RTE_EVENT_PORT_ATTR_ENQ_DEPTH</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a40fc8695cb074e656ab5eadf286b0f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd80caf495a4624fa213cc2330c8923"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#afcd80caf495a4624fa213cc2330c8923">RTE_EVENT_PORT_ATTR_DEQ_DEPTH</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:afcd80caf495a4624fa213cc2330c8923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a28fba179c8b08f42eaab7f3683a39"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a60a28fba179c8b08f42eaab7f3683a39">RTE_EVENT_PORT_ATTR_NEW_EVENT_THRESHOLD</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a60a28fba179c8b08f42eaab7f3683a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf25098a79d7e3ad4fd936737808a9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aebf25098a79d7e3ad4fd936737808a9f">RTE_EVENT_PORT_ATTR_IMPLICIT_RELEASE_DISABLE</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:aebf25098a79d7e3ad4fd936737808a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366ab13bc5be32cbc9ee15e294b4c9a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a366ab13bc5be32cbc9ee15e294b4c9a2">RTE_SCHED_TYPE_ORDERED</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a366ab13bc5be32cbc9ee15e294b4c9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c199a28e97411266a069bd07c9757fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a3c199a28e97411266a069bd07c9757fa">RTE_SCHED_TYPE_ATOMIC</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a3c199a28e97411266a069bd07c9757fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88982845a12ff215c721fccb18ed4a7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ac88982845a12ff215c721fccb18ed4a7">RTE_SCHED_TYPE_PARALLEL</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ac88982845a12ff215c721fccb18ed4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a711c45b3d3f125069b1a7cb731435"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ae5a711c45b3d3f125069b1a7cb731435">RTE_EVENT_TYPE_ETHDEV</a>&#160;&#160;&#160;0x0</td></tr>
<tr class="separator:ae5a711c45b3d3f125069b1a7cb731435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982ad2bf50bd73e7cdbe2a62e5d581f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a982ad2bf50bd73e7cdbe2a62e5d581f6">RTE_EVENT_TYPE_CRYPTODEV</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="separator:a982ad2bf50bd73e7cdbe2a62e5d581f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247d3e6500516ff097e06f199dfb5cc3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a247d3e6500516ff097e06f199dfb5cc3">RTE_EVENT_TYPE_TIMER</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="separator:a247d3e6500516ff097e06f199dfb5cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15be67634b343dc7dc7b6d63630abdd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ac15be67634b343dc7dc7b6d63630abdd">RTE_EVENT_TYPE_CPU</a>&#160;&#160;&#160;0x3</td></tr>
<tr class="separator:ac15be67634b343dc7dc7b6d63630abdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934df8149a7a1a4cfcdbb18a880d837c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a934df8149a7a1a4cfcdbb18a880d837c">RTE_EVENT_TYPE_ETH_RX_ADAPTER</a>&#160;&#160;&#160;0x4</td></tr>
<tr class="separator:a934df8149a7a1a4cfcdbb18a880d837c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add86bf2aa79f073ef45307d022bc5cc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#add86bf2aa79f073ef45307d022bc5cc2">RTE_EVENT_TYPE_DMADEV</a>&#160;&#160;&#160;0x5</td></tr>
<tr class="separator:add86bf2aa79f073ef45307d022bc5cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0feebd419e446783c98600a0f683c3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a6c0feebd419e446783c98600a0f683c3">RTE_EVENT_TYPE_VECTOR</a>&#160;&#160;&#160;0x8</td></tr>
<tr class="separator:a6c0feebd419e446783c98600a0f683c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c4a69d989950af3cb5525a16812d09"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a13c4a69d989950af3cb5525a16812d09">RTE_EVENT_TYPE_ETHDEV_VECTOR</a>&#160;&#160;&#160;	(<a class="el" href="rte__eventdev_8h.html#a6c0feebd419e446783c98600a0f683c3">RTE_EVENT_TYPE_VECTOR</a> | <a class="el" href="rte__eventdev_8h.html#ae5a711c45b3d3f125069b1a7cb731435">RTE_EVENT_TYPE_ETHDEV</a>)</td></tr>
<tr class="separator:a13c4a69d989950af3cb5525a16812d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a506b7019a0d71d0422725ad9379b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a07a506b7019a0d71d0422725ad9379b4">RTE_EVENT_TYPE_CPU_VECTOR</a>&#160;&#160;&#160;(<a class="el" href="rte__eventdev_8h.html#a6c0feebd419e446783c98600a0f683c3">RTE_EVENT_TYPE_VECTOR</a> | <a class="el" href="rte__eventdev_8h.html#ac15be67634b343dc7dc7b6d63630abdd">RTE_EVENT_TYPE_CPU</a>)</td></tr>
<tr class="separator:a07a506b7019a0d71d0422725ad9379b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4933c73c89694a3b085cf283f74fa7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a2c4933c73c89694a3b085cf283f74fa7">RTE_EVENT_TYPE_ETH_RX_ADAPTER_VECTOR</a>&#160;&#160;&#160;	(<a class="el" href="rte__eventdev_8h.html#a6c0feebd419e446783c98600a0f683c3">RTE_EVENT_TYPE_VECTOR</a> | <a class="el" href="rte__eventdev_8h.html#a934df8149a7a1a4cfcdbb18a880d837c">RTE_EVENT_TYPE_ETH_RX_ADAPTER</a>)</td></tr>
<tr class="separator:a2c4933c73c89694a3b085cf283f74fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41470ca6deb51e17db09b70b97a0ed4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a41470ca6deb51e17db09b70b97a0ed4c">RTE_EVENT_TYPE_CRYPTODEV_VECTOR</a>&#160;&#160;&#160;	(<a class="el" href="rte__eventdev_8h.html#a6c0feebd419e446783c98600a0f683c3">RTE_EVENT_TYPE_VECTOR</a> | <a class="el" href="rte__eventdev_8h.html#a982ad2bf50bd73e7cdbe2a62e5d581f6">RTE_EVENT_TYPE_CRYPTODEV</a>)</td></tr>
<tr class="separator:a41470ca6deb51e17db09b70b97a0ed4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351dba845f2d001f6245fd41692d8c9e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a351dba845f2d001f6245fd41692d8c9e">RTE_EVENT_TYPE_MAX</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:a351dba845f2d001f6245fd41692d8c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69a0db3e4653c786aef1febe7594b78"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aa69a0db3e4653c786aef1febe7594b78">RTE_EVENT_OP_NEW</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:aa69a0db3e4653c786aef1febe7594b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416488eee18e9e740dba1c61a312f06a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a416488eee18e9e740dba1c61a312f06a">RTE_EVENT_OP_FORWARD</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a416488eee18e9e740dba1c61a312f06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab927860cf68a0c0a8caf96fe9feb2a23"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ab927860cf68a0c0a8caf96fe9feb2a23">RTE_EVENT_OP_RELEASE</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ab927860cf68a0c0a8caf96fe9feb2a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0938b6c89c22b3de3ee9e8bfa1da2ae7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a0938b6c89c22b3de3ee9e8bfa1da2ae7">RTE_EVENT_ETH_RX_ADAPTER_CAP_INTERNAL_PORT</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="separator:a0938b6c89c22b3de3ee9e8bfa1da2ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3abde85e981790ae41c69ad7df33b75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ac3abde85e981790ae41c69ad7df33b75">RTE_EVENT_ETH_RX_ADAPTER_CAP_MULTI_EVENTQ</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="separator:ac3abde85e981790ae41c69ad7df33b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d39c45789a6d8c808b08c57057f715c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a8d39c45789a6d8c808b08c57057f715c">RTE_EVENT_ETH_RX_ADAPTER_CAP_OVERRIDE_FLOW_ID</a>&#160;&#160;&#160;0x4</td></tr>
<tr class="separator:a8d39c45789a6d8c808b08c57057f715c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d399c8c2290059cbf38cad80ce3bcab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a7d399c8c2290059cbf38cad80ce3bcab">RTE_EVENT_ETH_RX_ADAPTER_CAP_EVENT_VECTOR</a>&#160;&#160;&#160;0x8</td></tr>
<tr class="separator:a7d399c8c2290059cbf38cad80ce3bcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3ed17910cfdeb061734fe14f9651fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aee3ed17910cfdeb061734fe14f9651fc">RTE_EVENT_TIMER_ADAPTER_CAP_INTERNAL_PORT</a>&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td></tr>
<tr class="separator:aee3ed17910cfdeb061734fe14f9651fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a05105d3e7f16cce2776408571e1a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ac9a05105d3e7f16cce2776408571e1a2">RTE_EVENT_TIMER_ADAPTER_CAP_PERIODIC</a>&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td></tr>
<tr class="separator:ac9a05105d3e7f16cce2776408571e1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832fc0958c7dedc25a4c294d7bc08c48"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a832fc0958c7dedc25a4c294d7bc08c48">RTE_EVENT_CRYPTO_ADAPTER_CAP_INTERNAL_PORT_OP_NEW</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="separator:a832fc0958c7dedc25a4c294d7bc08c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafffb3091cacef210c8710c7bb717311"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aafffb3091cacef210c8710c7bb717311">RTE_EVENT_CRYPTO_ADAPTER_CAP_INTERNAL_PORT_OP_FWD</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="separator:aafffb3091cacef210c8710c7bb717311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7594e773a009ba1c9c2e19f413125893"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a7594e773a009ba1c9c2e19f413125893">RTE_EVENT_CRYPTO_ADAPTER_CAP_INTERNAL_PORT_QP_EV_BIND</a>&#160;&#160;&#160;0x4</td></tr>
<tr class="separator:a7594e773a009ba1c9c2e19f413125893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07cd5e93133ab8aa760e3eb17a3b81b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ab07cd5e93133ab8aa760e3eb17a3b81b">RTE_EVENT_CRYPTO_ADAPTER_CAP_SESSION_PRIVATE_DATA</a>&#160;&#160;&#160;0x8</td></tr>
<tr class="separator:ab07cd5e93133ab8aa760e3eb17a3b81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea81dcf3d4f9b7f9b2d89bb88fec88bc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aea81dcf3d4f9b7f9b2d89bb88fec88bc">RTE_EVENT_CRYPTO_ADAPTER_CAP_EVENT_VECTOR</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:aea81dcf3d4f9b7f9b2d89bb88fec88bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11992fe6cfef96d66f9ba1272edf4b1a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a11992fe6cfef96d66f9ba1272edf4b1a">RTE_EVENT_DMA_ADAPTER_CAP_INTERNAL_PORT_OP_NEW</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="separator:a11992fe6cfef96d66f9ba1272edf4b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18db40d7488a8e7d65dfb43d5a990081"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a18db40d7488a8e7d65dfb43d5a990081">RTE_EVENT_DMA_ADAPTER_CAP_INTERNAL_PORT_OP_FWD</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="separator:a18db40d7488a8e7d65dfb43d5a990081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491b08bd86b63147cf2b700df58abeec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a491b08bd86b63147cf2b700df58abeec">RTE_EVENT_DMA_ADAPTER_CAP_INTERNAL_PORT_VCHAN_EV_BIND</a>&#160;&#160;&#160;0x4</td></tr>
<tr class="separator:a491b08bd86b63147cf2b700df58abeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6c6cbdc5b9091cc561ab38983be324"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a3b6c6cbdc5b9091cc561ab38983be324">RTE_EVENT_ETH_TX_ADAPTER_CAP_INTERNAL_PORT</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="separator:a3b6c6cbdc5b9091cc561ab38983be324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53c9dc91baa6270b15b0521f6874609"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aa53c9dc91baa6270b15b0521f6874609">RTE_EVENT_ETH_TX_ADAPTER_CAP_EVENT_VECTOR</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="separator:aa53c9dc91baa6270b15b0521f6874609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0248ac6e03597e9a8c57a96cd38f8e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ae0248ac6e03597e9a8c57a96cd38f8e1">RTE_EVENT_DEV_XSTATS_NAME_SIZE</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:ae0248ac6e03597e9a8c57a96cd38f8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2be1a618a0cd023313f6132765ba40"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a9a2be1a618a0cd023313f6132765ba40">RTE_EVENT_DEV_MAINT_OP_FLUSH</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr class="separator:a9a2be1a618a0cd023313f6132765ba40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1d624b5b4606fdaf0799c19412e30d2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a1d624b5b4606fdaf0799c19412e30d2b">rte_eventdev_port_flush_t</a>) (uint8_t dev_id, struct <a class="el" href="structrte__event.html">rte_event</a> event, void *arg)</td></tr>
<tr class="separator:a1d624b5b4606fdaf0799c19412e30d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e04cfb272018b6337d57cd49bfd405e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a9e04cfb272018b6337d57cd49bfd405e">rte_eventdev_stop_flush_t</a>) (uint8_t dev_id, struct <a class="el" href="structrte__event.html">rte_event</a> event, void *arg)</td></tr>
<tr class="separator:a9e04cfb272018b6337d57cd49bfd405e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a505adb6f39a9108c494df8070312dee5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a505adb6f39a9108c494df8070312dee5">rte_event_dev_xstats_mode</a> </td></tr>
<tr class="separator:a505adb6f39a9108c494df8070312dee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6541eb8822285c7b77455636201d5134"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a6541eb8822285c7b77455636201d5134">rte_event_dev_count</a> (void)</td></tr>
<tr class="separator:a6541eb8822285c7b77455636201d5134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da264acd9bd0da6795801c6568f0387"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a7da264acd9bd0da6795801c6568f0387">rte_event_dev_get_dev_id</a> (const char *name)</td></tr>
<tr class="separator:a7da264acd9bd0da6795801c6568f0387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92ef37cd075e2db64d4f358b939c205"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ae92ef37cd075e2db64d4f358b939c205">rte_event_dev_socket_id</a> (uint8_t dev_id)</td></tr>
<tr class="separator:ae92ef37cd075e2db64d4f358b939c205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd7355a0be9b94bbca0f32796e57358"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a5bd7355a0be9b94bbca0f32796e57358">rte_event_dev_info_get</a> (uint8_t dev_id, struct <a class="el" href="structrte__event__dev__info.html">rte_event_dev_info</a> *dev_info)</td></tr>
<tr class="separator:a5bd7355a0be9b94bbca0f32796e57358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e78537e4554caf73c13c79e8a3cd06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a79e78537e4554caf73c13c79e8a3cd06">rte_event_dev_attr_get</a> (uint8_t dev_id, uint32_t attr_id, uint32_t *attr_value)</td></tr>
<tr class="separator:a79e78537e4554caf73c13c79e8a3cd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e7d0094442b3a158e89f120a21687d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure</a> (uint8_t dev_id, const struct <a class="el" href="structrte__event__dev__config.html">rte_event_dev_config</a> *dev_conf)</td></tr>
<tr class="separator:af1e7d0094442b3a158e89f120a21687d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d3f2bd3f600cdc3d8724844cbbcf20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a57d3f2bd3f600cdc3d8724844cbbcf20">rte_event_queue_default_conf_get</a> (uint8_t dev_id, uint8_t queue_id, struct <a class="el" href="structrte__event__queue__conf.html">rte_event_queue_conf</a> *queue_conf)</td></tr>
<tr class="separator:a57d3f2bd3f600cdc3d8724844cbbcf20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a1db34b6c7bb2b05a5db7aab8c6834"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup</a> (uint8_t dev_id, uint8_t queue_id, const struct <a class="el" href="structrte__event__queue__conf.html">rte_event_queue_conf</a> *queue_conf)</td></tr>
<tr class="separator:a57a1db34b6c7bb2b05a5db7aab8c6834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6d7fa11b04003ff32884d83ae04960"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a9f6d7fa11b04003ff32884d83ae04960">rte_event_queue_attr_get</a> (uint8_t dev_id, uint8_t queue_id, uint32_t attr_id, uint32_t *attr_value)</td></tr>
<tr class="separator:a9f6d7fa11b04003ff32884d83ae04960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1749bc088a0f3077fadf9a524426b59f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a1749bc088a0f3077fadf9a524426b59f">rte_event_queue_attr_set</a> (uint8_t dev_id, uint8_t queue_id, uint32_t attr_id, uint64_t attr_value)</td></tr>
<tr class="separator:a1749bc088a0f3077fadf9a524426b59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf86b3088e02126b06be3c0a5ac07bb7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#abf86b3088e02126b06be3c0a5ac07bb7">rte_event_port_default_conf_get</a> (uint8_t dev_id, uint8_t port_id, struct <a class="el" href="structrte__event__port__conf.html">rte_event_port_conf</a> *port_conf)</td></tr>
<tr class="separator:abf86b3088e02126b06be3c0a5ac07bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac087670e6e885abcdf046c8e74844cd4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ac087670e6e885abcdf046c8e74844cd4">rte_event_port_setup</a> (uint8_t dev_id, uint8_t port_id, const struct <a class="el" href="structrte__event__port__conf.html">rte_event_port_conf</a> *port_conf)</td></tr>
<tr class="separator:ac087670e6e885abcdf046c8e74844cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a49e09fc904ab0709f3fb7f8e7ef8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a70a49e09fc904ab0709f3fb7f8e7ef8b">rte_event_port_quiesce</a> (uint8_t dev_id, uint8_t port_id, <a class="el" href="rte__eventdev_8h.html#a1d624b5b4606fdaf0799c19412e30d2b">rte_eventdev_port_flush_t</a> release_cb, void *args)</td></tr>
<tr class="separator:a70a49e09fc904ab0709f3fb7f8e7ef8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1cc781b1ab9af77077c6c91eab37220"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aa1cc781b1ab9af77077c6c91eab37220">rte_event_port_attr_get</a> (uint8_t dev_id, uint8_t port_id, uint32_t attr_id, uint32_t *attr_value)</td></tr>
<tr class="separator:aa1cc781b1ab9af77077c6c91eab37220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e99f06a45adaa095b257b93ebaf201"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ab6e99f06a45adaa095b257b93ebaf201">rte_event_dev_start</a> (uint8_t dev_id)</td></tr>
<tr class="separator:ab6e99f06a45adaa095b257b93ebaf201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644f6cc4ab24a5c07bfff9b0f5c42e8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a644f6cc4ab24a5c07bfff9b0f5c42e8e">rte_event_dev_stop</a> (uint8_t dev_id)</td></tr>
<tr class="separator:a644f6cc4ab24a5c07bfff9b0f5c42e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e3bcdbed65202e822f6cefeb891bf8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a61e3bcdbed65202e822f6cefeb891bf8">rte_event_dev_stop_flush_callback_register</a> (uint8_t dev_id, <a class="el" href="rte__eventdev_8h.html#a9e04cfb272018b6337d57cd49bfd405e">rte_eventdev_stop_flush_t</a> callback, void *userdata)</td></tr>
<tr class="separator:a61e3bcdbed65202e822f6cefeb891bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70f4ed704d89a4ffce3b4c105bac076"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#af70f4ed704d89a4ffce3b4c105bac076">rte_event_dev_close</a> (uint8_t dev_id)</td></tr>
<tr class="separator:af70f4ed704d89a4ffce3b4c105bac076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0257af1e87fb6e3aefb42c507b0997"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__event__vector.html">rte_event_vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a5d0257af1e87fb6e3aefb42c507b0997">__rte_aligned</a> (16)</td></tr>
<tr class="separator:a5d0257af1e87fb6e3aefb42c507b0997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56aa49dc89eb44d2e35bd72bd809db17"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a56aa49dc89eb44d2e35bd72bd809db17">rte_event_eth_rx_adapter_caps_get</a> (uint8_t dev_id, uint16_t eth_port_id, uint32_t *caps)</td></tr>
<tr class="separator:a56aa49dc89eb44d2e35bd72bd809db17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78649b804d0c880dd23b23fcd28100f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a78649b804d0c880dd23b23fcd28100f9">rte_event_timer_adapter_caps_get</a> (uint8_t dev_id, uint32_t *caps)</td></tr>
<tr class="separator:a78649b804d0c880dd23b23fcd28100f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b478480a0d8d93b20622be566c127ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a6b478480a0d8d93b20622be566c127ee">rte_event_crypto_adapter_caps_get</a> (uint8_t dev_id, uint8_t cdev_id, uint32_t *caps)</td></tr>
<tr class="separator:a6b478480a0d8d93b20622be566c127ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebd0fa9262a9d72377e786606e32765"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#acebd0fa9262a9d72377e786606e32765">rte_event_dma_adapter_caps_get</a> (uint8_t dev_id, uint8_t dmadev_id, uint32_t *caps)</td></tr>
<tr class="separator:acebd0fa9262a9d72377e786606e32765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad147297659da4017ff8a8cec1757548c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ad147297659da4017ff8a8cec1757548c">rte_event_eth_tx_adapter_caps_get</a> (uint8_t dev_id, uint16_t eth_port_id, uint32_t *caps)</td></tr>
<tr class="separator:ad147297659da4017ff8a8cec1757548c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245cbc6e55632565a57f6f98f492428f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a245cbc6e55632565a57f6f98f492428f">rte_event_dequeue_timeout_ticks</a> (uint8_t dev_id, uint64_t ns, uint64_t *timeout_ticks)</td></tr>
<tr class="separator:a245cbc6e55632565a57f6f98f492428f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f0abd90e6784a4dc1c4f07ece2715a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a27f0abd90e6784a4dc1c4f07ece2715a">rte_event_port_link</a> (uint8_t dev_id, uint8_t port_id, const uint8_t queues[], const uint8_t priorities[], uint16_t nb_links)</td></tr>
<tr class="separator:a27f0abd90e6784a4dc1c4f07ece2715a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8dad9f41edf100e192e5610b2f078d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ad8dad9f41edf100e192e5610b2f078d5">rte_event_port_unlink</a> (uint8_t dev_id, uint8_t port_id, uint8_t queues[], uint16_t nb_unlinks)</td></tr>
<tr class="separator:ad8dad9f41edf100e192e5610b2f078d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ec0678b318c4b94e4888c77adb262e"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a52ec0678b318c4b94e4888c77adb262e">rte_event_port_profile_links_set</a> (uint8_t dev_id, uint8_t port_id, const uint8_t queues[], const uint8_t priorities[], uint16_t nb_links, uint8_t profile_id)</td></tr>
<tr class="separator:a52ec0678b318c4b94e4888c77adb262e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda92a9ed5f3f2eaaafe8383e1aa9b96"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#adda92a9ed5f3f2eaaafe8383e1aa9b96">rte_event_port_profile_unlink</a> (uint8_t dev_id, uint8_t port_id, uint8_t queues[], uint16_t nb_unlinks, uint8_t profile_id)</td></tr>
<tr class="separator:adda92a9ed5f3f2eaaafe8383e1aa9b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065a820ce96a30fd83b54f535ef580d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a065a820ce96a30fd83b54f535ef580d9">rte_event_port_unlinks_in_progress</a> (uint8_t dev_id, uint8_t port_id)</td></tr>
<tr class="separator:a065a820ce96a30fd83b54f535ef580d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0524c6c5b1d32981669c4d84254228a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a0524c6c5b1d32981669c4d84254228a1">rte_event_port_links_get</a> (uint8_t dev_id, uint8_t port_id, uint8_t queues[], uint8_t priorities[])</td></tr>
<tr class="separator:a0524c6c5b1d32981669c4d84254228a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd3d3bdeb4f797aab241c6ec44b0167"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a9fd3d3bdeb4f797aab241c6ec44b0167">rte_event_port_profile_links_get</a> (uint8_t dev_id, uint8_t port_id, uint8_t queues[], uint8_t priorities[], uint8_t profile_id)</td></tr>
<tr class="separator:a9fd3d3bdeb4f797aab241c6ec44b0167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335e46a7e6c7b3c17629b007d0a85e62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a335e46a7e6c7b3c17629b007d0a85e62">rte_event_dev_service_id_get</a> (uint8_t dev_id, uint32_t *service_id)</td></tr>
<tr class="separator:a335e46a7e6c7b3c17629b007d0a85e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766ba60306ac044b59d6143c77288c46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a766ba60306ac044b59d6143c77288c46">rte_event_dev_dump</a> (uint8_t dev_id, FILE *f)</td></tr>
<tr class="separator:a766ba60306ac044b59d6143c77288c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0399370c18dbdcff6e6a059a9e13f97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ac0399370c18dbdcff6e6a059a9e13f97">rte_event_dev_xstats_names_get</a> (uint8_t dev_id, enum <a class="el" href="rte__eventdev_8h.html#a505adb6f39a9108c494df8070312dee5">rte_event_dev_xstats_mode</a> mode, uint8_t queue_port_id, struct <a class="el" href="structrte__event__dev__xstats__name.html">rte_event_dev_xstats_name</a> *xstats_names, uint64_t *ids, unsigned int size)</td></tr>
<tr class="separator:ac0399370c18dbdcff6e6a059a9e13f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b48f9036629f85ff8b584cddb035c3d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a8b48f9036629f85ff8b584cddb035c3d">rte_event_dev_xstats_get</a> (uint8_t dev_id, enum <a class="el" href="rte__eventdev_8h.html#a505adb6f39a9108c494df8070312dee5">rte_event_dev_xstats_mode</a> mode, uint8_t queue_port_id, const uint64_t ids[], uint64_t values[], unsigned int n)</td></tr>
<tr class="separator:a8b48f9036629f85ff8b584cddb035c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825237f051767fafd92c6d6a854425f7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a825237f051767fafd92c6d6a854425f7">rte_event_dev_xstats_by_name_get</a> (uint8_t dev_id, const char *name, uint64_t *id)</td></tr>
<tr class="separator:a825237f051767fafd92c6d6a854425f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757a80d9145b41fd1317ffcef576821c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a757a80d9145b41fd1317ffcef576821c">rte_event_dev_xstats_reset</a> (uint8_t dev_id, enum <a class="el" href="rte__eventdev_8h.html#a505adb6f39a9108c494df8070312dee5">rte_event_dev_xstats_mode</a> mode, int16_t queue_port_id, const uint64_t ids[], uint32_t nb_ids)</td></tr>
<tr class="separator:a757a80d9145b41fd1317ffcef576821c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592ae650e0315dd61364e1cab3ecd6a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a592ae650e0315dd61364e1cab3ecd6a7">rte_event_dev_selftest</a> (uint8_t dev_id)</td></tr>
<tr class="separator:a592ae650e0315dd61364e1cab3ecd6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe373c0c3a2882bad04528df0e08f40"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a9fe373c0c3a2882bad04528df0e08f40">rte_event_vector_pool_create</a> (const char *name, unsigned int n, unsigned int cache_size, uint16_t <a class="el" href="rte__eventdev_8h.html#ab62797c76613377624e5c316140dc259">nb_elem</a>, int socket_id)</td></tr>
<tr class="separator:a9fe373c0c3a2882bad04528df0e08f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6b7f3fd1b11858a2db91864708f9a4"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst</a> (uint8_t dev_id, uint8_t port_id, const struct <a class="el" href="structrte__event.html">rte_event</a> ev[], uint16_t nb_events)</td></tr>
<tr class="separator:afc6b7f3fd1b11858a2db91864708f9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9c183571cdd91c8a1c70fc6a6c1241"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a9b9c183571cdd91c8a1c70fc6a6c1241">rte_event_enqueue_new_burst</a> (uint8_t dev_id, uint8_t port_id, const struct <a class="el" href="structrte__event.html">rte_event</a> ev[], uint16_t nb_events)</td></tr>
<tr class="separator:a9b9c183571cdd91c8a1c70fc6a6c1241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6260ce13081213f8eb8b1b4da935ad"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a2a6260ce13081213f8eb8b1b4da935ad">rte_event_enqueue_forward_burst</a> (uint8_t dev_id, uint8_t port_id, const struct <a class="el" href="structrte__event.html">rte_event</a> ev[], uint16_t nb_events)</td></tr>
<tr class="separator:a2a6260ce13081213f8eb8b1b4da935ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af1610d3ede24979267333cf2da1aab"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst</a> (uint8_t dev_id, uint8_t port_id, struct <a class="el" href="structrte__event.html">rte_event</a> ev[], uint16_t nb_events, uint64_t timeout_ticks)</td></tr>
<tr class="separator:a2af1610d3ede24979267333cf2da1aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ce3e169d572451634dd050efcc7dfb"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aa0ce3e169d572451634dd050efcc7dfb">rte_event_maintain</a> (uint8_t dev_id, uint8_t port_id, int op)</td></tr>
<tr class="separator:aa0ce3e169d572451634dd050efcc7dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4329609b4ac283c3e7c8b87838778bc8"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a4329609b4ac283c3e7c8b87838778bc8">rte_event_port_profile_switch</a> (uint8_t dev_id, uint8_t port_id, uint8_t profile_id)</td></tr>
<tr class="separator:a4329609b4ac283c3e7c8b87838778bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab62797c76613377624e5c316140dc259"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ab62797c76613377624e5c316140dc259">nb_elem</a></td></tr>
<tr class="separator:ab62797c76613377624e5c316140dc259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14841202e26525493abd0705de37cc4a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a14841202e26525493abd0705de37cc4a">elem_offset</a></td></tr>
<tr class="separator:a14841202e26525493abd0705de37cc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6afa72984587556813605e9102d667d"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ac6afa72984587556813605e9102d667d">rsvd</a></td></tr>
<tr class="separator:ac6afa72984587556813605e9102d667d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f839b211018e7d9572262b3c9d8661"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a52f839b211018e7d9572262b3c9d8661">attr_valid</a></td></tr>
<tr class="separator:a52f839b211018e7d9572262b3c9d8661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57f61ffbd7fff9cde410809bb2771fd"><td class="memItemLeft" >union {</td></tr>
<tr class="memitem:ad57f61ffbd7fff9cde410809bb2771fd"><td class="memItemLeft" valign="top">};&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:ad57f61ffbd7fff9cde410809bb2771fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE Event Device API</p>
<p>In a polling model, lcores poll ethdev ports and associated rx queues directly to look for packet. In an event driven model, by contrast, lcores call the scheduler that selects packets for them based on programmer specified criteria. Eventdev library adds support for event driven programming model, which offer applications automatic multicore scaling, dynamic load balancing, pipelining, packet ingress order maintenance and synchronization services to simplify application packet processing.</p>
<p>The Event Device API is composed of two parts:</p>
<ul>
<li>The application-oriented Event API that includes functions to setup an event device (configure it, setup its queues, ports and start it), to establish the link between queues to port and to receive events, and so on.</li>
<li>The driver-oriented Event API that exports a function allowing an event poll Mode Driver (PMD) to simultaneously register itself as an event device driver.</li>
</ul>
<p>Event device components: </p><pre class="fragment">                +-----------------+
                | +-------------+ |
   +-------+    | |    flow 0   | |
   |Packet |    | +-------------+ |
   |event  |    | +-------------+ |
   |       |    | |    flow 1   | |port_link(port0, queue0)
   +-------+    | +-------------+ |     |     +--------+
   +-------+    | +-------------+ o-----v-----o        |dequeue +------+
   |Crypto |    | |    flow n   | |           | event  +-------&gt;|Core 0|
   |work   |    | +-------------+ o----+      | port 0 |        |      |
   |done ev|    |  event queue 0  |    |      +--------+        +------+
   +-------+    +-----------------+    |
   +-------+                           |
   |Timer  |    +-----------------+    |      +--------+
   |expiry |    | +-------------+ |    +------o        |dequeue +------+
   |event  |    | |    flow 0   | o-----------o event  +-------&gt;|Core 1|
   +-------+    | +-------------+ |      +----o port 1 |        |      |
  Event enqueue | +-------------+ |      |    +--------+        +------+
o-------------&gt; | |    flow 1   | |      |
   enqueue(     | +-------------+ |      |
   queue_id,    |                 |      |    +--------+        +------+
   flow_id,     | +-------------+ |      |    |        |dequeue |Core 2|
   sched_type,  | |    flow n   | o-----------o event  +-------&gt;|      |
   event_type,  | +-------------+ |      |    | port 2 |        +------+
   subev_type,  |  event queue 1  |      |    +--------+
   event)       +-----------------+      |    +--------+
                                         |    |        |dequeue +------+
   +-------+    +-----------------+      |    | event  +-------&gt;|Core n|
   |Core   |    | +-------------+ o-----------o port n |        |      |
   |(SW)   |    | |    flow 0   | |      |    +--------+        +--+---+
   |event  |    | +-------------+ |      |                         |
   +-------+    | +-------------+ |      |                         |
       ^        | |    flow 1   | |      |                         |
       |        | +-------------+ o------+                         |
       |        | +-------------+ |                                |
       |        | |    flow n   | |                                |
       |        | +-------------+ |                                |
       |        |  event queue n  |                                |
       |        +-----------------+                                |
       |                                                           |
       +-----------------------------------------------------------+
</pre><p> Event device: A hardware or software-based event scheduler.</p>
<p>Event: A unit of scheduling that encapsulates a packet or other datatype like SW generated event from the CPU, Crypto work completion notification, Timer expiry event notification etc as well as metadata. The metadata includes flow ID, scheduling type, event priority, event_type, sub_event_type etc.</p>
<p>Event queue: A queue containing events that are scheduled by the event dev. An event queue contains events of different flows associated with scheduling types, such as atomic, ordered, or parallel.</p>
<p>Event port: An application's interface into the event dev for enqueue and dequeue operations. Each event port can be linked with one or more event queues for dequeue operations.</p>
<p>By default, all the functions of the Event Device API exported by a PMD are lock-free functions which assume to not be invoked in parallel on different logical cores to work on the same target object. For instance, the dequeue function of a PMD cannot be invoked in parallel on two logical cores to operates on same event port. Of course, this function can be invoked in parallel by different logical cores on different ports. It is the responsibility of the upper level application to enforce this rule.</p>
<p>In all functions of the Event API, the Event device is designated by an integer &gt;= 0 named the device identifier <em>dev_id</em></p>
<p>At the Event driver level, Event devices are represented by a generic data structure of type <em>rte_event_dev</em>.</p>
<p>Event devices are dynamically registered during the PCI/SoC device probing phase performed at EAL initialization time. When an Event device is being probed, a <em>rte_event_dev</em> structure and a new device identifier are allocated for that device. Then, the event_dev_init() function supplied by the Event driver matching the probed device is invoked to properly initialize the device.</p>
<p>The role of the device init function consists of resetting the hardware or software event driver implementations.</p>
<p>If the device init operation is successful, the correspondence between the device identifier assigned to the new device and its associated <em>rte_event_dev</em> structure is effectively registered. Otherwise, both the <em>rte_event_dev</em> structure and the device identifier are freed.</p>
<p>The functions exported by the application Event API to setup a device designated by its device identifier must be invoked in the following order:</p><ul>
<li><a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure()</a></li>
<li><a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a></li>
<li><a class="el" href="rte__eventdev_8h.html#ac087670e6e885abcdf046c8e74844cd4">rte_event_port_setup()</a></li>
<li><a class="el" href="rte__eventdev_8h.html#a27f0abd90e6784a4dc1c4f07ece2715a">rte_event_port_link()</a></li>
<li><a class="el" href="rte__eventdev_8h.html#ab6e99f06a45adaa095b257b93ebaf201">rte_event_dev_start()</a></li>
</ul>
<p>Then, the application can invoke, in any order, the functions exported by the Event API to schedule events, dequeue events, enqueue events, change event queue(s) to event port [un]link establishment and so on.</p>
<p>Application may use rte_event_[queue/port]_default_conf_get() to get the default configuration to set up an event queue or event port by overriding few default values.</p>
<p>If the application wants to change the configuration (i.e. call <a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure()</a>, <a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a>, or <a class="el" href="rte__eventdev_8h.html#ac087670e6e885abcdf046c8e74844cd4">rte_event_port_setup()</a>), it must call <a class="el" href="rte__eventdev_8h.html#a644f6cc4ab24a5c07bfff9b0f5c42e8e">rte_event_dev_stop()</a> first to stop the device and then do the reconfiguration before calling <a class="el" href="rte__eventdev_8h.html#ab6e99f06a45adaa095b257b93ebaf201">rte_event_dev_start()</a> again. The schedule, enqueue and dequeue functions should not be invoked when the device is stopped.</p>
<p>Finally, an application can close an Event device by invoking the <a class="el" href="rte__eventdev_8h.html#af70f4ed704d89a4ffce3b4c105bac076">rte_event_dev_close()</a> function.</p>
<p>Each function of the application Event API invokes a specific function of the PMD that controls the target device designated by its device identifier.</p>
<p>For this purpose, all device-specific functions of an Event driver are supplied through a set of pointers contained in a generic structure of type <em>event_dev_ops</em>. The address of the <em>event_dev_ops</em> structure is stored in the <em>rte_event_dev</em> structure by the device init function of the Event driver, which is invoked during the PCI/SoC device probing phase, as explained earlier.</p>
<p>In other words, each function of the Event API simply retrieves the <em>rte_event_dev</em> structure associated with the device identifier and performs an indirect invocation of the corresponding driver function supplied in the <em>event_dev_ops</em> structure of the <em>rte_event_dev</em> structure.</p>
<p>For performance reasons, the address of the fast-path functions of the Event driver is not contained in the <em>event_dev_ops</em> structure. Instead, they are directly stored at the beginning of the <em>rte_event_dev</em> structure to avoid an extra indirect memory access during their invocation.</p>
<p>RTE event device drivers do not use interrupts for enqueue or dequeue operation. Instead, Event drivers export Poll-Mode enqueue and dequeue functions to applications.</p>
<p>The events are injected to event device through <em>enqueue</em> operation by event producers in the system. The typical event producers are ethdev subsystem for generating packet events, CPU(SW) for generating events based on different stages of application processing, cryptodev for generating crypto work completion notification etc</p>
<p>The <em>dequeue</em> operation gets one or more events from the event ports. The application process the events and send to downstream event queue through <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> if it is an intermediate stage of event processing, on the final stage, the application may use Tx adapter API for maintaining the ingress order and then send the packet/event on the wire.</p>
<p>The point at which events are scheduled to ports depends on the device. For hardware devices, scheduling occurs asynchronously without any software intervention. Software schedulers can either be distributed (each worker thread schedules events to its own port) or centralized (a dedicated thread schedules to all ports). Distributed software schedulers perform the scheduling in <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a>, whereas centralized scheduler logic need a dedicated service core for scheduling. The RTE_EVENT_DEV_CAP_DISTRIBUTED_SCHED capability flag is not set indicates the device is centralized and thus needs a dedicated scheduling thread that repeatedly calls software specific scheduling function.</p>
<p>An event driven worker thread has following typical workflow on fastpath: </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (1) {</div>
<div class="line">   <a class="code" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst</a>(...);</div>
<div class="line">   (<span class="keyword">event</span> processing)</div>
<div class="line">   <a class="code" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst</a>(...);</div>
<div class="line">}</div>
<div class="ttc" id="arte__eventdev_8h_html_a2af1610d3ede24979267333cf2da1aab"><div class="ttname"><a href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst</a></div><div class="ttdeci">static uint16_t rte_event_dequeue_burst(uint8_t dev_id, uint8_t port_id, struct rte_event ev[], uint16_t nb_events, uint64_t timeout_ticks)</div><div class="ttdef"><b>Definition:</b> <a href="rte__eventdev_8h_source.html#l02392">rte_eventdev.h:2392</a></div></div>
<div class="ttc" id="arte__eventdev_8h_html_afc6b7f3fd1b11858a2db91864708f9a4"><div class="ttname"><a href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst</a></div><div class="ttdeci">static uint16_t rte_event_enqueue_burst(uint8_t dev_id, uint8_t port_id, const struct rte_event ev[], uint16_t nb_events)</div><div class="ttdef"><b>Definition:</b> <a href="rte__eventdev_8h_source.html#l02211">rte_eventdev.h:2211</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition in file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="acd8e2def7069ede68d5d37031323f952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8e2def7069ede68d5d37031323f952">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_QUEUE_QOS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_QUEUE_QOS&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event scheduling prioritization is based on the priority and weight associated with each event queue. Events from a queue with highest priority is scheduled first. If the queues are of same priority, weight of the queues are considered to select a queue in a weighted round robin fashion. Subsequent dequeue calls from an event port could see events from the same event queue, if the queue is configured with an affinity count. Affinity count is the number of subsequent dequeue calls, in which an event port should use the same event queue if the queue is non-empty</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a>, <a class="el" href="rte__eventdev_8h.html#a1749bc088a0f3077fadf9a524426b59f">rte_event_queue_attr_set()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00235">235</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="aeba3fa8f6c8170889356bdf893ec3183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba3fa8f6c8170889356bdf893ec3183">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_EVENT_QOS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_EVENT_QOS&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event scheduling prioritization is based on the priority associated with each event. Priority of each event is supplied in <em><a class="el" href="structrte__event.html">rte_event</a></em> structure on each enqueue operation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00242">242</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="af5d3efc148e69c47d8bfb16c71a7f72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d3efc148e69c47d8bfb16c71a7f72d">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_DISTRIBUTED_SCHED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_DISTRIBUTED_SCHED&#160;&#160;&#160;(1ULL &lt;&lt; 2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event device operates in distributed scheduling mode. In distributed scheduling mode, event scheduling happens in HW or <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> or the combination of these two. If the flag is not set then eventdev is centralized and thus needs a dedicated service core that acts as a scheduling thread .</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00251">251</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a74409c333b42420f7fb085ac79509a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74409c333b42420f7fb085ac79509a03">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_QUEUE_ALL_TYPES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_QUEUE_ALL_TYPES&#160;&#160;&#160;(1ULL &lt;&lt; 3)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event device is capable of enqueuing events of any type to any queue. If this capability is not set, the queue only supports events of the <em>RTE_SCHED_TYPE_</em> type that it was created with.</p>
<dl class="section see"><dt>See also</dt><dd>RTE_SCHED_TYPE_* values </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00258">258</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ae64cc76b136d54ca0c86332ed3723b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64cc76b136d54ca0c86332ed3723b15">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_BURST_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_BURST_MODE&#160;&#160;&#160;(1ULL &lt;&lt; 4)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event device is capable of operating in burst mode for enqueue(forward, release) and dequeue operation. If this capability is not set, application still uses the <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> and <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> but PMD accepts only one event at a time.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00266">266</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a4b1353d48908ed22912d8cdeee018ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1353d48908ed22912d8cdeee018ae0">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_IMPLICIT_RELEASE_DISABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_IMPLICIT_RELEASE_DISABLE&#160;&#160;&#160;(1ULL &lt;&lt; 5)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event device ports support disabling the implicit release feature, in which the port will release all unreleased events in its dequeue operation. If this capability is set and the port is configured with implicit release disabled, the application is responsible for explicitly releasing events using either the RTE_EVENT_OP_FORWARD or the RTE_EVENT_OP_RELEASE event enqueue operations.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00276">276</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a6be33f24673d26d71a3695dfd62623fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be33f24673d26d71a3695dfd62623fa">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_NONSEQ_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_NONSEQ_MODE&#160;&#160;&#160;(1ULL &lt;&lt; 6)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event device is capable of operating in none sequential mode. The path of the event is not necessary to be sequential. Application can change the path of event at runtime. If the flag is not set, then event each event will follow a path from queue 0 to queue 1 to queue 2 etc. If the flag is set, events may be sent to queues in any order. If the flag is not set, the eventdev will return an error when the application enqueues an event for a qid which is not the next in the sequence. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00286">286</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a2706ca7f81fc820e297b99e0e8c2583e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2706ca7f81fc820e297b99e0e8c2583e">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_RUNTIME_PORT_LINK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_RUNTIME_PORT_LINK&#160;&#160;&#160;(1ULL &lt;&lt; 7)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event device is capable of configuring the queue/port link at runtime. If the flag is not set, the eventdev queue/port link is only can be configured during initialization. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00292">292</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="affa865eedbbd9dac71ac37321fa63ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa865eedbbd9dac71ac37321fa63ac8">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_MULTIPLE_QUEUE_PORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_MULTIPLE_QUEUE_PORT&#160;&#160;&#160;(1ULL &lt;&lt; 8)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event device is capable of setting up the link between multiple queue with single port. If the flag is not set, the eventdev can only map a single queue to each port or map a single queue to many port. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00298">298</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a49215a9464a6825173251862149abab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49215a9464a6825173251862149abab4">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_CARRY_FLOW_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_CARRY_FLOW_ID&#160;&#160;&#160;(1ULL &lt;&lt; 9)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event device preserves the flow ID from the enqueued event to the dequeued event if the flag is set. Otherwise, the content of this field is implementation dependent. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00304">304</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ad6fbffafa7e06b1a005f2f6bdedf8532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6fbffafa7e06b1a005f2f6bdedf8532">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_MAINTENANCE_FREE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_MAINTENANCE_FREE&#160;&#160;&#160;(1ULL &lt;&lt; 10)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event device <em>does not</em> require calls to <a class="el" href="rte__eventdev_8h.html#aa0ce3e169d572451634dd050efcc7dfb">rte_event_maintain()</a>. An event device that does not set this flag requires calls to <a class="el" href="rte__eventdev_8h.html#aa0ce3e169d572451634dd050efcc7dfb">rte_event_maintain()</a> during periods when neither <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> nor <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> are called on a port. This will allow the event device to perform internal processing, such as flushing buffered events, return credits to a global pool, or process signaling related to load balancing. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00314">314</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="aadd334dbc86d81cf06f91fc1530987cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd334dbc86d81cf06f91fc1530987cc">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_RUNTIME_QUEUE_ATTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_RUNTIME_QUEUE_ATTR&#160;&#160;&#160;(1ULL &lt;&lt; 11)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event device is capable of changing the queue attributes at runtime i.e after <a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a> or rte_event_start() call sequence. If this flag is not set, eventdev queue attributes can only be configured during <a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a>. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00321">321</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a9b9a2569988d23fdeebae6acca1ce7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9a2569988d23fdeebae6acca1ce7e1">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_PROFILE_LINK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_PROFILE_LINK&#160;&#160;&#160;(1ULL &lt;&lt; 12)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event device is capable of supporting multiple link profiles per event port i.e., the value of <code><a class="el" href="structrte__event__dev__info.html#a728b1e0b57155ca94b52170e65b42b7e">rte_event_dev_info::max_profiles_per_port</a></code> is greater than one. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00327">327</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a7a89072eb7078f8be0f9b0c2642e34ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a89072eb7078f8be0f9b0c2642e34ef">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_PRIORITY_HIGHEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_PRIORITY_HIGHEST&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Highest priority expressed across eventdev subsystem </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a>, <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> </dd>
<dd>
<a class="el" href="rte__eventdev_8h.html#a27f0abd90e6784a4dc1c4f07ece2715a">rte_event_port_link()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00334">334</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a0110e34375b970cb883979a3c489e5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0110e34375b970cb883979a3c489e5c5">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_PRIORITY_NORMAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_PRIORITY_NORMAL&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Normal priority expressed across eventdev subsystem </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a>, <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> </dd>
<dd>
<a class="el" href="rte__eventdev_8h.html#a27f0abd90e6784a4dc1c4f07ece2715a">rte_event_port_link()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00339">339</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="aba559138ff70b32510631ad1ce5b8da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba559138ff70b32510631ad1ce5b8da5">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_PRIORITY_LOWEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_PRIORITY_LOWEST&#160;&#160;&#160;255</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lowest priority expressed across eventdev subsystem </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a>, <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> </dd>
<dd>
<a class="el" href="rte__eventdev_8h.html#a27f0abd90e6784a4dc1c4f07ece2715a">rte_event_port_link()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00344">344</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a22bf321656bc4a3921385dcb2eca5766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bf321656bc4a3921385dcb2eca5766">&#9670;&nbsp;</a></span>RTE_EVENT_QUEUE_WEIGHT_HIGHEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_QUEUE_WEIGHT_HIGHEST&#160;&#160;&#160;255</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Highest weight of an event queue </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a9f6d7fa11b04003ff32884d83ae04960">rte_event_queue_attr_get()</a>, <a class="el" href="rte__eventdev_8h.html#a1749bc088a0f3077fadf9a524426b59f">rte_event_queue_attr_set()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00350">350</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a121794eca66dc8700f40299e9c21cc7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121794eca66dc8700f40299e9c21cc7a">&#9670;&nbsp;</a></span>RTE_EVENT_QUEUE_WEIGHT_LOWEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_QUEUE_WEIGHT_LOWEST&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lowest weight of an event queue </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a9f6d7fa11b04003ff32884d83ae04960">rte_event_queue_attr_get()</a>, <a class="el" href="rte__eventdev_8h.html#a1749bc088a0f3077fadf9a524426b59f">rte_event_queue_attr_set()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00354">354</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a941b7ed39c32fb59127a2ebfa8c83b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941b7ed39c32fb59127a2ebfa8c83b23">&#9670;&nbsp;</a></span>RTE_EVENT_QUEUE_AFFINITY_HIGHEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_QUEUE_AFFINITY_HIGHEST&#160;&#160;&#160;255</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Highest scheduling affinity of an event queue </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a9f6d7fa11b04003ff32884d83ae04960">rte_event_queue_attr_get()</a>, <a class="el" href="rte__eventdev_8h.html#a1749bc088a0f3077fadf9a524426b59f">rte_event_queue_attr_set()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00360">360</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a65ccba1d3f7e99dd75352e578f2cd5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ccba1d3f7e99dd75352e578f2cd5e2">&#9670;&nbsp;</a></span>RTE_EVENT_QUEUE_AFFINITY_LOWEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_QUEUE_AFFINITY_LOWEST&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lowest scheduling affinity of an event queue </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a9f6d7fa11b04003ff32884d83ae04960">rte_event_queue_attr_get()</a>, <a class="el" href="rte__eventdev_8h.html#a1749bc088a0f3077fadf9a524426b59f">rte_event_queue_attr_set()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00364">364</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="af6e175391c335d69f4f488f0a8a08f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e175391c335d69f4f488f0a8a08f69">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_ATTR_PORT_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_ATTR_PORT_COUNT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The count of ports. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00481">481</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a346e82537d965576cfa4642da7ae66b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346e82537d965576cfa4642da7ae66b2">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_ATTR_QUEUE_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_ATTR_QUEUE_COUNT&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The count of queues. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00485">485</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a7dd45d7b76782e02927ea966bd2d27b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd45d7b76782e02927ea966bd2d27b1">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_ATTR_STARTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_ATTR_STARTED&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The status of the device, zero for stopped, non-zero for started. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00489">489</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="aedc71a4c2e35b5b23fe6fcf593c5909a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc71a4c2e35b5b23fe6fcf593c5909a">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CFG_PER_DEQUEUE_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CFG_PER_DEQUEUE_TIMEOUT&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Override the global <em>dequeue_timeout_ns</em> and use per dequeue timeout in ns. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a245cbc6e55632565a57f6f98f492428f">rte_event_dequeue_timeout_ticks()</a>, <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00512">512</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a6b417a1b2250685f2b583aa30a259241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b417a1b2250685f2b583aa30a259241">&#9670;&nbsp;</a></span>RTE_EVENT_QUEUE_CFG_ALL_TYPES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_QUEUE_CFG_ALL_TYPES&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allow ATOMIC,ORDERED,PARALLEL schedule type enqueue</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a366ab13bc5be32cbc9ee15e294b4c9a2">RTE_SCHED_TYPE_ORDERED</a>, <a class="el" href="rte__eventdev_8h.html#a3c199a28e97411266a069bd07c9757fa">RTE_SCHED_TYPE_ATOMIC</a>, <a class="el" href="rte__eventdev_8h.html#ac88982845a12ff215c721fccb18ed4a7">RTE_SCHED_TYPE_PARALLEL</a> </dd>
<dd>
<a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00606">606</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a3b0d54b104105e6f861c6e41b0ca3f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0d54b104105e6f861c6e41b0ca3f9f">&#9670;&nbsp;</a></span>RTE_EVENT_QUEUE_CFG_SINGLE_LINK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_QUEUE_CFG_SINGLE_LINK&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This event queue links only to a single event port.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#ac087670e6e885abcdf046c8e74844cd4">rte_event_port_setup()</a>, <a class="el" href="rte__eventdev_8h.html#a27f0abd90e6784a4dc1c4f07ece2715a">rte_event_port_link()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00611">611</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a6b359fd06e58898590f9b5f3b8011f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b359fd06e58898590f9b5f3b8011f4a">&#9670;&nbsp;</a></span>RTE_EVENT_QUEUE_ATTR_PRIORITY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_QUEUE_ATTR_PRIORITY&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The priority of the queue. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00720">720</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ad5f614827b00ced79a709be7b627e54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f614827b00ced79a709be7b627e54c">&#9670;&nbsp;</a></span>RTE_EVENT_QUEUE_ATTR_NB_ATOMIC_FLOWS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_QUEUE_ATTR_NB_ATOMIC_FLOWS&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of atomic flows configured for the queue. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00724">724</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a115b78b02fc98a801bc62dd916ac9cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115b78b02fc98a801bc62dd916ac9cf6">&#9670;&nbsp;</a></span>RTE_EVENT_QUEUE_ATTR_NB_ATOMIC_ORDER_SEQUENCES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_QUEUE_ATTR_NB_ATOMIC_ORDER_SEQUENCES&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of atomic order sequences configured for the queue. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00728">728</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a0d0ec3e9f90f3228a3ce31a548bed490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0ec3e9f90f3228a3ce31a548bed490">&#9670;&nbsp;</a></span>RTE_EVENT_QUEUE_ATTR_EVENT_QUEUE_CFG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_QUEUE_ATTR_EVENT_QUEUE_CFG&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The cfg flags for the queue. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00732">732</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a5fe4b0cd9c9643f681b461938110156a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe4b0cd9c9643f681b461938110156a">&#9670;&nbsp;</a></span>RTE_EVENT_QUEUE_ATTR_SCHEDULE_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_QUEUE_ATTR_SCHEDULE_TYPE&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The schedule type of the queue. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00736">736</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a2591817922f4511b62ee7635067c7e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2591817922f4511b62ee7635067c7e18">&#9670;&nbsp;</a></span>RTE_EVENT_QUEUE_ATTR_WEIGHT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_QUEUE_ATTR_WEIGHT&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The weight of the queue. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00740">740</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a868d382567beeba509263e70141aacd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868d382567beeba509263e70141aacd9">&#9670;&nbsp;</a></span>RTE_EVENT_QUEUE_ATTR_AFFINITY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_QUEUE_ATTR_AFFINITY&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Affinity of the queue. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00744">744</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="afbc5d49a30616703a0f27f0c66f9b2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc5d49a30616703a0f27f0c66f9b2ca">&#9670;&nbsp;</a></span>RTE_EVENT_PORT_CFG_DISABLE_IMPL_REL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_PORT_CFG_DISABLE_IMPL_REL&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure the port not to release outstanding events in rte_event_dev_dequeue_burst(). If set, all events received through the port must be explicitly released with RTE_EVENT_OP_RELEASE or RTE_EVENT_OP_FORWARD. Must be unset if the device is not RTE_EVENT_DEV_CAP_IMPLICIT_RELEASE_DISABLE capable. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00801">801</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="aafb50136dfac62bd29ddce2429b6c885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb50136dfac62bd29ddce2429b6c885">&#9670;&nbsp;</a></span>RTE_EVENT_PORT_CFG_SINGLE_LINK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_PORT_CFG_SINGLE_LINK&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This event port links only to a single event queue.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#ac087670e6e885abcdf046c8e74844cd4">rte_event_port_setup()</a>, <a class="el" href="rte__eventdev_8h.html#a27f0abd90e6784a4dc1c4f07ece2715a">rte_event_port_link()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00806">806</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a303abf06e3b4ac807137f8ff44cb3239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303abf06e3b4ac807137f8ff44cb3239">&#9670;&nbsp;</a></span>RTE_EVENT_PORT_CFG_HINT_PRODUCER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_PORT_CFG_HINT_PRODUCER&#160;&#160;&#160;(1ULL &lt;&lt; 2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hint that this event port will primarily enqueue events to the system. A PMD can optimize its internal workings by assuming that this port is primarily going to enqueue NEW events.</p>
<p>Note that this flag is only a hint, so PMDs must operate under the assumption that any port can enqueue an event with any type of op.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#ac087670e6e885abcdf046c8e74844cd4">rte_event_port_setup()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00816">816</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="aea09ff1e5833262f5cf1d378b30b58a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea09ff1e5833262f5cf1d378b30b58a4">&#9670;&nbsp;</a></span>RTE_EVENT_PORT_CFG_HINT_CONSUMER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_PORT_CFG_HINT_CONSUMER&#160;&#160;&#160;(1ULL &lt;&lt; 3)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hint that this event port will primarily dequeue events from the system. A PMD can optimize its internal workings by assuming that this port is primarily going to consume events, and not enqueue FORWARD or RELEASE events.</p>
<p>Note that this flag is only a hint, so PMDs must operate under the assumption that any port can enqueue an event with any type of op.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#ac087670e6e885abcdf046c8e74844cd4">rte_event_port_setup()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00827">827</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="add95e5b5732a00fd99b431d0a570209d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add95e5b5732a00fd99b431d0a570209d">&#9670;&nbsp;</a></span>RTE_EVENT_PORT_CFG_HINT_WORKER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_PORT_CFG_HINT_WORKER&#160;&#160;&#160;(1ULL &lt;&lt; 4)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hint that this event port will primarily pass existing events through. A PMD can optimize its internal workings by assuming that this port is primarily going to FORWARD events, and not enqueue NEW or RELEASE events often.</p>
<p>Note that this flag is only a hint, so PMDs must operate under the assumption that any port can enqueue an event with any type of op.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#ac087670e6e885abcdf046c8e74844cd4">rte_event_port_setup()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00838">838</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a40fc8695cb074e656ab5eadf286b0f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40fc8695cb074e656ab5eadf286b0f08">&#9670;&nbsp;</a></span>RTE_EVENT_PORT_ATTR_ENQ_DEPTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_PORT_ATTR_ENQ_DEPTH&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The queue depth of the port on the enqueue side </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00957">957</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="afcd80caf495a4624fa213cc2330c8923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd80caf495a4624fa213cc2330c8923">&#9670;&nbsp;</a></span>RTE_EVENT_PORT_ATTR_DEQ_DEPTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_PORT_ATTR_DEQ_DEPTH&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The queue depth of the port on the dequeue side </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00961">961</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a60a28fba179c8b08f42eaab7f3683a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a28fba179c8b08f42eaab7f3683a39">&#9670;&nbsp;</a></span>RTE_EVENT_PORT_ATTR_NEW_EVENT_THRESHOLD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_PORT_ATTR_NEW_EVENT_THRESHOLD&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The new event threshold of the port </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00965">965</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="aebf25098a79d7e3ad4fd936737808a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf25098a79d7e3ad4fd936737808a9f">&#9670;&nbsp;</a></span>RTE_EVENT_PORT_ATTR_IMPLICIT_RELEASE_DISABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_PORT_ATTR_IMPLICIT_RELEASE_DISABLE&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The implicit release disable attribute of the port </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00969">969</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a366ab13bc5be32cbc9ee15e294b4c9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366ab13bc5be32cbc9ee15e294b4c9a2">&#9670;&nbsp;</a></span>RTE_SCHED_TYPE_ORDERED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_SCHED_TYPE_ORDERED&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ordered scheduling</p>
<p>Events from an ordered flow of an event queue can be scheduled to multiple ports for concurrent processing while maintaining the original event order. This scheme enables the user to achieve high single flow throughput by avoiding SW synchronization for ordering between ports which bound to cores.</p>
<p>The source flow ordering from an event queue is maintained when events are enqueued to their destination queue within the same ordered flow context. An event port holds the context until application call <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> from the same port, which implicitly releases the context. User may allow the scheduler to release the context earlier than that by invoking <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> with RTE_EVENT_OP_RELEASE operation.</p>
<p>Events from the source queue appear in their original order when dequeued from a destination queue. Event ordering is based on the received event(s), but also other (newly allocated or stored) events are ordered when enqueued within the same ordered context. Events not enqueued (e.g. released or stored) within the context are considered missing from reordering and are skipped at this time (but can be ordered again within another context).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a>, <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a>, <a class="el" href="rte__eventdev_8h.html#ab927860cf68a0c0a8caf96fe9feb2a23">RTE_EVENT_OP_RELEASE</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01161">1161</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a3c199a28e97411266a069bd07c9757fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c199a28e97411266a069bd07c9757fa">&#9670;&nbsp;</a></span>RTE_SCHED_TYPE_ATOMIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_SCHED_TYPE_ATOMIC&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomic scheduling</p>
<p>Events from an atomic flow of an event queue can be scheduled only to a single port at a time. The port is guaranteed to have exclusive (atomic) access to the associated flow context, which enables the user to avoid SW synchronization. Atomic flows also help to maintain event ordering since only one port at a time can process events from a flow of an event queue.</p>
<p>The atomic queue synchronization context is dedicated to the port until application call <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> from the same port, which implicitly releases the context. User may allow the scheduler to release the context earlier than that by invoking <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> with RTE_EVENT_OP_RELEASE operation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a>, <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a>, <a class="el" href="rte__eventdev_8h.html#ab927860cf68a0c0a8caf96fe9feb2a23">RTE_EVENT_OP_RELEASE</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01180">1180</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ac88982845a12ff215c721fccb18ed4a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88982845a12ff215c721fccb18ed4a7">&#9670;&nbsp;</a></span>RTE_SCHED_TYPE_PARALLEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_SCHED_TYPE_PARALLEL&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parallel scheduling</p>
<p>The scheduler performs priority scheduling, load balancing, etc. functions but does not provide additional event synchronization or ordering. It is free to schedule events from a single parallel flow of an event queue to multiple events ports for concurrent processing. The application is responsible for flow context synchronization and event ordering (SW synchronization).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a>, <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01193">1193</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ae5a711c45b3d3f125069b1a7cb731435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a711c45b3d3f125069b1a7cb731435">&#9670;&nbsp;</a></span>RTE_EVENT_TYPE_ETHDEV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TYPE_ETHDEV&#160;&#160;&#160;0x0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event generated from ethdev subsystem </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01197">1197</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a982ad2bf50bd73e7cdbe2a62e5d581f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982ad2bf50bd73e7cdbe2a62e5d581f6">&#9670;&nbsp;</a></span>RTE_EVENT_TYPE_CRYPTODEV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TYPE_CRYPTODEV&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event generated from crypodev subsystem </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01199">1199</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a247d3e6500516ff097e06f199dfb5cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247d3e6500516ff097e06f199dfb5cc3">&#9670;&nbsp;</a></span>RTE_EVENT_TYPE_TIMER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TYPE_TIMER&#160;&#160;&#160;0x2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event generated from event timer adapter </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01201">1201</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ac15be67634b343dc7dc7b6d63630abdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15be67634b343dc7dc7b6d63630abdd">&#9670;&nbsp;</a></span>RTE_EVENT_TYPE_CPU</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TYPE_CPU&#160;&#160;&#160;0x3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event generated from cpu for pipelining. Application may use <em>sub_event_type</em> to further classify the event </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01205">1205</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a934df8149a7a1a4cfcdbb18a880d837c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934df8149a7a1a4cfcdbb18a880d837c">&#9670;&nbsp;</a></span>RTE_EVENT_TYPE_ETH_RX_ADAPTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TYPE_ETH_RX_ADAPTER&#160;&#160;&#160;0x4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event generated from event eth Rx adapter </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01207">1207</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="add86bf2aa79f073ef45307d022bc5cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add86bf2aa79f073ef45307d022bc5cc2">&#9670;&nbsp;</a></span>RTE_EVENT_TYPE_DMADEV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TYPE_DMADEV&#160;&#160;&#160;0x5</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event generated from dma subsystem </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01209">1209</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a6c0feebd419e446783c98600a0f683c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c0feebd419e446783c98600a0f683c3">&#9670;&nbsp;</a></span>RTE_EVENT_TYPE_VECTOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TYPE_VECTOR&#160;&#160;&#160;0x8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that event is a vector. All vector event types should be a logical OR of EVENT_TYPE_VECTOR. This simplifies the pipeline design as one can split processing the events between vector events and normal event across event types. Example: if (ev.event_type &amp; RTE_EVENT_TYPE_VECTOR) { // Classify and handle vector event. } else { // Classify and handle event. } </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01221">1221</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a13c4a69d989950af3cb5525a16812d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c4a69d989950af3cb5525a16812d09">&#9670;&nbsp;</a></span>RTE_EVENT_TYPE_ETHDEV_VECTOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TYPE_ETHDEV_VECTOR&#160;&#160;&#160;	(<a class="el" href="rte__eventdev_8h.html#a6c0feebd419e446783c98600a0f683c3">RTE_EVENT_TYPE_VECTOR</a> | <a class="el" href="rte__eventdev_8h.html#ae5a711c45b3d3f125069b1a7cb731435">RTE_EVENT_TYPE_ETHDEV</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event vector generated from ethdev subsystem </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01224">1224</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a07a506b7019a0d71d0422725ad9379b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a506b7019a0d71d0422725ad9379b4">&#9670;&nbsp;</a></span>RTE_EVENT_TYPE_CPU_VECTOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TYPE_CPU_VECTOR&#160;&#160;&#160;(<a class="el" href="rte__eventdev_8h.html#a6c0feebd419e446783c98600a0f683c3">RTE_EVENT_TYPE_VECTOR</a> | <a class="el" href="rte__eventdev_8h.html#ac15be67634b343dc7dc7b6d63630abdd">RTE_EVENT_TYPE_CPU</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event vector generated from cpu for pipelining. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01226">1226</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a2c4933c73c89694a3b085cf283f74fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4933c73c89694a3b085cf283f74fa7">&#9670;&nbsp;</a></span>RTE_EVENT_TYPE_ETH_RX_ADAPTER_VECTOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TYPE_ETH_RX_ADAPTER_VECTOR&#160;&#160;&#160;	(<a class="el" href="rte__eventdev_8h.html#a6c0feebd419e446783c98600a0f683c3">RTE_EVENT_TYPE_VECTOR</a> | <a class="el" href="rte__eventdev_8h.html#a934df8149a7a1a4cfcdbb18a880d837c">RTE_EVENT_TYPE_ETH_RX_ADAPTER</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event vector generated from eth Rx adapter. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01229">1229</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a41470ca6deb51e17db09b70b97a0ed4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41470ca6deb51e17db09b70b97a0ed4c">&#9670;&nbsp;</a></span>RTE_EVENT_TYPE_CRYPTODEV_VECTOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TYPE_CRYPTODEV_VECTOR&#160;&#160;&#160;	(<a class="el" href="rte__eventdev_8h.html#a6c0feebd419e446783c98600a0f683c3">RTE_EVENT_TYPE_VECTOR</a> | <a class="el" href="rte__eventdev_8h.html#a982ad2bf50bd73e7cdbe2a62e5d581f6">RTE_EVENT_TYPE_CRYPTODEV</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event vector generated from cryptodev adapter. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01232">1232</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a351dba845f2d001f6245fd41692d8c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351dba845f2d001f6245fd41692d8c9e">&#9670;&nbsp;</a></span>RTE_EVENT_TYPE_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TYPE_MAX&#160;&#160;&#160;0x10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of event types </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01235">1235</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="aa69a0db3e4653c786aef1febe7594b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69a0db3e4653c786aef1febe7594b78">&#9670;&nbsp;</a></span>RTE_EVENT_OP_NEW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_OP_NEW&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event producers use this operation to inject a new event to the event device. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01241">1241</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a416488eee18e9e740dba1c61a312f06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416488eee18e9e740dba1c61a312f06a">&#9670;&nbsp;</a></span>RTE_EVENT_OP_FORWARD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_OP_FORWARD&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The CPU use this operation to forward the event to different event queue or change to new application specific flow or schedule type to enable pipelining.</p>
<p>This operation must only be enqueued to the same port that the event to be forwarded was dequeued from. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01249">1249</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ab927860cf68a0c0a8caf96fe9feb2a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab927860cf68a0c0a8caf96fe9feb2a23">&#9670;&nbsp;</a></span>RTE_EVENT_OP_RELEASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_OP_RELEASE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release the flow context associated with the schedule type.</p>
<p>If current flow's scheduler type method is <em>RTE_SCHED_TYPE_ATOMIC</em> then this function hints the scheduler that the user has completed critical section processing in the current atomic context. The scheduler is now allowed to schedule events from the same flow from an event queue to another port. However, the context may be still held until the next <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> call, this call allows but does not force the scheduler to release the context early.</p>
<p>Early atomic context release may increase parallelism and thus system performance, but the user needs to design carefully the split into critical vs non-critical sections.</p>
<p>If current flow's scheduler type method is <em>RTE_SCHED_TYPE_ORDERED</em> then this function hints the scheduler that the user has done all that need to maintain event order in the current ordered context. The scheduler is allowed to release the ordered context of this port and avoid reordering any following enqueues.</p>
<p>Early ordered context release may increase parallelism and thus system performance.</p>
<p>If current flow's scheduler type method is <em>RTE_SCHED_TYPE_PARALLEL</em> or no scheduling context is held then this function may be an NOOP, depending on the implementation.</p>
<p>This operation must only be enqueued to the same port that the event to be released was dequeued from. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01280">1280</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a0938b6c89c22b3de3ee9e8bfa1da2ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0938b6c89c22b3de3ee9e8bfa1da2ae7">&#9670;&nbsp;</a></span>RTE_EVENT_ETH_RX_ADAPTER_CAP_INTERNAL_PORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_ETH_RX_ADAPTER_CAP_INTERNAL_PORT&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This flag is sent when the packet transfer mechanism is in HW. Ethdev can send packets to the event device using internal event port. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01363">1363</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ac3abde85e981790ae41c69ad7df33b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3abde85e981790ae41c69ad7df33b75">&#9670;&nbsp;</a></span>RTE_EVENT_ETH_RX_ADAPTER_CAP_MULTI_EVENTQ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_ETH_RX_ADAPTER_CAP_MULTI_EVENTQ&#160;&#160;&#160;0x2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adapter supports multiple event queues per ethdev. Every ethdev Rx queue can be connected to a unique event queue. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01367">1367</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a8d39c45789a6d8c808b08c57057f715c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d39c45789a6d8c808b08c57057f715c">&#9670;&nbsp;</a></span>RTE_EVENT_ETH_RX_ADAPTER_CAP_OVERRIDE_FLOW_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_ETH_RX_ADAPTER_CAP_OVERRIDE_FLOW_ID&#160;&#160;&#160;0x4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The application can override the adapter generated flow ID in the event. This flow ID can be specified when adding an ethdev Rx queue to the adapter using the ev.flow_id member. </p><dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__event__eth__rx__adapter__queue__conf.html#ace15ae1b604b29456e25bfb3f73fbc8a">rte_event_eth_rx_adapter_queue_conf::ev</a> </dd>
<dd>
struct <a class="el" href="structrte__event__eth__rx__adapter__queue__conf.html#a10784c91ca56bcc794c9cbe05eeb6499">rte_event_eth_rx_adapter_queue_conf::rx_queue_flags</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01374">1374</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a7d399c8c2290059cbf38cad80ce3bcab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d399c8c2290059cbf38cad80ce3bcab">&#9670;&nbsp;</a></span>RTE_EVENT_ETH_RX_ADAPTER_CAP_EVENT_VECTOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_ETH_RX_ADAPTER_CAP_EVENT_VECTOR&#160;&#160;&#160;0x8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adapter supports event vectorization per ethdev. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01376">1376</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="aee3ed17910cfdeb061734fe14f9651fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3ed17910cfdeb061734fe14f9651fc">&#9670;&nbsp;</a></span>RTE_EVENT_TIMER_ADAPTER_CAP_INTERNAL_PORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TIMER_ADAPTER_CAP_INTERNAL_PORT&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This flag is set when the timer mechanism is in HW. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01401">1401</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ac9a05105d3e7f16cce2776408571e1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a05105d3e7f16cce2776408571e1a2">&#9670;&nbsp;</a></span>RTE_EVENT_TIMER_ADAPTER_CAP_PERIODIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TIMER_ADAPTER_CAP_PERIODIC&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This flag is set if periodic mode is supported. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01404">1404</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a832fc0958c7dedc25a4c294d7bc08c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832fc0958c7dedc25a4c294d7bc08c48">&#9670;&nbsp;</a></span>RTE_EVENT_CRYPTO_ADAPTER_CAP_INTERNAL_PORT_OP_NEW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_CRYPTO_ADAPTER_CAP_INTERNAL_PORT_OP_NEW&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag indicates HW is capable of generating events in RTE_EVENT_OP_NEW enqueue operation. Cryptodev will send packets to the event device as new events using an internal event port. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01428">1428</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="aafffb3091cacef210c8710c7bb717311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafffb3091cacef210c8710c7bb717311">&#9670;&nbsp;</a></span>RTE_EVENT_CRYPTO_ADAPTER_CAP_INTERNAL_PORT_OP_FWD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_CRYPTO_ADAPTER_CAP_INTERNAL_PORT_OP_FWD&#160;&#160;&#160;0x2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag indicates HW is capable of generating events in RTE_EVENT_OP_FORWARD enqueue operation. Cryptodev will send packets to the event device as forwarded event using an internal event port. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01435">1435</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a7594e773a009ba1c9c2e19f413125893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7594e773a009ba1c9c2e19f413125893">&#9670;&nbsp;</a></span>RTE_EVENT_CRYPTO_ADAPTER_CAP_INTERNAL_PORT_QP_EV_BIND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_CRYPTO_ADAPTER_CAP_INTERNAL_PORT_QP_EV_BIND&#160;&#160;&#160;0x4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag indicates HW is capable of mapping crypto queue pair to event queue. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01440">1440</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ab07cd5e93133ab8aa760e3eb17a3b81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07cd5e93133ab8aa760e3eb17a3b81b">&#9670;&nbsp;</a></span>RTE_EVENT_CRYPTO_ADAPTER_CAP_SESSION_PRIVATE_DATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_CRYPTO_ADAPTER_CAP_SESSION_PRIVATE_DATA&#160;&#160;&#160;0x8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag indicates HW/SW supports a mechanism to store and retrieve the private data information along with the crypto session. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01445">1445</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="aea81dcf3d4f9b7f9b2d89bb88fec88bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea81dcf3d4f9b7f9b2d89bb88fec88bc">&#9670;&nbsp;</a></span>RTE_EVENT_CRYPTO_ADAPTER_CAP_EVENT_VECTOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_CRYPTO_ADAPTER_CAP_EVENT_VECTOR&#160;&#160;&#160;0x10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag indicates HW is capable of aggregating processed crypto operations into <a class="el" href="structrte__event__vector.html">rte_event_vector</a>. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01450">1450</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a11992fe6cfef96d66f9ba1272edf4b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11992fe6cfef96d66f9ba1272edf4b1a">&#9670;&nbsp;</a></span>RTE_EVENT_DMA_ADAPTER_CAP_INTERNAL_PORT_OP_NEW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DMA_ADAPTER_CAP_INTERNAL_PORT_OP_NEW&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag indicates HW is capable of generating events in RTE_EVENT_OP_NEW enqueue operation. DMADEV will send packets to the event device as new events using an internal event port. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01481">1481</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a18db40d7488a8e7d65dfb43d5a990081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18db40d7488a8e7d65dfb43d5a990081">&#9670;&nbsp;</a></span>RTE_EVENT_DMA_ADAPTER_CAP_INTERNAL_PORT_OP_FWD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DMA_ADAPTER_CAP_INTERNAL_PORT_OP_FWD&#160;&#160;&#160;0x2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag indicates HW is capable of generating events in RTE_EVENT_OP_FORWARD enqueue operation. DMADEV will send packets to the event device as forwarded event using an internal event port. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01488">1488</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a491b08bd86b63147cf2b700df58abeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491b08bd86b63147cf2b700df58abeec">&#9670;&nbsp;</a></span>RTE_EVENT_DMA_ADAPTER_CAP_INTERNAL_PORT_VCHAN_EV_BIND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DMA_ADAPTER_CAP_INTERNAL_PORT_VCHAN_EV_BIND&#160;&#160;&#160;0x4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag indicates HW is capable of mapping DMA vchan to event queue. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01491">1491</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a3b6c6cbdc5b9091cc561ab38983be324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6c6cbdc5b9091cc561ab38983be324">&#9670;&nbsp;</a></span>RTE_EVENT_ETH_TX_ADAPTER_CAP_INTERNAL_PORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_ETH_TX_ADAPTER_CAP_INTERNAL_PORT&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This flag is sent when the PMD supports a packet transmit callback </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01520">1520</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="aa53c9dc91baa6270b15b0521f6874609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53c9dc91baa6270b15b0521f6874609">&#9670;&nbsp;</a></span>RTE_EVENT_ETH_TX_ADAPTER_CAP_EVENT_VECTOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_ETH_TX_ADAPTER_CAP_EVENT_VECTOR&#160;&#160;&#160;0x2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that the Tx adapter is capable of handling event vector of mbufs. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01524">1524</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ae0248ac6e03597e9a8c57a96cd38f8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0248ac6e03597e9a8c57a96cd38f8e1">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_XSTATS_NAME_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_XSTATS_NAME_SIZE&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum name length for extended statistics counters </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01944">1944</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a9a2be1a618a0cd023313f6132765ba40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2be1a618a0cd023313f6132765ba40">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_MAINT_OP_FLUSH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_MAINT_OP_FLUSH&#160;&#160;&#160;(1 &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Force an immediately flush of any buffered events in the port, potentially at the cost of additional overhead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#aa0ce3e169d572451634dd050efcc7dfb">rte_event_maintain()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l02429">2429</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a1d624b5b4606fdaf0799c19412e30d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d624b5b4606fdaf0799c19412e30d2b">&#9670;&nbsp;</a></span>rte_eventdev_port_flush_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void(* rte_eventdev_port_flush_t) (uint8_t dev_id, struct <a class="el" href="structrte__event.html">rte_event</a> event, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function prototype that can be passed during rte_event_port_release(), invoked once per a released event. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00919">919</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a9e04cfb272018b6337d57cd49bfd405e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e04cfb272018b6337d57cd49bfd405e">&#9670;&nbsp;</a></span>rte_eventdev_stop_flush_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void(* rte_eventdev_stop_flush_t) (uint8_t dev_id, struct <a class="el" href="structrte__event.html">rte_event</a> event, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function called during <a class="el" href="rte__eventdev_8h.html#a644f6cc4ab24a5c07bfff9b0f5c42e8e">rte_event_dev_stop()</a>, invoked once per flushed event. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01031">1031</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a505adb6f39a9108c494df8070312dee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505adb6f39a9108c494df8070312dee5">&#9670;&nbsp;</a></span>rte_event_dev_xstats_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__eventdev_8h.html#a505adb6f39a9108c494df8070312dee5">rte_event_dev_xstats_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selects the component of the eventdev to retrieve statistics from. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01949">1949</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6541eb8822285c7b77455636201d5134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6541eb8822285c7b77455636201d5134">&#9670;&nbsp;</a></span>rte_event_dev_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rte_event_dev_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the total number of event devices that have been successfully initialised.</p>
<dl class="section return"><dt>Returns</dt><dd>The total number of usable event devices. </dd></dl>

</div>
</div>
<a id="a7da264acd9bd0da6795801c6568f0387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da264acd9bd0da6795801c6568f0387">&#9670;&nbsp;</a></span>rte_event_dev_get_dev_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_get_dev_id </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the device identifier for the named event device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Event device name to select the event device identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns event device identifier on success.<ul>
<li>&lt;0: Failure to find named event device. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae92ef37cd075e2db64d4f358b939c205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92ef37cd075e2db64d4f358b939c205">&#9670;&nbsp;</a></span>rte_event_dev_socket_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_socket_id </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the NUMA socket to which a device is connected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The NUMA socket id to which the device is connected or a default of zero if the socket could not be determined. -(-EINVAL) dev_id value is out of range. </dd></dl>

</div>
</div>
<a id="a5bd7355a0be9b94bbca0f32796e57358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd7355a0be9b94bbca0f32796e57358">&#9670;&nbsp;</a></span>rte_event_dev_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_info_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__event__dev__info.html">rte_event_dev_info</a> *&#160;</td>
          <td class="paramname"><em>dev_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the contextual information of an event device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dev_info</td><td>A pointer to a structure of type <em><a class="el" href="structrte__event__dev__info.html">rte_event_dev_info</a></em> to be filled with the contextual information of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, driver updates the contextual information of the event device</li>
<li>&lt;0: Error code returned by the driver info get function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a79e78537e4554caf73c13c79e8a3cd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e78537e4554caf73c13c79e8a3cd06">&#9670;&nbsp;</a></span>rte_event_dev_attr_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_attr_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attr_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>attr_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an attribute from a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>Eventdev id </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">attr_id</td><td>The attribute ID to retrieve </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">attr_value</td><td>A pointer that will be filled in with the attribute value if successful.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Successfully retrieved attribute value</li>
<li>-EINVAL: Invalid device or <em>attr_id</em> provided, or <em>attr_value</em> is NULL </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af1e7d0094442b3a158e89f120a21687d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e7d0094442b3a158e89f120a21687d">&#9670;&nbsp;</a></span>rte_event_dev_configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_configure </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__event__dev__config.html">rte_event_dev_config</a> *&#160;</td>
          <td class="paramname"><em>dev_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure an event device.</p>
<p>This function must be invoked first before any other function in the API. This function can also be re-invoked when a device is in the stopped state.</p>
<p>The caller may use <a class="el" href="rte__eventdev_8h.html#a5bd7355a0be9b94bbca0f32796e57358">rte_event_dev_info_get()</a> to get the capability of each resources available for this event device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device to configure. </td></tr>
    <tr><td class="paramname">dev_conf</td><td>The event device configuration structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, device configured.</li>
<li>&lt;0: Error code returned by the driver configuration function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a57d3f2bd3f600cdc3d8724844cbbcf20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d3f2bd3f600cdc3d8724844cbbcf20">&#9670;&nbsp;</a></span>rte_event_queue_default_conf_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_queue_default_conf_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__event__queue__conf.html">rte_event_queue_conf</a> *&#160;</td>
          <td class="paramname"><em>queue_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the default configuration information of an event queue designated by its <em>queue_id</em> from the event driver for an event device.</p>
<p>This function intended to be used in conjunction with <a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a> where caller needs to set up the queue by overriding few default values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue_id</td><td>The index of the event queue to get the configuration information. The value must be in the range [0, nb_event_queues - 1] previously supplied to <a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">queue_conf</td><td>The pointer to the default event queue configuration data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, driver updates the default event queue configuration data.</li>
<li>&lt;0: Error code returned by the driver info get function.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a> </dd></dl>

</div>
</div>
<a id="a57a1db34b6c7bb2b05a5db7aab8c6834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a1db34b6c7bb2b05a5db7aab8c6834">&#9670;&nbsp;</a></span>rte_event_queue_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_queue_setup </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__event__queue__conf.html">rte_event_queue_conf</a> *&#160;</td>
          <td class="paramname"><em>queue_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate and set up an event queue for an event device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the event queue to setup. The value must be in the range [0, nb_event_queues - 1] previously supplied to <a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">queue_conf</td><td>The pointer to the configuration data to be used for the event queue. NULL value is allowed, in which case default configuration used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a57d3f2bd3f600cdc3d8724844cbbcf20">rte_event_queue_default_conf_get()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, event queue correctly set up.</li>
<li>&lt;0: event queue configuration failed </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9f6d7fa11b04003ff32884d83ae04960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6d7fa11b04003ff32884d83ae04960">&#9670;&nbsp;</a></span>rte_event_queue_attr_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_queue_attr_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attr_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>attr_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an attribute from a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>Eventdev id </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue_id</td><td>Eventdev queue id </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">attr_id</td><td>The attribute ID to retrieve </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">attr_value</td><td>A pointer that will be filled in with the attribute value if successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Successfully returned value</li>
<li>-EINVAL: invalid device, queue or attr_id provided, or attr_value was NULL</li>
<li>-EOVERFLOW: returned when attr_id is set to RTE_EVENT_QUEUE_ATTR_SCHEDULE_TYPE and event_queue_cfg is set to RTE_EVENT_QUEUE_CFG_ALL_TYPES </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1749bc088a0f3077fadf9a524426b59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1749bc088a0f3077fadf9a524426b59f">&#9670;&nbsp;</a></span>rte_event_queue_attr_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_queue_attr_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attr_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>attr_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set an event queue attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Eventdev id </td></tr>
    <tr><td class="paramname">queue_id</td><td>Eventdev queue id </td></tr>
    <tr><td class="paramname">attr_id</td><td>The attribute ID to set </td></tr>
    <tr><td class="paramname">attr_value</td><td>The attribute value to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Successfully set attribute.</li>
<li>-EINVAL: invalid device, queue or attr_id.</li>
<li>-ENOTSUP: device does not support setting the event attribute.</li>
<li>&lt;0: failed to set event queue attribute </li>
</ul>
</dd></dl>

</div>
</div>
<a id="abf86b3088e02126b06be3c0a5ac07bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf86b3088e02126b06be3c0a5ac07bb7">&#9670;&nbsp;</a></span>rte_event_port_default_conf_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_port_default_conf_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__event__port__conf.html">rte_event_port_conf</a> *&#160;</td>
          <td class="paramname"><em>port_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the default configuration information of an event port designated by its <em>port_id</em> from the event driver for an event device.</p>
<p>This function intended to be used in conjunction with <a class="el" href="rte__eventdev_8h.html#ac087670e6e885abcdf046c8e74844cd4">rte_event_port_setup()</a> where caller needs to set up the port by overriding few default values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">port_id</td><td>The index of the event port to get the configuration information. The value must be in the range [0, nb_event_ports - 1] previously supplied to <a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">port_conf</td><td>The pointer to the default event port configuration data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, driver updates the default event port configuration data.</li>
<li>&lt;0: Error code returned by the driver info get function.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#ac087670e6e885abcdf046c8e74844cd4">rte_event_port_setup()</a> </dd></dl>

</div>
</div>
<a id="ac087670e6e885abcdf046c8e74844cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac087670e6e885abcdf046c8e74844cd4">&#9670;&nbsp;</a></span>rte_event_port_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_port_setup </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__event__port__conf.html">rte_event_port_conf</a> *&#160;</td>
          <td class="paramname"><em>port_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate and set up an event port for an event device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">port_id</td><td>The index of the event port to setup. The value must be in the range [0, nb_event_ports - 1] previously supplied to <a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">port_conf</td><td>The pointer to the configuration data to be used for the queue. NULL value is allowed, in which case default configuration used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#abf86b3088e02126b06be3c0a5ac07bb7">rte_event_port_default_conf_get()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, event port correctly set up.</li>
<li>&lt;0: Port configuration failed</li>
<li>(-EDQUOT) Quota exceeded(Application tried to link the queue configured with RTE_EVENT_QUEUE_CFG_SINGLE_LINK to more than one event ports) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a70a49e09fc904ab0709f3fb7f8e7ef8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a49e09fc904ab0709f3fb7f8e7ef8b">&#9670;&nbsp;</a></span>rte_event_port_quiesce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_event_port_quiesce </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__eventdev_8h.html#a1d624b5b4606fdaf0799c19412e30d2b">rte_eventdev_port_flush_t</a>&#160;</td>
          <td class="paramname"><em>release_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Quiesce any core specific resources consumed by the event port.</p>
<p>Event ports are generally coupled with lcores, and a given Hardware implementation might require the PMD to store port specific data in the lcore. When the application decides to migrate the event port to another lcore or teardown the current lcore it may to call <code>rte_event_port_quiesce</code> to make sure that all the data associated with the event port are released from the lcore, this might also include any prefetched events. While releasing the event port from the lcore, this function calls the user-provided flush callback once per event.</p>
<dl class="section note"><dt>Note</dt><dd>Invocation of this API does not affect the existing port configuration.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">port_id</td><td>The index of the event port to setup. The value must be in the range [0, nb_event_ports - 1] previously supplied to <a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">release_cb</td><td>Callback function invoked once per flushed event. </td></tr>
    <tr><td class="paramname">args</td><td>Argument supplied to callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1cc781b1ab9af77077c6c91eab37220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1cc781b1ab9af77077c6c91eab37220">&#9670;&nbsp;</a></span>rte_event_port_attr_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_port_attr_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attr_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>attr_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an attribute from a port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>Eventdev id </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">port_id</td><td>Eventdev port id </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">attr_id</td><td>The attribute ID to retrieve </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">attr_value</td><td>A pointer that will be filled in with the attribute value if successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Successfully returned value</li>
<li>(-EINVAL) Invalid device, port or attr_id, or attr_value was NULL </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab6e99f06a45adaa095b257b93ebaf201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e99f06a45adaa095b257b93ebaf201">&#9670;&nbsp;</a></span>rte_event_dev_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_start </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an event device.</p>
<p>The device start step is the last one and consists of setting the event queues to start accepting the events and schedules to event ports.</p>
<p>On success, all basic functions exported by the API (event enqueue, event dequeue and so on) can be invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Event device identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, device started.</li>
<li>-ESTALE : Not all ports of the device are configured</li>
<li>-ENOLINK: Not all queues are linked, which could lead to deadlock. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a644f6cc4ab24a5c07bfff9b0f5c42e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644f6cc4ab24a5c07bfff9b0f5c42e8e">&#9670;&nbsp;</a></span>rte_event_dev_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_event_dev_stop </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop an event device.</p>
<p>This function causes all queued events to be drained, including those residing in event ports. While draining events out of the device, this function calls the user-provided flush callback (if one was registered) once per event.</p>
<p>The device can be restarted with a call to <a class="el" href="rte__eventdev_8h.html#ab6e99f06a45adaa095b257b93ebaf201">rte_event_dev_start()</a>. Threads that continue to enqueue/dequeue while the device is stopped, or being stopped, will result in undefined behavior. This includes event adapters, which must be stopped prior to stopping the eventdev.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Event device identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a61e3bcdbed65202e822f6cefeb891bf8">rte_event_dev_stop_flush_callback_register()</a> </dd></dl>

</div>
</div>
<a id="a61e3bcdbed65202e822f6cefeb891bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e3bcdbed65202e822f6cefeb891bf8">&#9670;&nbsp;</a></span>rte_event_dev_stop_flush_callback_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_stop_flush_callback_register </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__eventdev_8h.html#a9e04cfb272018b6337d57cd49bfd405e">rte_eventdev_stop_flush_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function to be invoked during <a class="el" href="rte__eventdev_8h.html#a644f6cc4ab24a5c07bfff9b0f5c42e8e">rte_event_dev_stop()</a> for each flushed event. This function can be used to properly dispose of queued events, for example events containing memory pointers.</p>
<p>The callback function is only registered for the calling process. The callback function must be registered in every process that can call <a class="el" href="rte__eventdev_8h.html#a644f6cc4ab24a5c07bfff9b0f5c42e8e">rte_event_dev_stop()</a>.</p>
<p>To unregister a callback, call this function with a NULL callback pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback function invoked once per flushed event. </td></tr>
    <tr><td class="paramname">userdata</td><td>Argument supplied to callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success.</li>
<li>-EINVAL if <em>dev_id</em> is invalid</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a644f6cc4ab24a5c07bfff9b0f5c42e8e">rte_event_dev_stop()</a> </dd></dl>

</div>
</div>
<a id="af70f4ed704d89a4ffce3b4c105bac076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70f4ed704d89a4ffce3b4c105bac076">&#9670;&nbsp;</a></span>rte_event_dev_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_close </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close an event device. The device cannot be restarted!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Event device identifier</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on successfully closing device</li>
<li>&lt;0 on failure to close device</li>
<li>(-EAGAIN) if device is busy </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5d0257af1e87fb6e3aefb42c507b0997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0257af1e87fb6e3aefb42c507b0997">&#9670;&nbsp;</a></span>__rte_aligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__event__vector.html">rte_event_vector</a> <a class="el" href="struct____rte__aligned.html">__rte_aligned</a> </td>
          <td>(</td>
          <td class="paramtype">16&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; Implementation specific opaque value. An implementation may use this field to hold implementation specific value to share between dequeue and enqueue operation. The application should not modify this field. Start of the vector array union. Depending upon the event type the vector array can be an array of mbufs or pointers or opaque u64 values. </p>

</div>
</div>
<a id="a56aa49dc89eb44d2e35bd72bd809db17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56aa49dc89eb44d2e35bd72bd809db17">&#9670;&nbsp;</a></span>rte_event_eth_rx_adapter_caps_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_eth_rx_adapter_caps_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>eth_port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the event device's ethdev Rx adapter capabilities for the specified ethernet port</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">eth_port_id</td><td>The identifier of the ethernet device.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">caps</td><td>A pointer to memory filled with Rx event adapter capabilities.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, driver provides Rx event adapter capabilities for the ethernet device.</li>
<li>&lt;0: Error code returned by the driver function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a78649b804d0c880dd23b23fcd28100f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78649b804d0c880dd23b23fcd28100f9">&#9670;&nbsp;</a></span>rte_event_timer_adapter_caps_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_timer_adapter_caps_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the event device's timer adapter capabilities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">caps</td><td>A pointer to memory to be filled with event timer adapter capabilities.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, driver provided event timer adapter capabilities.</li>
<li>&lt;0: Error code returned by the driver function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6b478480a0d8d93b20622be566c127ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b478480a0d8d93b20622be566c127ee">&#9670;&nbsp;</a></span>rte_event_crypto_adapter_caps_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_crypto_adapter_caps_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cdev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the event device's crypto adapter capabilities for the specified cryptodev device</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cdev_id</td><td>The identifier of the cryptodev device.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">caps</td><td>A pointer to memory filled with event adapter capabilities. It is expected to be pre-allocated &amp; initialized by caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, driver provides event adapter capabilities for the cryptodev device.</li>
<li>&lt;0: Error code returned by the driver function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="acebd0fa9262a9d72377e786606e32765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acebd0fa9262a9d72377e786606e32765">&#9670;&nbsp;</a></span>rte_event_dma_adapter_caps_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_event_dma_adapter_caps_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dmadev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the event device's DMA adapter capabilities for the specified dmadev device</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dmadev_id</td><td>The identifier of the dmadev device.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">caps</td><td>A pointer to memory filled with event adapter capabilities. It is expected to be pre-allocated &amp; initialized by caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, driver provides event adapter capabilities for the dmadev device.</li>
<li>&lt;0: Error code returned by the driver function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad147297659da4017ff8a8cec1757548c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad147297659da4017ff8a8cec1757548c">&#9670;&nbsp;</a></span>rte_event_eth_tx_adapter_caps_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_eth_tx_adapter_caps_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>eth_port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the event device's eth Tx adapter capabilities</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">eth_port_id</td><td>The identifier of the ethernet device.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">caps</td><td>A pointer to memory filled with eth Tx adapter capabilities.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, driver provides eth Tx adapter capabilities.</li>
<li>&lt;0: Error code returned by the driver function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a245cbc6e55632565a57f6f98f492428f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245cbc6e55632565a57f6f98f492428f">&#9670;&nbsp;</a></span>rte_event_dequeue_timeout_ticks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dequeue_timeout_ticks </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>timeout_ticks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts nanoseconds to <em>timeout_ticks</em> value for <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a></p>
<p>If the device is configured with RTE_EVENT_DEV_CFG_PER_DEQUEUE_TIMEOUT flag then application can use this function to convert timeout value in nanoseconds to implementations specific timeout value supplied in <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ns</td><td>Wait time in nanosecond </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timeout_ticks</td><td>Value for the <em>timeout_ticks</em> parameter in <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success.</li>
<li>-ENOTSUP if the device doesn't support timeouts</li>
<li>-EINVAL if <em>dev_id</em> is invalid or <em>timeout_ticks</em> is NULL</li>
<li>other values &lt; 0 on failure.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a>, <a class="el" href="rte__eventdev_8h.html#aedc71a4c2e35b5b23fe6fcf593c5909a">RTE_EVENT_DEV_CFG_PER_DEQUEUE_TIMEOUT</a> </dd>
<dd>
<a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure()</a> </dd></dl>

</div>
</div>
<a id="a27f0abd90e6784a4dc1c4f07ece2715a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f0abd90e6784a4dc1c4f07ece2715a">&#9670;&nbsp;</a></span>rte_event_port_link()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_port_link </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>queues</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>priorities</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_links</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Link multiple source event queues supplied in <em>queues</em> to the destination event port designated by its <em>port_id</em> with associated service priority supplied in <em>priorities</em> on the event device designated by its <em>dev_id</em>.</p>
<p>The link establishment shall enable the event port <em>port_id</em> from receiving events from the specified event queue(s) supplied in <em>queues</em></p>
<p>An event queue may link to one or more event ports. The number of links can be established from an event queue to event port is implementation defined.</p>
<p>Event queue(s) to event port link establishment can be changed at runtime without re-configuring the device to support scaling and to reduce the latency of critical work by establishing the link with more event ports at runtime.</p>
<p>When the value of <code><a class="el" href="structrte__event__dev__info.html#a728b1e0b57155ca94b52170e65b42b7e">rte_event_dev_info::max_profiles_per_port</a></code> is greater than or equal to one, this function links the event queues to the default profile_id i.e. profile_id 0 of the event port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramname">port_id</td><td>Event port identifier to select the destination port to link.</td></tr>
    <tr><td class="paramname">queues</td><td>Points to an array of <em>nb_links</em> event queues to be linked to the event port. NULL value is allowed, in which case this function links all the configured event queues <em>nb_event_queues</em> which previously supplied to <a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure()</a> to the event port <em>port_id</em></td></tr>
    <tr><td class="paramname">priorities</td><td>Points to an array of <em>nb_links</em> service priorities associated with each event queue link to event port. The priority defines the event port's servicing priority for event queue, which may be ignored by an implementation. The requested priority should in the range of [RTE_EVENT_DEV_PRIORITY_HIGHEST, RTE_EVENT_DEV_PRIORITY_LOWEST]. The implementation shall normalize the requested priority to implementation supported priority value. NULL value is allowed, in which case this function links the event queues with RTE_EVENT_DEV_PRIORITY_NORMAL servicing priority</td></tr>
    <tr><td class="paramname">nb_links</td><td>The number of links to establish. This parameter is ignored if queues is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of links actually established. The return value can be less than the value of the <em>nb_links</em> parameter when the implementation has the limitation on specific queue to port link establishment or if invalid parameters are specified in <em>queues</em> If the return value is less than <em>nb_links</em>, the remaining links at the end of link[] are not established, and the caller has to take care of them. If return value is less than <em>nb_links</em> then implementation shall update the rte_errno accordingly, Possible rte_errno values are (EDQUOT) Quota exceeded(Application tried to link the queue configured with RTE_EVENT_QUEUE_CFG_SINGLE_LINK to more than one event ports) (EINVAL) Invalid parameter </dd></dl>

</div>
</div>
<a id="ad8dad9f41edf100e192e5610b2f078d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8dad9f41edf100e192e5610b2f078d5">&#9670;&nbsp;</a></span>rte_event_port_unlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_port_unlink </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>queues</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_unlinks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlink multiple source event queues supplied in <em>queues</em> from the destination event port designated by its <em>port_id</em> on the event device designated by its <em>dev_id</em>.</p>
<p>The unlink call issues an async request to disable the event port <em>port_id</em> from receiving events from the specified event queue <em>queue_id</em>. Event queue(s) to event port unlink establishment can be changed at runtime without re-configuring the device.</p>
<p>When the value of <code><a class="el" href="structrte__event__dev__info.html#a728b1e0b57155ca94b52170e65b42b7e">rte_event_dev_info::max_profiles_per_port</a></code> is greater than or equal to one, this function unlinks the event queues from the default profile identifier i.e. profile 0 of the event port.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a065a820ce96a30fd83b54f535ef580d9">rte_event_port_unlinks_in_progress()</a> to poll for completed unlinks.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramname">port_id</td><td>Event port identifier to select the destination port to unlink.</td></tr>
    <tr><td class="paramname">queues</td><td>Points to an array of <em>nb_unlinks</em> event queues to be unlinked from the event port. NULL value is allowed, in which case this function unlinks all the event queue(s) from the event port <em>port_id</em>.</td></tr>
    <tr><td class="paramname">nb_unlinks</td><td>The number of unlinks to establish. This parameter is ignored if queues is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of unlinks successfully requested. The return value can be less than the value of the <em>nb_unlinks</em> parameter when the implementation has the limitation on specific queue to port unlink establishment or if invalid parameters are specified. If the return value is less than <em>nb_unlinks</em>, the remaining queues at the end of queues[] are not unlinked, and the caller has to take care of them. If return value is less than <em>nb_unlinks</em> then implementation shall update the rte_errno accordingly, Possible rte_errno values are (EINVAL) Invalid parameter </dd></dl>

</div>
</div>
<a id="a52ec0678b318c4b94e4888c77adb262e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ec0678b318c4b94e4888c77adb262e">&#9670;&nbsp;</a></span>rte_event_port_profile_links_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_event_port_profile_links_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>queues</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>priorities</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_links</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>profile_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Link multiple source event queues supplied in <em>queues</em> to the destination event port designated by its <em>port_id</em> with associated profile identifier supplied in <em>profile_id</em> with service priorities supplied in <em>priorities</em> on the event device designated by its <em>dev_id</em>.</p>
<p>If <em>profile_id</em> is set to 0 then, the links created by the call <code>rte_event_port_link</code> will be overwritten.</p>
<p>Event ports by default use profile_id 0 unless it is changed using the call <code><a class="el" href="rte__eventdev_8h.html#a4329609b4ac283c3e7c8b87838778bc8">rte_event_port_profile_switch()</a></code>.</p>
<p>The link establishment shall enable the event port <em>port_id</em> from receiving events from the specified event queue(s) supplied in <em>queues</em></p>
<p>An event queue may link to one or more event ports. The number of links can be established from an event queue to event port is implementation defined.</p>
<p>Event queue(s) to event port link establishment can be changed at runtime without re-configuring the device to support scaling and to reduce the latency of critical work by establishing the link with more event ports at runtime.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramname">port_id</td><td>Event port identifier to select the destination port to link.</td></tr>
    <tr><td class="paramname">queues</td><td>Points to an array of <em>nb_links</em> event queues to be linked to the event port. NULL value is allowed, in which case this function links all the configured event queues <em>nb_event_queues</em> which previously supplied to <a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure()</a> to the event port <em>port_id</em></td></tr>
    <tr><td class="paramname">priorities</td><td>Points to an array of <em>nb_links</em> service priorities associated with each event queue link to event port. The priority defines the event port's servicing priority for event queue, which may be ignored by an implementation. The requested priority should in the range of [RTE_EVENT_DEV_PRIORITY_HIGHEST, RTE_EVENT_DEV_PRIORITY_LOWEST]. The implementation shall normalize the requested priority to implementation supported priority value. NULL value is allowed, in which case this function links the event queues with RTE_EVENT_DEV_PRIORITY_NORMAL servicing priority</td></tr>
    <tr><td class="paramname">nb_links</td><td>The number of links to establish. This parameter is ignored if queues is NULL.</td></tr>
    <tr><td class="paramname">profile_id</td><td>The profile identifier associated with the links between event queues and event port. Should be less than the max capability reported by <code><a class="el" href="structrte__event__dev__info.html#a728b1e0b57155ca94b52170e65b42b7e">rte_event_dev_info::max_profiles_per_port</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of links actually established. The return value can be less than the value of the <em>nb_links</em> parameter when the implementation has the limitation on specific queue to port link establishment or if invalid parameters are specified in <em>queues</em> If the return value is less than <em>nb_links</em>, the remaining links at the end of link[] are not established, and the caller has to take care of them. If return value is less than <em>nb_links</em> then implementation shall update the rte_errno accordingly, Possible rte_errno values are (EDQUOT) Quota exceeded(Application tried to link the queue configured with RTE_EVENT_QUEUE_CFG_SINGLE_LINK to more than one event ports) (EINVAL) Invalid parameter </dd></dl>

</div>
</div>
<a id="adda92a9ed5f3f2eaaafe8383e1aa9b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda92a9ed5f3f2eaaafe8383e1aa9b96">&#9670;&nbsp;</a></span>rte_event_port_profile_unlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_event_port_profile_unlink </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>queues</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_unlinks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>profile_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlink multiple source event queues supplied in <em>queues</em> that belong to profile designated by <em>profile_id</em> from the destination event port designated by its <em>port_id</em> on the event device designated by its <em>dev_id</em>.</p>
<p>If <em>profile_id</em> is set to 0 i.e., the default profile then, then this function will act as <code>rte_event_port_unlink</code>.</p>
<p>The unlink call issues an async request to disable the event port <em>port_id</em> from receiving events from the specified event queue <em>queue_id</em>. Event queue(s) to event port unlink establishment can be changed at runtime without re-configuring the device.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a065a820ce96a30fd83b54f535ef580d9">rte_event_port_unlinks_in_progress()</a> to poll for completed unlinks.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramname">port_id</td><td>Event port identifier to select the destination port to unlink.</td></tr>
    <tr><td class="paramname">queues</td><td>Points to an array of <em>nb_unlinks</em> event queues to be unlinked from the event port. NULL value is allowed, in which case this function unlinks all the event queue(s) from the event port <em>port_id</em>.</td></tr>
    <tr><td class="paramname">nb_unlinks</td><td>The number of unlinks to establish. This parameter is ignored if queues is NULL.</td></tr>
    <tr><td class="paramname">profile_id</td><td>The profile identifier associated with the links between event queues and event port. Should be less than the max capability reported by <code><a class="el" href="structrte__event__dev__info.html#a728b1e0b57155ca94b52170e65b42b7e">rte_event_dev_info::max_profiles_per_port</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of unlinks successfully requested. The return value can be less than the value of the <em>nb_unlinks</em> parameter when the implementation has the limitation on specific queue to port unlink establishment or if invalid parameters are specified. If the return value is less than <em>nb_unlinks</em>, the remaining queues at the end of queues[] are not unlinked, and the caller has to take care of them. If return value is less than <em>nb_unlinks</em> then implementation shall update the rte_errno accordingly, Possible rte_errno values are (EINVAL) Invalid parameter </dd></dl>

</div>
</div>
<a id="a065a820ce96a30fd83b54f535ef580d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065a820ce96a30fd83b54f535ef580d9">&#9670;&nbsp;</a></span>rte_event_port_unlinks_in_progress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_port_unlinks_in_progress </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of unlinks in progress.</p>
<p>This function provides the application with a method to detect when an unlink has been completed by the implementation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#ad8dad9f41edf100e192e5610b2f078d5">rte_event_port_unlink()</a> to issue unlink requests.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramname">port_id</td><td>Event port identifier to select port to check for unlinks in progress.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of unlinks that are in progress. A return of zero indicates that there are no outstanding unlink requests. A positive return value indicates the number of unlinks that are in progress, but are not yet complete. A negative return value indicates an error, -EINVAL indicates an invalid parameter passed for <em>dev_id</em> or <em>port_id</em>. </dd></dl>

</div>
</div>
<a id="a0524c6c5b1d32981669c4d84254228a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0524c6c5b1d32981669c4d84254228a1">&#9670;&nbsp;</a></span>rte_event_port_links_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_port_links_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>queues</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priorities</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the list of source event queues and its associated service priority linked to the destination event port designated by its <em>port_id</em> on the event device designated by its <em>dev_id</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">port_id</td><td>Event port identifier.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">queues</td><td>Points to an array of <em>queues</em> for output. The caller has to allocate <em>RTE_EVENT_MAX_QUEUES_PER_DEV</em> bytes to store the event queue(s) linked with event port <em>port_id</em></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">priorities</td><td>Points to an array of <em>priorities</em> for output. The caller has to allocate <em>RTE_EVENT_MAX_QUEUES_PER_DEV</em> bytes to store the service priority associated with each event queue linked</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of links established on the event port designated by its <em>port_id</em>.<ul>
<li>&lt;0 on failure. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9fd3d3bdeb4f797aab241c6ec44b0167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd3d3bdeb4f797aab241c6ec44b0167">&#9670;&nbsp;</a></span>rte_event_port_profile_links_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_event_port_profile_links_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>queues</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priorities</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>profile_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the list of source event queues and its service priority associated to a <em>profile_id</em> and linked to the destination event port designated by its <em>port_id</em> on the event device designated by its <em>dev_id</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">port_id</td><td>Event port identifier.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">queues</td><td>Points to an array of <em>queues</em> for output. The caller has to allocate <em>RTE_EVENT_MAX_QUEUES_PER_DEV</em> bytes to store the event queue(s) linked with event port <em>port_id</em></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">priorities</td><td>Points to an array of <em>priorities</em> for output. The caller has to allocate <em>RTE_EVENT_MAX_QUEUES_PER_DEV</em> bytes to store the service priority associated with each event queue linked</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">profile_id</td><td>The profile identifier associated with the links between event queues and event port. Should be less than the max capability reported by <code><a class="el" href="structrte__event__dev__info.html#a728b1e0b57155ca94b52170e65b42b7e">rte_event_dev_info::max_profiles_per_port</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of links established on the event port designated by its <em>port_id</em>.<ul>
<li>&lt;0 on failure. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a335e46a7e6c7b3c17629b007d0a85e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335e46a7e6c7b3c17629b007d0a85e62">&#9670;&nbsp;</a></span>rte_event_dev_service_id_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_service_id_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>service_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the service ID of the event dev. If the adapter doesn't use a rte_service function, this function returns -ESRCH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">service_id</td><td>A pointer to a uint32_t, to be filled in with the service id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success</li>
<li>&lt;0: Error code on failure, if the event dev doesn't use a rte_service function, this function returns -ESRCH. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a766ba60306ac044b59d6143c77288c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766ba60306ac044b59d6143c77288c46">&#9670;&nbsp;</a></span>rte_event_dev_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_dump </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump internal information about <em>dev_id</em> to the FILE* provided in <em>f</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramname">f</td><td>A pointer to a file for output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: on success</li>
<li>&lt;0: on failure. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac0399370c18dbdcff6e6a059a9e13f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0399370c18dbdcff6e6a059a9e13f97">&#9670;&nbsp;</a></span>rte_event_dev_xstats_names_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_xstats_names_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__eventdev_8h.html#a505adb6f39a9108c494df8070312dee5">rte_event_dev_xstats_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>queue_port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__event__dev__xstats__name.html">rte_event_dev_xstats_name</a> *&#160;</td>
          <td class="paramname"><em>xstats_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve names of extended statistics of an event device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the event device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">mode</td><td>The mode of statistics to retrieve. Choices include the device statistics, port statistics or queue statistics. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue_port_id</td><td>Used to specify the port or queue number in queue or port mode, and is ignored in device mode. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xstats_names</td><td>Block of memory to insert names into. Must be at least size in capacity. If set to NULL, function returns required capacity. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ids</td><td>Block of memory to insert ids into. Must be at least size in capacity. If set to NULL, function returns required capacity. The id values returned can be passed to <em>rte_event_dev_xstats_get</em> to select statistics. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size</td><td>Capacity of xstats_names (number of names). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>positive value lower or equal to size: success. The return value is the number of entries filled in the stats table.</li>
<li>positive value higher than size: error, the given statistics table is too small. The return value corresponds to the size that should be given to succeed. The entries in the table are not valid and shall not be used by the caller.</li>
<li>negative value on error: -ENODEV for invalid <em>dev_id</em> -EINVAL for invalid mode, queue port or id parameters -ENOTSUP if the device doesn't support this function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8b48f9036629f85ff8b584cddb035c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b48f9036629f85ff8b584cddb035c3d">&#9670;&nbsp;</a></span>rte_event_dev_xstats_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_xstats_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__eventdev_8h.html#a505adb6f39a9108c494df8070312dee5">rte_event_dev_xstats_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>queue_port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>ids</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>values</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve extended statistics of an event device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">mode</td><td>The mode of statistics to retrieve. Choices include the device statistics, port statistics or queue statistics. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue_port_id</td><td>Used to specify the port or queue number in queue or port mode, and is ignored in device mode. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ids</td><td>The id numbers of the stats to get. The ids can be got from the stat position in the stat list from rte_event_dev_get_xstats_names(), or by using <a class="el" href="rte__eventdev_8h.html#a825237f051767fafd92c6d6a854425f7">rte_event_dev_xstats_by_name_get()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>The values for each stats request by ID. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>The number of stats requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>positive value: number of stat entries filled into the values array</li>
<li>negative value on error: -ENODEV for invalid <em>dev_id</em> -EINVAL for invalid mode, queue port or id parameters -ENOTSUP if the device doesn't support this function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a825237f051767fafd92c6d6a854425f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825237f051767fafd92c6d6a854425f7">&#9670;&nbsp;</a></span>rte_event_dev_xstats_by_name_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t rte_event_dev_xstats_by_name_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the value of a single stat by requesting it by name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>The stat name to retrieve </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>If non-NULL, the numerical id of the stat will be returned, so that further requests for the stat can be got using rte_event_dev_xstats_get, which will be faster as it doesn't need to scan a list of names for the stat. If the stat cannot be found, the id returned will be (unsigned)-1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>positive value or zero: the stat value</li>
<li>negative value: -EINVAL if stat not found, -ENOTSUP if not supported. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a757a80d9145b41fd1317ffcef576821c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757a80d9145b41fd1317ffcef576821c">&#9670;&nbsp;</a></span>rte_event_dev_xstats_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_xstats_reset </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__eventdev_8h.html#a505adb6f39a9108c494df8070312dee5">rte_event_dev_xstats_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>queue_port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>ids</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nb_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the values of the xstats of the selected component in the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device </td></tr>
    <tr><td class="paramname">mode</td><td>The mode of the statistics to reset. Choose from device, queue or port. </td></tr>
    <tr><td class="paramname">queue_port_id</td><td>The queue or port to reset. 0 and positive values select ports and queues, while -1 indicates all ports or queues. </td></tr>
    <tr><td class="paramname">ids</td><td>Selects specific statistics to be reset. When NULL, all statistics selected by <em>mode</em> will be reset. If non-NULL, must point to array of at least <em>nb_ids</em> size. </td></tr>
    <tr><td class="paramname">nb_ids</td><td>The number of ids available from the <em>ids</em> array. Ignored when ids is NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>zero: successfully reset the statistics to zero</li>
<li>negative value: -EINVAL invalid parameters, -ENOTSUP if not supported. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a592ae650e0315dd61364e1cab3ecd6a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592ae650e0315dd61364e1cab3ecd6a7">&#9670;&nbsp;</a></span>rte_event_dev_selftest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_selftest </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trigger the eventdev self test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Selftest successful</li>
<li>-ENOTSUP if the device doesn't support selftest</li>
<li>other values &lt; 0 on failure. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9fe373c0c3a2882bad04528df0e08f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe373c0c3a2882bad04528df0e08f40">&#9670;&nbsp;</a></span>rte_event_vector_pool_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__mempool.html">rte_mempool</a>* rte_event_vector_pool_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cache_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the memory required per event vector based on the number of elements per vector. This should be used to create the mempool that holds the event vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the vector pool. </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in the mbuf pool. </td></tr>
    <tr><td class="paramname">cache_size</td><td>Size of the per-core object cache. See <a class="el" href="rte__mempool_8h.html#a503f2f889043a48ca9995878846db2fd">rte_mempool_create()</a> for details. </td></tr>
    <tr><td class="paramname">nb_elem</td><td>The number of elements that a single event vector should be able to hold. </td></tr>
    <tr><td class="paramname">socket_id</td><td>The socket identifier where the memory should be allocated. The value can be <em>SOCKET_ID_ANY</em> if there is no NUMA constraint for the reserved zone</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the newly allocated mempool, on success. NULL on error with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>E_RTE_NO_CONFIG - function could not get pointer to rte_config structure</li>
<li>E_RTE_SECONDARY - function was called from a secondary process instance</li>
<li>EINVAL - cache size provided is too large, or priv_size is not aligned.</li>
<li>ENOSPC - the maximum number of memzones has already been allocated</li>
<li>EEXIST - a memzone with the same name already exists</li>
<li>ENOMEM - no appropriate memory area found in which to create memzone</li>
<li>ENAMETOOLONG - mempool name requested is too long. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afc6b7f3fd1b11858a2db91864708f9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6b7f3fd1b11858a2db91864708f9a4">&#9670;&nbsp;</a></span>rte_event_enqueue_burst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_event_enqueue_burst </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__event.html">rte_event</a>&#160;</td>
          <td class="paramname"><em>ev</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue a burst of events objects or an event object supplied in <em><a class="el" href="structrte__event.html">rte_event</a></em> structure on an event device designated by its <em>dev_id</em> through the event port specified by <em>port_id</em>. Each event object specifies the event queue on which it will be enqueued.</p>
<p>The <em>nb_events</em> parameter is the number of event objects to enqueue which are supplied in the <em>ev</em> array of <em><a class="el" href="structrte__event.html">rte_event</a></em> structure.</p>
<p>Event operations RTE_EVENT_OP_FORWARD and RTE_EVENT_OP_RELEASE must only be enqueued to the same port that their associated events were dequeued from.</p>
<p>The <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> function returns the number of events objects it actually enqueued. A return value equal to <em>nb_events</em> means that all event objects have been enqueued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">port_id</td><td>The identifier of the event port. </td></tr>
    <tr><td class="paramname">ev</td><td>Points to an array of <em>nb_events</em> objects of type <em><a class="el" href="structrte__event.html">rte_event</a></em> structure which contain the event object enqueue operations to be processed. </td></tr>
    <tr><td class="paramname">nb_events</td><td>The number of event objects to enqueue, typically number of rte_event_port_attr_get(...RTE_EVENT_PORT_ATTR_ENQ_DEPTH...) available for this port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of event objects actually enqueued on the event device. The return value can be less than the value of the <em>nb_events</em> parameter when the event devices queue is full or if invalid parameters are specified in a <em><a class="el" href="structrte__event.html">rte_event</a></em>. If the return value is less than <em>nb_events</em>, the remaining events at the end of ev[] are not consumed and the caller has to take care of them, and rte_errno is set accordingly. Possible errno values include:<ul>
<li>EINVAL The port ID is invalid, device ID is invalid, an event's queue ID is invalid, or an event's sched type doesn't match the capabilities of the destination queue.</li>
<li>ENOSPC The event port was backpressured and unable to enqueue one or more events. This error code is only applicable to closed systems. </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#aa1cc781b1ab9af77077c6c91eab37220">rte_event_port_attr_get()</a>, <a class="el" href="rte__eventdev_8h.html#a40fc8695cb074e656ab5eadf286b0f08">RTE_EVENT_PORT_ATTR_ENQ_DEPTH</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l02211">2211</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a9b9c183571cdd91c8a1c70fc6a6c1241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9c183571cdd91c8a1c70fc6a6c1241">&#9670;&nbsp;</a></span>rte_event_enqueue_new_burst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_event_enqueue_new_burst </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__event.html">rte_event</a>&#160;</td>
          <td class="paramname"><em>ev</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue a burst of events objects of operation type <em>RTE_EVENT_OP_NEW</em> on an event device designated by its <em>dev_id</em> through the event port specified by <em>port_id</em>.</p>
<p>Provides the same functionality as <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a>, expect that application can use this API when the all objects in the burst contains the enqueue operation of the type <em>RTE_EVENT_OP_NEW</em>. This specialized function can provide the additional hint to the PMD and optimize if possible.</p>
<p>The <a class="el" href="rte__eventdev_8h.html#a9b9c183571cdd91c8a1c70fc6a6c1241">rte_event_enqueue_new_burst()</a> result is undefined if the enqueue burst has event object of operation type != RTE_EVENT_OP_NEW.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">port_id</td><td>The identifier of the event port. </td></tr>
    <tr><td class="paramname">ev</td><td>Points to an array of <em>nb_events</em> objects of type <em><a class="el" href="structrte__event.html">rte_event</a></em> structure which contain the event object enqueue operations to be processed. </td></tr>
    <tr><td class="paramname">nb_events</td><td>The number of event objects to enqueue, typically number of rte_event_port_attr_get(...RTE_EVENT_PORT_ATTR_ENQ_DEPTH...) available for this port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of event objects actually enqueued on the event device. The return value can be less than the value of the <em>nb_events</em> parameter when the event devices queue is full or if invalid parameters are specified in a <em><a class="el" href="structrte__event.html">rte_event</a></em>. If the return value is less than <em>nb_events</em>, the remaining events at the end of ev[] are not consumed and the caller has to take care of them, and rte_errno is set accordingly. Possible errno values include:<ul>
<li>EINVAL The port ID is invalid, device ID is invalid, an event's queue ID is invalid, or an event's sched type doesn't match the capabilities of the destination queue.</li>
<li>ENOSPC The event port was backpressured and unable to enqueue one or more events. This error code is only applicable to closed systems. </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#aa1cc781b1ab9af77077c6c91eab37220">rte_event_port_attr_get()</a>, <a class="el" href="rte__eventdev_8h.html#a40fc8695cb074e656ab5eadf286b0f08">RTE_EVENT_PORT_ATTR_ENQ_DEPTH</a> </dd>
<dd>
<a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l02263">2263</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a2a6260ce13081213f8eb8b1b4da935ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6260ce13081213f8eb8b1b4da935ad">&#9670;&nbsp;</a></span>rte_event_enqueue_forward_burst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_event_enqueue_forward_burst </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__event.html">rte_event</a>&#160;</td>
          <td class="paramname"><em>ev</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue a burst of events objects of operation type <em>RTE_EVENT_OP_FORWARD</em> on an event device designated by its <em>dev_id</em> through the event port specified by <em>port_id</em>.</p>
<p>Provides the same functionality as <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a>, expect that application can use this API when the all objects in the burst contains the enqueue operation of the type <em>RTE_EVENT_OP_FORWARD</em>. This specialized function can provide the additional hint to the PMD and optimize if possible.</p>
<p>The <a class="el" href="rte__eventdev_8h.html#a9b9c183571cdd91c8a1c70fc6a6c1241">rte_event_enqueue_new_burst()</a> result is undefined if the enqueue burst has event object of operation type != RTE_EVENT_OP_FORWARD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">port_id</td><td>The identifier of the event port. </td></tr>
    <tr><td class="paramname">ev</td><td>Points to an array of <em>nb_events</em> objects of type <em><a class="el" href="structrte__event.html">rte_event</a></em> structure which contain the event object enqueue operations to be processed. </td></tr>
    <tr><td class="paramname">nb_events</td><td>The number of event objects to enqueue, typically number of rte_event_port_attr_get(...RTE_EVENT_PORT_ATTR_ENQ_DEPTH...) available for this port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of event objects actually enqueued on the event device. The return value can be less than the value of the <em>nb_events</em> parameter when the event devices queue is full or if invalid parameters are specified in a <em><a class="el" href="structrte__event.html">rte_event</a></em>. If the return value is less than <em>nb_events</em>, the remaining events at the end of ev[] are not consumed and the caller has to take care of them, and rte_errno is set accordingly. Possible errno values include:<ul>
<li>EINVAL The port ID is invalid, device ID is invalid, an event's queue ID is invalid, or an event's sched type doesn't match the capabilities of the destination queue.</li>
<li>ENOSPC The event port was backpressured and unable to enqueue one or more events. This error code is only applicable to closed systems. </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#aa1cc781b1ab9af77077c6c91eab37220">rte_event_port_attr_get()</a>, <a class="el" href="rte__eventdev_8h.html#a40fc8695cb074e656ab5eadf286b0f08">RTE_EVENT_PORT_ATTR_ENQ_DEPTH</a> </dd>
<dd>
<a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l02315">2315</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a2af1610d3ede24979267333cf2da1aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af1610d3ede24979267333cf2da1aab">&#9670;&nbsp;</a></span>rte_event_dequeue_burst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_event_dequeue_burst </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__event.html">rte_event</a>&#160;</td>
          <td class="paramname"><em>ev</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout_ticks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue a burst of events objects or an event object from the event port designated by its <em>event_port_id</em>, on an event device designated by its <em>dev_id</em>.</p>
<p><a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> does not dictate the specifics of scheduling algorithm as each eventdev driver may have different criteria to schedule an event. However, in general, from an application perspective scheduler may use the following scheme to dispatch an event to the port.</p>
<p>1) Selection of event queue based on a) The list of event queues are linked to the event port. b) If the device has RTE_EVENT_DEV_CAP_QUEUE_QOS capability then event queue selection from list is based on event queue priority relative to other event queue supplied as <em>priority</em> in <a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a> c) If the device has RTE_EVENT_DEV_CAP_EVENT_QOS capability then event queue selection from the list is based on event priority supplied as <em>priority</em> in <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> 2) Selection of event a) The number of flows available in selected event queue. b) Schedule type method associated with the event</p>
<p>The <em>nb_events</em> parameter is the maximum number of event objects to dequeue which are returned in the <em>ev</em> array of <em><a class="el" href="structrte__event.html">rte_event</a></em> structure.</p>
<p>The <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> function returns the number of events objects it actually dequeued. A return value equal to <em>nb_events</em> means that all event objects have been dequeued.</p>
<p>The number of events dequeued is the number of scheduler contexts held by this port. These contexts are automatically released in the next <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> invocation if the port supports implicit releases, or invoking <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> with RTE_EVENT_OP_RELEASE operation can be used to release the contexts early.</p>
<p>Event operations RTE_EVENT_OP_FORWARD and RTE_EVENT_OP_RELEASE must only be enqueued to the same port that their associated events were dequeued from.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">port_id</td><td>The identifier of the event port. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ev</td><td>Points to an array of <em>nb_events</em> objects of type <em><a class="el" href="structrte__event.html">rte_event</a></em> structure for output to be populated with the dequeued event objects. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nb_events</td><td>The maximum number of event objects to dequeue, typically number of rte_event_port_dequeue_depth() available for this port.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout_ticks</td><td><ul>
<li>0 no-wait, returns immediately if there is no event.</li>
<li>&gt;0 wait for the event, if the device is configured with RTE_EVENT_DEV_CFG_PER_DEQUEUE_TIMEOUT then this function will wait until at least one event is available or <em>timeout_ticks</em> time. if the device is not configured with RTE_EVENT_DEV_CFG_PER_DEQUEUE_TIMEOUT then this function will wait until the event available or <em>dequeue_timeout_ns</em> ns which was previously supplied to <a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure()</a></li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of event objects actually dequeued from the port. The return value can be less than the value of the <em>nb_events</em> parameter when the event port's queue is not full.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>rte_event_port_dequeue_depth() </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l02392">2392</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="aa0ce3e169d572451634dd050efcc7dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ce3e169d572451634dd050efcc7dfb">&#9670;&nbsp;</a></span>rte_event_maintain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_event_maintain </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maintain an event device.</p>
<p>This function is only relevant for event devices which do not have the <a class="el" href="rte__eventdev_8h.html#ad6fbffafa7e06b1a005f2f6bdedf8532">RTE_EVENT_DEV_CAP_MAINTENANCE_FREE</a> flag set. Such devices require an application thread using a particular port to periodically call <a class="el" href="rte__eventdev_8h.html#aa0ce3e169d572451634dd050efcc7dfb">rte_event_maintain()</a> on that port during periods which it is neither attempting to enqueue events to nor dequeue events from the port. <a class="el" href="rte__eventdev_8h.html#aa0ce3e169d572451634dd050efcc7dfb">rte_event_maintain()</a> is a low-overhead function and should be called at a high rate (e.g., in the application's poll loop).</p>
<p>No port may be left unmaintained.</p>
<p>At the application thread's convenience, <a class="el" href="rte__eventdev_8h.html#aa0ce3e169d572451634dd050efcc7dfb">rte_event_maintain()</a> may (but is not required to) be called even during periods when enqueue or dequeue functions are being called, at the cost of a slight increase in overhead.</p>
<p><a class="el" href="rte__eventdev_8h.html#aa0ce3e169d572451634dd050efcc7dfb">rte_event_maintain()</a> may be called on event devices which have set <a class="el" href="rte__eventdev_8h.html#ad6fbffafa7e06b1a005f2f6bdedf8532">RTE_EVENT_DEV_CAP_MAINTENANCE_FREE</a>, in which case it is a no-operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">port_id</td><td>The identifier of the event port. </td></tr>
    <tr><td class="paramname">op</td><td>0, or <a class="el" href="rte__eventdev_8h.html#a9a2be1a618a0cd023313f6132765ba40">RTE_EVENT_DEV_MAINT_OP_FLUSH</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success.</li>
<li>-EINVAL if <em>dev_id</em>, <em>port_id</em>, or <em>op</em> is invalid.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#ad6fbffafa7e06b1a005f2f6bdedf8532">RTE_EVENT_DEV_CAP_MAINTENANCE_FREE</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l02467">2467</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a4329609b4ac283c3e7c8b87838778bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4329609b4ac283c3e7c8b87838778bc8">&#9670;&nbsp;</a></span>rte_event_port_profile_switch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t rte_event_port_profile_switch </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>profile_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the active profile on an event port.</p>
<p>This function is used to change the current active profile on an event port when multiple link profiles are configured on an event port through the function call <code>rte_event_port_profile_links_set</code>.</p>
<p>On the subsequent <code>rte_event_dequeue_burst</code> call, only the event queues that were associated with the newly active profile will participate in scheduling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">port_id</td><td>The identifier of the event port. </td></tr>
    <tr><td class="paramname">profile_id</td><td>The identifier of the profile. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success.</li>
<li>-EINVAL if <em>dev_id</em>, <em>port_id</em>, or <em>profile_id</em> is invalid. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l02515">2515</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ab62797c76613377624e5c316140dc259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62797c76613377624e5c316140dc259">&#9670;&nbsp;</a></span>nb_elem</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t nb_elem</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of elements valid in this event vector. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00000">0</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a14841202e26525493abd0705de37cc4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14841202e26525493abd0705de37cc4a">&#9670;&nbsp;</a></span>elem_offset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t elem_offset</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset into the vector array where valid elements start from. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00002">2</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ac6afa72984587556813605e9102d667d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6afa72984587556813605e9102d667d">&#9670;&nbsp;</a></span>rsvd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rsvd</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserved for future use </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00004">4</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a52f839b211018e7d9572262b3c9d8661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f839b211018e7d9572262b3c9d8661">&#9670;&nbsp;</a></span>attr_valid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t attr_valid</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that the below union attributes have valid information. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00006">6</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ad57f61ffbd7fff9cde410809bb2771fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57f61ffbd7fff9cde410809bb2771fd">&#9670;&nbsp;</a></span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union { ... } </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Union to hold common attributes of the vector array. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
