<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/bbdev/rte_bbdev.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">23.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_4e5c52521fbb4af3f7908ec35c5f7449.html">bbdev</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_bbdev.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;rte_compat.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__cpuflags_8h_source.html">rte_cpuflags.h</a>&gt;</code><br />
<code>#include &quot;<a class="el" href="rte__bbdev__op_8h_source.html">rte_bbdev_op.h</a>&quot;</code><br />
</div>
<p><a href="rte__bbdev_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__bbdev__queue__conf.html">rte_bbdev_queue_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__bbdev__stats.html">rte_bbdev_stats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__bbdev__driver__info.html">rte_bbdev_driver_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__bbdev__info.html">rte_bbdev_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__bbdev__queue__info.html">rte_bbdev_queue_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:afb7096069a91f3e740616a5967533973"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#afb7096069a91f3e740616a5967533973">RTE_BBDEV_MAX_DEVS</a>&#160;&#160;&#160;128</td></tr>
<tr class="separator:afb7096069a91f3e740616a5967533973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af802dc9dbbdfce9e4d0aa55894dcbf91"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#af802dc9dbbdfce9e4d0aa55894dcbf91">RTE_BBDEV_FOREACH</a>(i)</td></tr>
<tr class="separator:af802dc9dbbdfce9e4d0aa55894dcbf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589f71722680b1d346be2d38a0385165"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a589f71722680b1d346be2d38a0385165">RTE_BBDEV_END_OF_CAPABILITIES_LIST</a>()&#160;&#160;&#160;	{ <a class="el" href="rte__bbdev__op_8h.html#a35a82e6bdeafffb0038dc34bb5ff9889a85f6ca196ad00ffab40b765721d5cbf6">RTE_BBDEV_OP_NONE</a> }</td></tr>
<tr class="separator:a589f71722680b1d346be2d38a0385165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed6d26768b2f19c294deea5dd812f59"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#afed6d26768b2f19c294deea5dd812f59">RTE_BBDEV_NAME_MAX_LEN</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:afed6d26768b2f19c294deea5dd812f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a794dc2714438a7dfe7b06cef27d87a97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a794dc2714438a7dfe7b06cef27d87a97">rte_bbdev_cb_fn</a>) (uint16_t dev_id, enum <a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6">rte_bbdev_event_type</a> event, void *cb_arg, void *ret_param)</td></tr>
<tr class="separator:a794dc2714438a7dfe7b06cef27d87a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a393a1f786e4ca5c3bf7481382c0c765a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a393a1f786e4ca5c3bf7481382c0c765a">rte_bbdev_state</a> </td></tr>
<tr class="separator:a393a1f786e4ca5c3bf7481382c0c765a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd597c6b5e212f5a01a63512a8e889f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a0cd597c6b5e212f5a01a63512a8e889f">rte_bbdev_enqueue_status</a> { <a class="el" href="rte__bbdev_8h.html#a0cd597c6b5e212f5a01a63512a8e889fafe85b4e610203d8e5aae5fe5e88ed4ca">RTE_BBDEV_ENQ_STATUS_NONE</a>
, <a class="el" href="rte__bbdev_8h.html#a0cd597c6b5e212f5a01a63512a8e889fa488a13f35b5ca1b52af47e577c03faa4">RTE_BBDEV_ENQ_STATUS_QUEUE_FULL</a>
, <a class="el" href="rte__bbdev_8h.html#a0cd597c6b5e212f5a01a63512a8e889fa3f6c63aa5839967bfafd38fe94a848cd">RTE_BBDEV_ENQ_STATUS_RING_FULL</a>
, <a class="el" href="rte__bbdev_8h.html#a0cd597c6b5e212f5a01a63512a8e889fa25727a7bf10adf13daaf00122af3fe71">RTE_BBDEV_ENQ_STATUS_INVALID_OP</a>
 }</td></tr>
<tr class="separator:a0cd597c6b5e212f5a01a63512a8e889f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e2a03baf9cd936459801de536235a1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a02e2a03baf9cd936459801de536235a1">rte_bbdev_device_status</a> { <br />
&#160;&#160;<a class="el" href="rte__bbdev_8h.html#a02e2a03baf9cd936459801de536235a1aef03e9aa38f4b7de9870db223f3381a3">RTE_BBDEV_DEV_NOSTATUS</a>
, <a class="el" href="rte__bbdev_8h.html#a02e2a03baf9cd936459801de536235a1a0ea8a8f91e8cbb8720404588f0d8b0ab">RTE_BBDEV_DEV_NOT_SUPPORTED</a>
, <a class="el" href="rte__bbdev_8h.html#a02e2a03baf9cd936459801de536235a1aa304382a26c48cfe70736298b704f2b6">RTE_BBDEV_DEV_RESET</a>
, <a class="el" href="rte__bbdev_8h.html#a02e2a03baf9cd936459801de536235a1a5e8b3ef5aa2bf27dc5604c7ea055089a">RTE_BBDEV_DEV_CONFIGURED</a>
, <br />
&#160;&#160;<a class="el" href="rte__bbdev_8h.html#a02e2a03baf9cd936459801de536235a1ad1ae0a4b13d894f8aacd6b1e52fcfda8">RTE_BBDEV_DEV_ACTIVE</a>
, <a class="el" href="rte__bbdev_8h.html#a02e2a03baf9cd936459801de536235a1a035b8028efd5268dc7e25af4ce7f5b55">RTE_BBDEV_DEV_FATAL_ERR</a>
, <a class="el" href="rte__bbdev_8h.html#a02e2a03baf9cd936459801de536235a1a99f6a6aac2383a8ac6b5c15e83526efa">RTE_BBDEV_DEV_RESTART_REQ</a>
, <a class="el" href="rte__bbdev_8h.html#a02e2a03baf9cd936459801de536235a1a53c560528b665fbb9a25e5fe7b0576d9">RTE_BBDEV_DEV_RECONFIG_REQ</a>
, <br />
&#160;&#160;<a class="el" href="rte__bbdev_8h.html#a02e2a03baf9cd936459801de536235a1a0afc8223451092056962f9b9074a5497">RTE_BBDEV_DEV_CORRECT_ERR</a>
<br />
 }</td></tr>
<tr class="separator:a02e2a03baf9cd936459801de536235a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f094d19776103df98851abe088313d6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6">rte_bbdev_event_type</a> { <a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6adc0d3774bec179d6aef04c864bb5c057">RTE_BBDEV_EVENT_UNKNOWN</a>
, <a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6a236bec3c622d84a51c5717ce6fd941f4">RTE_BBDEV_EVENT_ERROR</a>
, <a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6acd75b27861793af96f1425b74855c1fa">RTE_BBDEV_EVENT_DEQUEUE</a>
, <a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6afdcbb8073dfbdfd7b2d843e452cb5501">RTE_BBDEV_EVENT_MAX</a>
 }</td></tr>
<tr class="separator:a5f094d19776103df98851abe088313d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a58c069221f73c4db35723d1b5375971b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a58c069221f73c4db35723d1b5375971b">rte_bbdev_count</a> (void)</td></tr>
<tr class="separator:a58c069221f73c4db35723d1b5375971b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2837f9304738ba5ab4d5e037740d83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#aae2837f9304738ba5ab4d5e037740d83">rte_bbdev_is_valid</a> (uint16_t dev_id)</td></tr>
<tr class="separator:aae2837f9304738ba5ab4d5e037740d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f67024511801791958c5f13acc80c8"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a42f67024511801791958c5f13acc80c8">rte_bbdev_find_next</a> (uint16_t dev_id)</td></tr>
<tr class="separator:a42f67024511801791958c5f13acc80c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be66496555abe61f852aebf6e90677a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a1be66496555abe61f852aebf6e90677a">rte_bbdev_setup_queues</a> (uint16_t dev_id, uint16_t num_queues, int socket_id)</td></tr>
<tr class="separator:a1be66496555abe61f852aebf6e90677a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad064155a7230fd81c3884f06c648483a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#ad064155a7230fd81c3884f06c648483a">rte_bbdev_intr_enable</a> (uint16_t dev_id)</td></tr>
<tr class="separator:ad064155a7230fd81c3884f06c648483a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9ae29dcb3bf426b79d7a6f281abcca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a5f9ae29dcb3bf426b79d7a6f281abcca">rte_bbdev_queue_configure</a> (uint16_t dev_id, uint16_t queue_id, const struct <a class="el" href="structrte__bbdev__queue__conf.html">rte_bbdev_queue_conf</a> *conf)</td></tr>
<tr class="separator:a5f9ae29dcb3bf426b79d7a6f281abcca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e9a93812470f96fc3072e1bd978a06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a01e9a93812470f96fc3072e1bd978a06">rte_bbdev_start</a> (uint16_t dev_id)</td></tr>
<tr class="separator:a01e9a93812470f96fc3072e1bd978a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7f355a996304ef4ab96033bb65fb74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a2f7f355a996304ef4ab96033bb65fb74">rte_bbdev_stop</a> (uint16_t dev_id)</td></tr>
<tr class="separator:a2f7f355a996304ef4ab96033bb65fb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c6816b0028573d1a666bff8225010a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a37c6816b0028573d1a666bff8225010a">rte_bbdev_close</a> (uint16_t dev_id)</td></tr>
<tr class="separator:a37c6816b0028573d1a666bff8225010a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea81d659c645d3788fa5128bbcaf528"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#aaea81d659c645d3788fa5128bbcaf528">rte_bbdev_queue_start</a> (uint16_t dev_id, uint16_t queue_id)</td></tr>
<tr class="separator:aaea81d659c645d3788fa5128bbcaf528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02cb6ee9b81ed604ea34cfb5d3f7f01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#af02cb6ee9b81ed604ea34cfb5d3f7f01">rte_bbdev_queue_stop</a> (uint16_t dev_id, uint16_t queue_id)</td></tr>
<tr class="separator:af02cb6ee9b81ed604ea34cfb5d3f7f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee9070dbe07a30ee36c71efdbc7ef4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#abee9070dbe07a30ee36c71efdbc7ef4c">rte_bbdev_stats_get</a> (uint16_t dev_id, struct <a class="el" href="structrte__bbdev__stats.html">rte_bbdev_stats</a> *stats)</td></tr>
<tr class="separator:abee9070dbe07a30ee36c71efdbc7ef4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af3a013a859bf830b2e0ae40b336ddf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a5af3a013a859bf830b2e0ae40b336ddf">rte_bbdev_stats_reset</a> (uint16_t dev_id)</td></tr>
<tr class="separator:a5af3a013a859bf830b2e0ae40b336ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5862e8538d62d9e85f85e6c2f185a201"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a5862e8538d62d9e85f85e6c2f185a201">rte_bbdev_info_get</a> (uint16_t dev_id, struct <a class="el" href="structrte__bbdev__info.html">rte_bbdev_info</a> *dev_info)</td></tr>
<tr class="separator:a5862e8538d62d9e85f85e6c2f185a201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c648fc0d842396ce43c955725d50219"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a7c648fc0d842396ce43c955725d50219">rte_bbdev_queue_info_get</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__queue__info.html">rte_bbdev_queue_info</a> *queue_info)</td></tr>
<tr class="separator:a7c648fc0d842396ce43c955725d50219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bbfdcdaad1072db173a5e4d736a7d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a21bbfdcdaad1072db173a5e4d736a7d1">RTE_TAILQ_HEAD</a> (rte_bbdev_cb_list, rte_bbdev_callback)</td></tr>
<tr class="separator:a21bbfdcdaad1072db173a5e4d736a7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d359617143cc4f3c1017975fc30d9cb"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a5d359617143cc4f3c1017975fc30d9cb">rte_bbdev_enqueue_enc_ops</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__enc__op.html">rte_bbdev_enc_op</a> **ops, uint16_t num_ops)</td></tr>
<tr class="separator:a5d359617143cc4f3c1017975fc30d9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f84cab8137c830d5e592e4404782b3"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#ae8f84cab8137c830d5e592e4404782b3">rte_bbdev_enqueue_dec_ops</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__dec__op.html">rte_bbdev_dec_op</a> **ops, uint16_t num_ops)</td></tr>
<tr class="separator:ae8f84cab8137c830d5e592e4404782b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbfc439233c983e4a854df4d6357346"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#aabbfc439233c983e4a854df4d6357346">rte_bbdev_enqueue_ldpc_enc_ops</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__enc__op.html">rte_bbdev_enc_op</a> **ops, uint16_t num_ops)</td></tr>
<tr class="separator:aabbfc439233c983e4a854df4d6357346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2189bf018a687c8323056e9e47ecbd7"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#ab2189bf018a687c8323056e9e47ecbd7">rte_bbdev_enqueue_ldpc_dec_ops</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__dec__op.html">rte_bbdev_dec_op</a> **ops, uint16_t num_ops)</td></tr>
<tr class="separator:ab2189bf018a687c8323056e9e47ecbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757050f022866f7a485497bbb4fae0bd"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a757050f022866f7a485497bbb4fae0bd">rte_bbdev_enqueue_fft_ops</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__fft__op.html">rte_bbdev_fft_op</a> **ops, uint16_t num_ops)</td></tr>
<tr class="separator:a757050f022866f7a485497bbb4fae0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534f3c877c79c11fd81988078e039f53"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a534f3c877c79c11fd81988078e039f53">rte_bbdev_enqueue_mldts_ops</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__mldts__op.html">rte_bbdev_mldts_op</a> **ops, uint16_t num_ops)</td></tr>
<tr class="separator:a534f3c877c79c11fd81988078e039f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa048e0f43fe7789745353d06fc7b1657"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#aa048e0f43fe7789745353d06fc7b1657">rte_bbdev_dequeue_enc_ops</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__enc__op.html">rte_bbdev_enc_op</a> **ops, uint16_t num_ops)</td></tr>
<tr class="separator:aa048e0f43fe7789745353d06fc7b1657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ec082a4762e04accf636885735bf5f"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a95ec082a4762e04accf636885735bf5f">rte_bbdev_dequeue_dec_ops</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__dec__op.html">rte_bbdev_dec_op</a> **ops, uint16_t num_ops)</td></tr>
<tr class="separator:a95ec082a4762e04accf636885735bf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795e3e8a85763099e9b2b5382201d338"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a795e3e8a85763099e9b2b5382201d338">rte_bbdev_dequeue_ldpc_enc_ops</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__enc__op.html">rte_bbdev_enc_op</a> **ops, uint16_t num_ops)</td></tr>
<tr class="separator:a795e3e8a85763099e9b2b5382201d338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f1a88e324939b91d15b672a2a75b48"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a52f1a88e324939b91d15b672a2a75b48">rte_bbdev_dequeue_ldpc_dec_ops</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__dec__op.html">rte_bbdev_dec_op</a> **ops, uint16_t num_ops)</td></tr>
<tr class="separator:a52f1a88e324939b91d15b672a2a75b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256715d7d2933d8a67a789ed6dadf8c1"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a256715d7d2933d8a67a789ed6dadf8c1">rte_bbdev_dequeue_fft_ops</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__fft__op.html">rte_bbdev_fft_op</a> **ops, uint16_t num_ops)</td></tr>
<tr class="separator:a256715d7d2933d8a67a789ed6dadf8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabaa7bb4b4b17357f116762627d6950a"><td class="memItemLeft" align="right" valign="top">static __rte_experimental uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#aabaa7bb4b4b17357f116762627d6950a">rte_bbdev_dequeue_mldts_ops</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__mldts__op.html">rte_bbdev_mldts_op</a> **ops, uint16_t num_ops)</td></tr>
<tr class="separator:aabaa7bb4b4b17357f116762627d6950a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f7d65861b6bc66552a9456e91be710"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a26f7d65861b6bc66552a9456e91be710">rte_bbdev_callback_register</a> (uint16_t dev_id, enum <a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6">rte_bbdev_event_type</a> event, <a class="el" href="rte__bbdev_8h.html#a794dc2714438a7dfe7b06cef27d87a97">rte_bbdev_cb_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="separator:a26f7d65861b6bc66552a9456e91be710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf683ac303b468689866fa387f077cf0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#abf683ac303b468689866fa387f077cf0">rte_bbdev_callback_unregister</a> (uint16_t dev_id, enum <a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6">rte_bbdev_event_type</a> event, <a class="el" href="rte__bbdev_8h.html#a794dc2714438a7dfe7b06cef27d87a97">rte_bbdev_cb_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="separator:abf683ac303b468689866fa387f077cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c39312c028d099f62b422cc8d766fe3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a0c39312c028d099f62b422cc8d766fe3">rte_bbdev_queue_intr_enable</a> (uint16_t dev_id, uint16_t queue_id)</td></tr>
<tr class="separator:a0c39312c028d099f62b422cc8d766fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad26ed2e5759c8375b546cd017e6b42"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#adad26ed2e5759c8375b546cd017e6b42">rte_bbdev_queue_intr_disable</a> (uint16_t dev_id, uint16_t queue_id)</td></tr>
<tr class="separator:adad26ed2e5759c8375b546cd017e6b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae128c6c582aa08fd1972a1dcdf38dd61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#ae128c6c582aa08fd1972a1dcdf38dd61">rte_bbdev_queue_intr_ctl</a> (uint16_t dev_id, uint16_t queue_id, int epfd, int op, void *data)</td></tr>
<tr class="separator:ae128c6c582aa08fd1972a1dcdf38dd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584c0e64cbae4540aa3dec81d251298f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a584c0e64cbae4540aa3dec81d251298f">rte_bbdev_device_status_str</a> (enum <a class="el" href="rte__bbdev_8h.html#a02e2a03baf9cd936459801de536235a1">rte_bbdev_device_status</a> status)</td></tr>
<tr class="separator:a584c0e64cbae4540aa3dec81d251298f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed77dd6e901c542247844b7276756d5e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#aed77dd6e901c542247844b7276756d5e">rte_bbdev_enqueue_status_str</a> (enum <a class="el" href="rte__bbdev_8h.html#a0cd597c6b5e212f5a01a63512a8e889f">rte_bbdev_enqueue_status</a> status)</td></tr>
<tr class="separator:aed77dd6e901c542247844b7276756d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Wireless base band device abstraction APIs.</p>
<p>This API allows an application to discover, configure and use a device to process operations. An asynchronous API (enqueue, followed by later dequeue) is used for processing operations.</p>
<p>The functions in this API are not thread-safe when called on the same target object (a device, or a queue on a device), with the exception that one thread can enqueue operations to a queue while another thread dequeues from the same queue. </p>

<p class="definition">Definition in file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="afb7096069a91f3e740616a5967533973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7096069a91f3e740616a5967533973">&#9670;&nbsp;</a></span>RTE_BBDEV_MAX_DEVS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_BBDEV_MAX_DEVS&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max number of devices </p>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00036">36</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="af802dc9dbbdfce9e4d0aa55894dcbf91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af802dc9dbbdfce9e4d0aa55894dcbf91">&#9670;&nbsp;</a></span>RTE_BBDEV_FOREACH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_BBDEV_FOREACH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        <span class="keywordflow">for</span> (i = <a class="code" href="rte__bbdev_8h.html#a42f67024511801791958c5f13acc80c8">rte_bbdev_find_next</a>(-1); \</div>
<div class="line">        i &lt; <a class="code" href="rte__bbdev_8h.html#afb7096069a91f3e740616a5967533973">RTE_BBDEV_MAX_DEVS</a>; \</div>
<div class="line">        i = <a class="code" href="rte__bbdev_8h.html#a42f67024511801791958c5f13acc80c8">rte_bbdev_find_next</a>(i))</div>
<div class="ttc" id="arte__bbdev_8h_html_a42f67024511801791958c5f13acc80c8"><div class="ttname"><a href="rte__bbdev_8h.html#a42f67024511801791958c5f13acc80c8">rte_bbdev_find_next</a></div><div class="ttdeci">uint16_t rte_bbdev_find_next(uint16_t dev_id)</div></div>
<div class="ttc" id="arte__bbdev_8h_html_afb7096069a91f3e740616a5967533973"><div class="ttname"><a href="rte__bbdev_8h.html#afb7096069a91f3e740616a5967533973">RTE_BBDEV_MAX_DEVS</a></div><div class="ttdeci">#define RTE_BBDEV_MAX_DEVS</div><div class="ttdef"><b>Definition:</b> <a href="rte__bbdev_8h_source.html#l00036">rte_bbdev.h:36</a></div></div>
</div><!-- fragment --><p>Iterate through all enabled devices </p>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00087">87</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="a589f71722680b1d346be2d38a0385165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589f71722680b1d346be2d38a0385165">&#9670;&nbsp;</a></span>RTE_BBDEV_END_OF_CAPABILITIES_LIST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_BBDEV_END_OF_CAPABILITIES_LIST</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;	{ <a class="el" href="rte__bbdev__op_8h.html#a35a82e6bdeafffb0038dc34bb5ff9889a85f6ca196ad00ffab40b765721d5cbf6">RTE_BBDEV_OP_NONE</a> }</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro used at end of bbdev PMD list </p>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00360">360</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="afed6d26768b2f19c294deea5dd812f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afed6d26768b2f19c294deea5dd812f59">&#9670;&nbsp;</a></span>RTE_BBDEV_NAME_MAX_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_BBDEV_NAME_MAX_LEN&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max length of device name </p>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00475">475</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a794dc2714438a7dfe7b06cef27d87a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794dc2714438a7dfe7b06cef27d87a97">&#9670;&nbsp;</a></span>rte_bbdev_cb_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void(* rte_bbdev_cb_fn) (uint16_t dev_id, enum <a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6">rte_bbdev_event_type</a> event, void *cb_arg, void *ret_param)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef for application callback function registered by application software for notification of device events</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Device identifier </td></tr>
    <tr><td class="paramname">event</td><td>Device event to register for notification of. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>User specified parameter to be passed to user's callback function. </td></tr>
    <tr><td class="paramname">ret_param</td><td>To pass data back to user application. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00929">929</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a393a1f786e4ca5c3bf7481382c0c765a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393a1f786e4ca5c3bf7481382c0c765a">&#9670;&nbsp;</a></span>rte_bbdev_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__bbdev_8h.html#a393a1f786e4ca5c3bf7481382c0c765a">rte_bbdev_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags indicate current state of BBDEV device </p>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00047">47</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="a0cd597c6b5e212f5a01a63512a8e889f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd597c6b5e212f5a01a63512a8e889f">&#9670;&nbsp;</a></span>rte_bbdev_enqueue_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__bbdev_8h.html#a0cd597c6b5e212f5a01a63512a8e889f">rte_bbdev_enqueue_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags to indicate the reason why a previous enqueue may not have consumed all requested operations. In case of multiple reasons the latter supersedes a previous one. The related macro RTE_BBDEV_ENQ_STATUS_SIZE_MAX can be used as an absolute maximum for notably sizing array while allowing for future enumeration insertion. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0cd597c6b5e212f5a01a63512a8e889fafe85b4e610203d8e5aae5fe5e88ed4ca"></a>RTE_BBDEV_ENQ_STATUS_NONE&#160;</td><td class="fielddoc"><p>Nothing to report. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0cd597c6b5e212f5a01a63512a8e889fa488a13f35b5ca1b52af47e577c03faa4"></a>RTE_BBDEV_ENQ_STATUS_QUEUE_FULL&#160;</td><td class="fielddoc"><p>Not enough room in queue. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0cd597c6b5e212f5a01a63512a8e889fa3f6c63aa5839967bfafd38fe94a848cd"></a>RTE_BBDEV_ENQ_STATUS_RING_FULL&#160;</td><td class="fielddoc"><p>Not enough room in ring. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0cd597c6b5e212f5a01a63512a8e889fa25727a7bf10adf13daaf00122af3fe71"></a>RTE_BBDEV_ENQ_STATUS_INVALID_OP&#160;</td><td class="fielddoc"><p>Operation was rejected as invalid. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00242">242</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="a02e2a03baf9cd936459801de536235a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e2a03baf9cd936459801de536235a1">&#9670;&nbsp;</a></span>rte_bbdev_device_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__bbdev_8h.html#a02e2a03baf9cd936459801de536235a1">rte_bbdev_device_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags to indicate the status of the device. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a02e2a03baf9cd936459801de536235a1aef03e9aa38f4b7de9870db223f3381a3"></a>RTE_BBDEV_DEV_NOSTATUS&#160;</td><td class="fielddoc"><p>Nothing being reported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a02e2a03baf9cd936459801de536235a1a0ea8a8f91e8cbb8720404588f0d8b0ab"></a>RTE_BBDEV_DEV_NOT_SUPPORTED&#160;</td><td class="fielddoc"><p>Device status is not supported on the PMD. </p>
</td></tr>
<tr><td class="fieldname"><a id="a02e2a03baf9cd936459801de536235a1aa304382a26c48cfe70736298b704f2b6"></a>RTE_BBDEV_DEV_RESET&#160;</td><td class="fielddoc"><p>Device in reset and un-configured state. </p>
</td></tr>
<tr><td class="fieldname"><a id="a02e2a03baf9cd936459801de536235a1a5e8b3ef5aa2bf27dc5604c7ea055089a"></a>RTE_BBDEV_DEV_CONFIGURED&#160;</td><td class="fielddoc"><p>Device is configured and ready to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="a02e2a03baf9cd936459801de536235a1ad1ae0a4b13d894f8aacd6b1e52fcfda8"></a>RTE_BBDEV_DEV_ACTIVE&#160;</td><td class="fielddoc"><p>Device is configured and VF is being used. </p>
</td></tr>
<tr><td class="fieldname"><a id="a02e2a03baf9cd936459801de536235a1a035b8028efd5268dc7e25af4ce7f5b55"></a>RTE_BBDEV_DEV_FATAL_ERR&#160;</td><td class="fielddoc"><p>Device has hit a fatal uncorrectable error. </p>
</td></tr>
<tr><td class="fieldname"><a id="a02e2a03baf9cd936459801de536235a1a99f6a6aac2383a8ac6b5c15e83526efa"></a>RTE_BBDEV_DEV_RESTART_REQ&#160;</td><td class="fielddoc"><p>Device requires application to restart. </p>
</td></tr>
<tr><td class="fieldname"><a id="a02e2a03baf9cd936459801de536235a1a53c560528b665fbb9a25e5fe7b0576d9"></a>RTE_BBDEV_DEV_RECONFIG_REQ&#160;</td><td class="fielddoc"><p>Device requires application to reconfigure queues. </p>
</td></tr>
<tr><td class="fieldname"><a id="a02e2a03baf9cd936459801de536235a1a0afc8223451092056962f9b9074a5497"></a>RTE_BBDEV_DEV_CORRECT_ERR&#160;</td><td class="fielddoc"><p>Warning of a correctable error event happened. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00253">253</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="a5f094d19776103df98851abe088313d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f094d19776103df98851abe088313d6">&#9670;&nbsp;</a></span>rte_bbdev_event_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6">rte_bbdev_event_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Definitions of device event types </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5f094d19776103df98851abe088313d6adc0d3774bec179d6aef04c864bb5c057"></a>RTE_BBDEV_EVENT_UNKNOWN&#160;</td><td class="fielddoc"><p>unknown event type </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f094d19776103df98851abe088313d6a236bec3c622d84a51c5717ce6fd941f4"></a>RTE_BBDEV_EVENT_ERROR&#160;</td><td class="fielddoc"><p>error interrupt event </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f094d19776103df98851abe088313d6acd75b27861793af96f1425b74855c1fa"></a>RTE_BBDEV_EVENT_DEQUEUE&#160;</td><td class="fielddoc"><p>dequeue event </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f094d19776103df98851abe088313d6afdcbb8073dfbdfd7b2d843e452cb5501"></a>RTE_BBDEV_EVENT_MAX&#160;</td><td class="fielddoc"><p>max value of this enum </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00909">909</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a58c069221f73c4db35723d1b5375971b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c069221f73c4db35723d1b5375971b">&#9670;&nbsp;</a></span>rte_bbdev_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rte_bbdev_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the total number of devices that have been successfully initialised.</p>
<dl class="section return"><dt>Returns</dt><dd>The total number of usable devices. </dd></dl>

</div>
</div>
<a id="aae2837f9304738ba5ab4d5e037740d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2837f9304738ba5ab4d5e037740d83">&#9670;&nbsp;</a></span>rte_bbdev_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rte_bbdev_is_valid </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a device is valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if device ID is valid and device is attached, false otherwise. </dd></dl>

</div>
</div>
<a id="a42f67024511801791958c5f13acc80c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f67024511801791958c5f13acc80c8">&#9670;&nbsp;</a></span>rte_bbdev_find_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rte_bbdev_find_next </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the next enabled device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The current device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The next device, or</li>
<li>RTE_BBDEV_MAX_DEVS if none found </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1be66496555abe61f852aebf6e90677a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be66496555abe61f852aebf6e90677a">&#9670;&nbsp;</a></span>rte_bbdev_setup_queues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_bbdev_setup_queues </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_queues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setup up device queues. This function must be called on a device before setting up the queues and starting the device. It can also be called when a device is in the stopped state. If any device queues have been configured their configuration will be cleared by a call to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">num_queues</td><td>Number of queues to configure on device. </td></tr>
    <tr><td class="paramname">socket_id</td><td>ID of a socket which will be used to allocate memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>-ENODEV if dev_id is invalid or the device is corrupted</li>
<li>-EINVAL if num_queues is invalid, 0 or greater than maximum</li>
<li>-EBUSY if the identified device has already started</li>
<li>-ENOMEM if unable to allocate memory </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad064155a7230fd81c3884f06c648483a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad064155a7230fd81c3884f06c648483a">&#9670;&nbsp;</a></span>rte_bbdev_intr_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_bbdev_intr_enable </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable interrupts. This function may be called before starting the device to enable the interrupts if they are available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>-ENODEV if dev_id is invalid or the device is corrupted</li>
<li>-EBUSY if the identified device has already started</li>
<li>-ENOTSUP if the interrupts are not supported by the device </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5f9ae29dcb3bf426b79d7a6f281abcca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9ae29dcb3bf426b79d7a6f281abcca">&#9670;&nbsp;</a></span>rte_bbdev_queue_configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_bbdev_queue_configure </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__bbdev__queue__conf.html">rte_bbdev_queue_conf</a> *&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure a queue on a device. This function can be called after device configuration, and before starting. It can also be called when the device or the queue is in the stopped state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">conf</td><td>The queue configuration. If NULL, a default configuration will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>EINVAL if the identified queue size or priority are invalid</li>
<li>EBUSY if the identified queue or its device have already started </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a01e9a93812470f96fc3072e1bd978a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e9a93812470f96fc3072e1bd978a06">&#9670;&nbsp;</a></span>rte_bbdev_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_bbdev_start </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start a device. This is the last step needed before enqueueing operations is possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>negative value on failure - as returned from PMD </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2f7f355a996304ef4ab96033bb65fb74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7f355a996304ef4ab96033bb65fb74">&#9670;&nbsp;</a></span>rte_bbdev_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_bbdev_stop </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop a device. The device can be reconfigured, and restarted after being stopped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a37c6816b0028573d1a666bff8225010a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c6816b0028573d1a666bff8225010a">&#9670;&nbsp;</a></span>rte_bbdev_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_bbdev_close </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close a device. The device cannot be restarted without reconfiguration!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aaea81d659c645d3788fa5128bbcaf528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea81d659c645d3788fa5128bbcaf528">&#9670;&nbsp;</a></span>rte_bbdev_queue_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_bbdev_queue_start </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start a specified queue on a device. This is only needed if the queue has been stopped, or if the deferred_start flag has been set when configuring the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>negative value on failure - as returned from PMD </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af02cb6ee9b81ed604ea34cfb5d3f7f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02cb6ee9b81ed604ea34cfb5d3f7f01">&#9670;&nbsp;</a></span>rte_bbdev_queue_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_bbdev_queue_stop </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop a specified queue on a device, to allow re configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>negative value on failure - as returned from PMD </li>
</ul>
</dd></dl>

</div>
</div>
<a id="abee9070dbe07a30ee36c71efdbc7ef4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee9070dbe07a30ee36c71efdbc7ef4c">&#9670;&nbsp;</a></span>rte_bbdev_stats_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_bbdev_stats_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__stats.html">rte_bbdev_stats</a> *&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the general I/O statistics of a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">stats</td><td>Pointer to structure to where statistics will be copied. On error, this location may or may not have been modified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>EINVAL if invalid parameter pointer is provided </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5af3a013a859bf830b2e0ae40b336ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af3a013a859bf830b2e0ae40b336ddf">&#9670;&nbsp;</a></span>rte_bbdev_stats_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_bbdev_stats_reset </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the statistics of a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5862e8538d62d9e85f85e6c2f185a201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5862e8538d62d9e85f85e6c2f185a201">&#9670;&nbsp;</a></span>rte_bbdev_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_bbdev_info_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__info.html">rte_bbdev_info</a> *&#160;</td>
          <td class="paramname"><em>dev_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve information about a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">dev_info</td><td>Pointer to structure to where information will be copied. On error, this location may or may not have been modified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>EINVAL if invalid parameter pointer is provided </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7c648fc0d842396ce43c955725d50219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c648fc0d842396ce43c955725d50219">&#9670;&nbsp;</a></span>rte_bbdev_queue_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_bbdev_queue_info_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__queue__info.html">rte_bbdev_queue_info</a> *&#160;</td>
          <td class="paramname"><em>queue_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve information about a specific queue on a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">queue_info</td><td>Pointer to structure to where information will be copied. On error, this location may or may not have been modified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>EINVAL if invalid parameter pointer is provided </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a21bbfdcdaad1072db173a5e4d736a7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21bbfdcdaad1072db173a5e4d736a7d1">&#9670;&nbsp;</a></span>RTE_TAILQ_HEAD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTE_TAILQ_HEAD </td>
          <td>(</td>
          <td class="paramtype">rte_bbdev_cb_list&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rte_bbdev_callback&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Structure to keep track of registered callbacks </p>

</div>
</div>
<a id="a5d359617143cc4f3c1017975fc30d9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d359617143cc4f3c1017975fc30d9cb">&#9670;&nbsp;</a></span>rte_bbdev_enqueue_enc_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_bbdev_enqueue_enc_ops </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__enc__op.html">rte_bbdev_enc_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue a burst of processed encode operations to a queue of the device. This functions only enqueues as many operations as currently possible and does not block until <code>num_ops</code> entries in the queue are available. This function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">ops</td><td>Pointer array containing operations to be enqueued Must have at least <code>num_ops</code> entries </td></tr>
    <tr><td class="paramname">num_ops</td><td>The maximum number of operations to enqueue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually enqueued (this is the number of processed entries in the <code>ops</code> array). </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00565">565</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="ae8f84cab8137c830d5e592e4404782b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f84cab8137c830d5e592e4404782b3">&#9670;&nbsp;</a></span>rte_bbdev_enqueue_dec_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_bbdev_enqueue_dec_ops </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__dec__op.html">rte_bbdev_dec_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue a burst of processed decode operations to a queue of the device. This functions only enqueues as many operations as currently possible and does not block until <code>num_ops</code> entries in the queue are available. This function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">ops</td><td>Pointer array containing operations to be enqueued Must have at least <code>num_ops</code> entries </td></tr>
    <tr><td class="paramname">num_ops</td><td>The maximum number of operations to enqueue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually enqueued (this is the number of processed entries in the <code>ops</code> array). </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00595">595</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="aabbfc439233c983e4a854df4d6357346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbfc439233c983e4a854df4d6357346">&#9670;&nbsp;</a></span>rte_bbdev_enqueue_ldpc_enc_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_bbdev_enqueue_ldpc_enc_ops </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__enc__op.html">rte_bbdev_enc_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue a burst of processed encode operations to a queue of the device. This functions only enqueues as many operations as currently possible and does not block until <code>num_ops</code> entries in the queue are available. This function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">ops</td><td>Pointer array containing operations to be enqueued Must have at least <code>num_ops</code> entries </td></tr>
    <tr><td class="paramname">num_ops</td><td>The maximum number of operations to enqueue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually enqueued (this is the number of processed entries in the <code>ops</code> array). </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00625">625</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="ab2189bf018a687c8323056e9e47ecbd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2189bf018a687c8323056e9e47ecbd7">&#9670;&nbsp;</a></span>rte_bbdev_enqueue_ldpc_dec_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_bbdev_enqueue_ldpc_dec_ops </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__dec__op.html">rte_bbdev_dec_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue a burst of processed decode operations to a queue of the device. This functions only enqueues as many operations as currently possible and does not block until <code>num_ops</code> entries in the queue are available. This function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">ops</td><td>Pointer array containing operations to be enqueued Must have at least <code>num_ops</code> entries </td></tr>
    <tr><td class="paramname">num_ops</td><td>The maximum number of operations to enqueue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually enqueued (this is the number of processed entries in the <code>ops</code> array). </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00655">655</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="a757050f022866f7a485497bbb4fae0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757050f022866f7a485497bbb4fae0bd">&#9670;&nbsp;</a></span>rte_bbdev_enqueue_fft_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_bbdev_enqueue_fft_ops </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__fft__op.html">rte_bbdev_fft_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue a burst of FFT operations to a queue of the device. This functions only enqueues as many operations as currently possible and does not block until <code>num_ops</code> entries in the queue are available. This function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">ops</td><td>Pointer array containing operations to be enqueued. Must have at least <code>num_ops</code> entries. </td></tr>
    <tr><td class="paramname">num_ops</td><td>The maximum number of operations to enqueue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually enqueued. (This is the number of processed entries in the <code>ops</code> array.) </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00685">685</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="a534f3c877c79c11fd81988078e039f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534f3c877c79c11fd81988078e039f53">&#9670;&nbsp;</a></span>rte_bbdev_enqueue_mldts_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_bbdev_enqueue_mldts_ops </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__mldts__op.html">rte_bbdev_mldts_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue a burst of MLDTS operations to a queue of the device. This functions only enqueues as many operations as currently possible and does not block until <code>num_ops</code> entries in the queue are available. This function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">ops</td><td>Pointer array containing operations to be enqueued Must have at least <code>num_ops</code> entries </td></tr>
    <tr><td class="paramname">num_ops</td><td>The maximum number of operations to enqueue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually enqueued (this is the number of processed entries in the <code>ops</code> array). </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00715">715</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="aa048e0f43fe7789745353d06fc7b1657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa048e0f43fe7789745353d06fc7b1657">&#9670;&nbsp;</a></span>rte_bbdev_dequeue_enc_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_bbdev_dequeue_enc_ops </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__enc__op.html">rte_bbdev_enc_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue a burst of processed encode operations from a queue of the device. This functions returns only the current contents of the queue, and does not block until @ num_ops is available. This function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">ops</td><td>Pointer array where operations will be dequeued to. Must have at least <code>num_ops</code> entries, i.e. a pointer to a table of void * pointers (ops) that will be filled. </td></tr>
    <tr><td class="paramname">num_ops</td><td>The maximum number of operations to dequeue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually dequeued. (This is the number of entries copied into the <code>ops</code> array.) </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00746">746</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="a95ec082a4762e04accf636885735bf5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ec082a4762e04accf636885735bf5f">&#9670;&nbsp;</a></span>rte_bbdev_dequeue_dec_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_bbdev_dequeue_dec_ops </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__dec__op.html">rte_bbdev_dec_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue a burst of processed decode operations from a queue of the device. This functions returns only the current contents of the queue, and does not block until @ num_ops is available. This function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">ops</td><td>Pointer array where operations will be dequeued to. Must have at least <code>num_ops</code> entries ie. A pointer to a table of void * pointers (ops) that will be filled. </td></tr>
    <tr><td class="paramname">num_ops</td><td>The maximum number of operations to dequeue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually dequeued (this is the number of entries copied into the <code>ops</code> array). </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00778">778</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="a795e3e8a85763099e9b2b5382201d338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795e3e8a85763099e9b2b5382201d338">&#9670;&nbsp;</a></span>rte_bbdev_dequeue_ldpc_enc_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_bbdev_dequeue_ldpc_enc_ops </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__enc__op.html">rte_bbdev_enc_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue a burst of processed encode operations from a queue of the device. This functions returns only the current contents of the queue, and does not block until @ num_ops is available. This function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">ops</td><td>Pointer array where operations will be dequeued to. Must have at least <code>num_ops</code> entries </td></tr>
    <tr><td class="paramname">num_ops</td><td>The maximum number of operations to dequeue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually dequeued (this is the number of entries copied into the <code>ops</code> array). </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00809">809</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="a52f1a88e324939b91d15b672a2a75b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f1a88e324939b91d15b672a2a75b48">&#9670;&nbsp;</a></span>rte_bbdev_dequeue_ldpc_dec_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_bbdev_dequeue_ldpc_dec_ops </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__dec__op.html">rte_bbdev_dec_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue a burst of processed decode operations from a queue of the device. This functions returns only the current contents of the queue, and does not block until @ num_ops is available. This function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">ops</td><td>Pointer array where operations will be dequeued to. Must have at least <code>num_ops</code> entries </td></tr>
    <tr><td class="paramname">num_ops</td><td>The maximum number of operations to dequeue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually dequeued (this is the number of entries copied into the <code>ops</code> array). </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00839">839</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="a256715d7d2933d8a67a789ed6dadf8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256715d7d2933d8a67a789ed6dadf8c1">&#9670;&nbsp;</a></span>rte_bbdev_dequeue_fft_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_bbdev_dequeue_fft_ops </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__fft__op.html">rte_bbdev_fft_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue a burst of FFT operations from a queue of the device. This functions returns only the current contents of the queue, and does not block until @ num_ops is available. This function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">ops</td><td>Pointer array where operations will be dequeued to. Must have at least <code>num_ops</code> entries </td></tr>
    <tr><td class="paramname">num_ops</td><td>The maximum number of operations to dequeue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually dequeued (this is the number of entries copied into the <code>ops</code> array). </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00869">869</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="aabaa7bb4b4b17357f116762627d6950a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabaa7bb4b4b17357f116762627d6950a">&#9670;&nbsp;</a></span>rte_bbdev_dequeue_mldts_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __rte_experimental uint16_t rte_bbdev_dequeue_mldts_ops </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__mldts__op.html">rte_bbdev_mldts_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue a burst of MLDTS operations from a queue of the device. This functions returns only the current contents of the queue, and does not block until <code>num_ops</code> is available. This function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">ops</td><td>Pointer array where operations will be dequeued to. Must have at least <code>num_ops</code> entries </td></tr>
    <tr><td class="paramname">num_ops</td><td>The maximum number of operations to dequeue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually dequeued (this is the number of entries copied into the <code>ops</code> array). </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00900">900</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="a26f7d65861b6bc66552a9456e91be710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f7d65861b6bc66552a9456e91be710">&#9670;&nbsp;</a></span>rte_bbdev_callback_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_bbdev_callback_register </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6">rte_bbdev_event_type</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__bbdev_8h.html#a794dc2714438a7dfe7b06cef27d87a97">rte_bbdev_cb_fn</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a callback function for specific device id. Multiple callbacks can be added and will be called in the order they are added when an event is triggered. Callbacks are called in a separate thread created by the DPDK EAL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Device id. </td></tr>
    <tr><td class="paramname">event</td><td>The event that the callback will be registered for. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>User supplied callback function to be called. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Pointer to parameter that will be passed to the callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, negative value on failure. </dd></dl>

</div>
</div>
<a id="abf683ac303b468689866fa387f077cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf683ac303b468689866fa387f077cf0">&#9670;&nbsp;</a></span>rte_bbdev_callback_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_bbdev_callback_unregister </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6">rte_bbdev_event_type</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__bbdev_8h.html#a794dc2714438a7dfe7b06cef27d87a97">rte_bbdev_cb_fn</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for specific device id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The device identifier. </td></tr>
    <tr><td class="paramname">event</td><td>The event that the callback will be unregistered for. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>User supplied callback function to be unregistered. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Pointer to the parameter supplied when registering the callback. (void *)-1 means to remove all registered callbacks with the specified function address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>EINVAL if invalid parameter pointer is provided</li>
<li>EAGAIN if the provided callback pointer does not exist </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0c39312c028d099f62b422cc8d766fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c39312c028d099f62b422cc8d766fe3">&#9670;&nbsp;</a></span>rte_bbdev_queue_intr_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_bbdev_queue_intr_enable </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable a one-shot interrupt on the next operation enqueued to a particular queue. The interrupt will be triggered when the operation is ready to be dequeued. To handle the interrupt, an epoll file descriptor must be registered using <a class="el" href="rte__bbdev_8h.html#ae128c6c582aa08fd1972a1dcdf38dd61">rte_bbdev_queue_intr_ctl()</a>, and then an application thread/lcore can wait for the interrupt using <a class="el" href="rte__epoll_8h.html#ae21a1a9a960fb68888b2a8918f73e879">rte_epoll_wait()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The device identifier. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>negative value on failure - as returned from PMD </li>
</ul>
</dd></dl>

</div>
</div>
<a id="adad26ed2e5759c8375b546cd017e6b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad26ed2e5759c8375b546cd017e6b42">&#9670;&nbsp;</a></span>rte_bbdev_queue_intr_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_bbdev_queue_intr_disable </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable a one-shot interrupt on the next operation enqueued to a particular queue (if it has been enabled).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The device identifier. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>negative value on failure - as returned from PMD </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae128c6c582aa08fd1972a1dcdf38dd61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae128c6c582aa08fd1972a1dcdf38dd61">&#9670;&nbsp;</a></span>rte_bbdev_queue_intr_ctl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_bbdev_queue_intr_ctl </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>epfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Control interface for per-queue interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The device identifier. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">epfd</td><td>Epoll file descriptor that will be associated with the interrupt source. If the special value RTE_EPOLL_PER_THREAD is provided, a per thread epoll file descriptor created by the EAL is used (RTE_EPOLL_PER_THREAD can also be used when calling <a class="el" href="rte__epoll_8h.html#ae21a1a9a960fb68888b2a8918f73e879">rte_epoll_wait()</a>). </td></tr>
    <tr><td class="paramname">op</td><td>The operation be performed for the vector.RTE_INTR_EVENT_ADD or RTE_INTR_EVENT_DEL. </td></tr>
    <tr><td class="paramname">data</td><td>User context, that will be returned in the epdata.data field of the <a class="el" href="structrte__epoll__event.html">rte_epoll_event</a> structure filled in by <a class="el" href="rte__epoll_8h.html#ae21a1a9a960fb68888b2a8918f73e879">rte_epoll_wait()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>ENOTSUP if interrupts are not supported by the identified device</li>
<li>negative value on failure - as returned from PMD </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a584c0e64cbae4540aa3dec81d251298f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584c0e64cbae4540aa3dec81d251298f">&#9670;&nbsp;</a></span>rte_bbdev_device_status_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rte_bbdev_device_status_str </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="rte__bbdev_8h.html#a02e2a03baf9cd936459801de536235a1">rte_bbdev_device_status</a>&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert device status from enum to string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Device status as enum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Device status as string or NULL if invalid. </dd></dl>

</div>
</div>
<a id="aed77dd6e901c542247844b7276756d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed77dd6e901c542247844b7276756d5e">&#9670;&nbsp;</a></span>rte_bbdev_enqueue_status_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rte_bbdev_enqueue_status_str </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="rte__bbdev_8h.html#a0cd597c6b5e212f5a01a63512a8e889f">rte_bbdev_enqueue_status</a>&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert queue status from enum to string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Queue status as enum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Queue status as string or NULL if op_type is invalid. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
