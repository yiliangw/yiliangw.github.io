<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/dispatcher/rte_dispatcher.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">23.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_33602f307eacccce57ec1e0ce60238e9.html">dispatcher</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_dispatcher.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;rte_compat.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>&gt;</code><br />
</div>
<p><a href="rte__dispatcher_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__dispatcher__stats.html">rte_dispatcher_stats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aba25c12261c64ad469b090604e8c17dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__dispatcher_8h.html#aba25c12261c64ad469b090604e8c17dc">rte_dispatcher_match_t</a>) (const struct <a class="el" href="structrte__event.html">rte_event</a> *event, void *cb_data)</td></tr>
<tr class="separator:aba25c12261c64ad469b090604e8c17dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fade430d231b403c449d44d58b23152"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__dispatcher_8h.html#a3fade430d231b403c449d44d58b23152">rte_dispatcher_process_t</a>) (uint8_t event_dev_id, uint8_t event_port_id, struct <a class="el" href="structrte__event.html">rte_event</a> *events, uint16_t num, void *cb_data)</td></tr>
<tr class="separator:a3fade430d231b403c449d44d58b23152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfd336227e5ece42ef6891dc7190d70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__dispatcher_8h.html#a6bfd336227e5ece42ef6891dc7190d70">rte_dispatcher_finalize_t</a>) (uint8_t event_dev_id, uint8_t event_port_id, void *cb_data)</td></tr>
<tr class="separator:a6bfd336227e5ece42ef6891dc7190d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab711798cc1f0b5ffe4165f58385583be"><td class="memItemLeft" align="right" valign="top">__rte_experimental struct rte_dispatcher *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__dispatcher_8h.html#ab711798cc1f0b5ffe4165f58385583be">rte_dispatcher_create</a> (uint8_t event_dev_id)</td></tr>
<tr class="separator:ab711798cc1f0b5ffe4165f58385583be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb32ccf3e5f02da8f5d42141580fb86"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__dispatcher_8h.html#a5bb32ccf3e5f02da8f5d42141580fb86">rte_dispatcher_free</a> (struct rte_dispatcher *dispatcher)</td></tr>
<tr class="separator:a5bb32ccf3e5f02da8f5d42141580fb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be807f6d35c132801adb3eaaf4775e6"><td class="memItemLeft" align="right" valign="top">__rte_experimental uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__dispatcher_8h.html#a6be807f6d35c132801adb3eaaf4775e6">rte_dispatcher_service_id_get</a> (const struct rte_dispatcher *dispatcher)</td></tr>
<tr class="separator:a6be807f6d35c132801adb3eaaf4775e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9507dc31fdf4b5ac2e64ada76f80602"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__dispatcher_8h.html#af9507dc31fdf4b5ac2e64ada76f80602">rte_dispatcher_bind_port_to_lcore</a> (struct rte_dispatcher *dispatcher, uint8_t event_port_id, uint16_t batch_size, uint64_t timeout, unsigned int lcore_id)</td></tr>
<tr class="separator:af9507dc31fdf4b5ac2e64ada76f80602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd16c8e9cdd904af149a55b5543599fb"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__dispatcher_8h.html#acd16c8e9cdd904af149a55b5543599fb">rte_dispatcher_unbind_port_from_lcore</a> (struct rte_dispatcher *dispatcher, uint8_t event_port_id, unsigned int lcore_id)</td></tr>
<tr class="separator:acd16c8e9cdd904af149a55b5543599fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d14a11b866a6789ee254f1a669e76f1"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__dispatcher_8h.html#a8d14a11b866a6789ee254f1a669e76f1">rte_dispatcher_register</a> (struct rte_dispatcher *dispatcher, <a class="el" href="rte__dispatcher_8h.html#aba25c12261c64ad469b090604e8c17dc">rte_dispatcher_match_t</a> match_fun, void *match_cb_data, <a class="el" href="rte__dispatcher_8h.html#a3fade430d231b403c449d44d58b23152">rte_dispatcher_process_t</a> process_fun, void *process_cb_data)</td></tr>
<tr class="separator:a8d14a11b866a6789ee254f1a669e76f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b7da467194d352b9b0c25b73c82cdc"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__dispatcher_8h.html#a14b7da467194d352b9b0c25b73c82cdc">rte_dispatcher_unregister</a> (struct rte_dispatcher *dispatcher, int handler_id)</td></tr>
<tr class="separator:a14b7da467194d352b9b0c25b73c82cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104b5aa5f22090c0836aa0bf073cd381"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__dispatcher_8h.html#a104b5aa5f22090c0836aa0bf073cd381">rte_dispatcher_finalize_register</a> (struct rte_dispatcher *dispatcher, <a class="el" href="rte__dispatcher_8h.html#a6bfd336227e5ece42ef6891dc7190d70">rte_dispatcher_finalize_t</a> finalize_fun, void *finalize_data)</td></tr>
<tr class="separator:a104b5aa5f22090c0836aa0bf073cd381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d22e9a2e22afe858698178e458272cc"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__dispatcher_8h.html#a8d22e9a2e22afe858698178e458272cc">rte_dispatcher_finalize_unregister</a> (struct rte_dispatcher *dispatcher, int reg_id)</td></tr>
<tr class="separator:a8d22e9a2e22afe858698178e458272cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0631f2348e4f7cd3c22b88d191dda9e9"><td class="memItemLeft" align="right" valign="top">__rte_experimental void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__dispatcher_8h.html#a0631f2348e4f7cd3c22b88d191dda9e9">rte_dispatcher_start</a> (struct rte_dispatcher *dispatcher)</td></tr>
<tr class="separator:a0631f2348e4f7cd3c22b88d191dda9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bade1d29fde4ff436c1aba45c29107e"><td class="memItemLeft" align="right" valign="top">__rte_experimental void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__dispatcher_8h.html#a6bade1d29fde4ff436c1aba45c29107e">rte_dispatcher_stop</a> (struct rte_dispatcher *dispatcher)</td></tr>
<tr class="separator:a6bade1d29fde4ff436c1aba45c29107e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01118e760f004bf45858624fdeed98ea"><td class="memItemLeft" align="right" valign="top">__rte_experimental void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__dispatcher_8h.html#a01118e760f004bf45858624fdeed98ea">rte_dispatcher_stats_get</a> (const struct rte_dispatcher *dispatcher, struct <a class="el" href="structrte__dispatcher__stats.html">rte_dispatcher_stats</a> *stats)</td></tr>
<tr class="separator:a01118e760f004bf45858624fdeed98ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fbce3a3f5625d1ec2e22675c173c7e"><td class="memItemLeft" align="right" valign="top">__rte_experimental void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__dispatcher_8h.html#a54fbce3a3f5625d1ec2e22675c173c7e">rte_dispatcher_stats_reset</a> (struct rte_dispatcher *dispatcher)</td></tr>
<tr class="separator:a54fbce3a3f5625d1ec2e22675c173c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE Dispatcher</p>
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> All functions in this file may be changed or removed without prior notice.</dd></dl>
<p>The purpose of the dispatcher is to help decouple different parts of an application (e.g., modules), sharing the same underlying event device. </p>

<p class="definition">Definition in file <a class="el" href="rte__dispatcher_8h_source.html">rte_dispatcher.h</a>.</p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aba25c12261c64ad469b090604e8c17dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba25c12261c64ad469b090604e8c17dc">&#9670;&nbsp;</a></span>rte_dispatcher_match_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> bool(* rte_dispatcher_match_t) (const struct <a class="el" href="structrte__event.html">rte_event</a> *event, void *cb_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function prototype for match callbacks.</p>
<p>Match callbacks are used by an application to decide how the dispatcher distributes events to different parts of the application.</p>
<p>The application is not expected to process the event at the point of the match call. Such matters should be deferred to the process callback invocation.</p>
<p>The match callback may be used as an opportunity to prefetch data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Pointer to event</td></tr>
    <tr><td class="paramname">cb_data</td><td>The pointer supplied by the application in <a class="el" href="rte__dispatcher_8h.html#a8d14a11b866a6789ee254f1a669e76f1">rte_dispatcher_register()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true in case this event should be delivered (via the process callback), and false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__dispatcher_8h_source.html#l00056">56</a> of file <a class="el" href="rte__dispatcher_8h_source.html">rte_dispatcher.h</a>.</p>

</div>
</div>
<a id="a3fade430d231b403c449d44d58b23152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fade430d231b403c449d44d58b23152">&#9670;&nbsp;</a></span>rte_dispatcher_process_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void(* rte_dispatcher_process_t) (uint8_t event_dev_id, uint8_t event_port_id, struct <a class="el" href="structrte__event.html">rte_event</a> *events, uint16_t num, void *cb_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function prototype for process callbacks.</p>
<p>The process callbacks are used by the dispatcher to deliver events for processing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_dev_id</td><td>The originating event device id.</td></tr>
    <tr><td class="paramname">event_port_id</td><td>The originating event port.</td></tr>
    <tr><td class="paramname">events</td><td>Pointer to an array of events.</td></tr>
    <tr><td class="paramname">num</td><td>The number of events in the <code>events</code> array.</td></tr>
    <tr><td class="paramname">cb_data</td><td>The pointer supplied by the application in <a class="el" href="rte__dispatcher_8h.html#a8d14a11b866a6789ee254f1a669e76f1">rte_dispatcher_register()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__dispatcher_8h_source.html#l00081">81</a> of file <a class="el" href="rte__dispatcher_8h_source.html">rte_dispatcher.h</a>.</p>

</div>
</div>
<a id="a6bfd336227e5ece42ef6891dc7190d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfd336227e5ece42ef6891dc7190d70">&#9670;&nbsp;</a></span>rte_dispatcher_finalize_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void(* rte_dispatcher_finalize_t) (uint8_t event_dev_id, uint8_t event_port_id, void *cb_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function prototype for finalize callbacks.</p>
<p>The finalize callbacks are used by the dispatcher to notify the application it has delivered all events from a particular batch dequeued from the event device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_dev_id</td><td>The originating event device id.</td></tr>
    <tr><td class="paramname">event_port_id</td><td>The originating event port.</td></tr>
    <tr><td class="paramname">cb_data</td><td>The pointer supplied by the application in <a class="el" href="rte__dispatcher_8h.html#a104b5aa5f22090c0836aa0bf073cd381">rte_dispatcher_finalize_register()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__dispatcher_8h_source.html#l00102">102</a> of file <a class="el" href="rte__dispatcher_8h_source.html">rte_dispatcher.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab711798cc1f0b5ffe4165f58385583be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab711798cc1f0b5ffe4165f58385583be">&#9670;&nbsp;</a></span>rte_dispatcher_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental struct rte_dispatcher* rte_dispatcher_create </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>event_dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a dispatcher with the specified id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_dev_id</td><td>The identifier of the event device from which this dispatcher will dequeue events.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new dispatcher instance, or NULL on failure, in which case rte_errno is set. </dd></dl>

</div>
</div>
<a id="a5bb32ccf3e5f02da8f5d42141580fb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb32ccf3e5f02da8f5d42141580fb86">&#9670;&nbsp;</a></span>rte_dispatcher_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_dispatcher_free </td>
          <td>(</td>
          <td class="paramtype">struct rte_dispatcher *&#160;</td>
          <td class="paramname"><em>dispatcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a dispatcher.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dispatcher</td><td>The dispatcher instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success</li>
<li>&lt;0: Error code on failure </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6be807f6d35c132801adb3eaaf4775e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be807f6d35c132801adb3eaaf4775e6">&#9670;&nbsp;</a></span>rte_dispatcher_service_id_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental uint32_t rte_dispatcher_service_id_get </td>
          <td>(</td>
          <td class="paramtype">const struct rte_dispatcher *&#160;</td>
          <td class="paramname"><em>dispatcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the service identifier of a dispatcher.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dispatcher</td><td>The dispatcher instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dispatcher service's id. </dd></dl>

</div>
</div>
<a id="af9507dc31fdf4b5ac2e64ada76f80602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9507dc31fdf4b5ac2e64ada76f80602">&#9670;&nbsp;</a></span>rte_dispatcher_bind_port_to_lcore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_dispatcher_bind_port_to_lcore </td>
          <td>(</td>
          <td class="paramtype">struct rte_dispatcher *&#160;</td>
          <td class="paramname"><em>dispatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>event_port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>lcore_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binds an event device port to a specific lcore on the specified dispatcher.</p>
<p>This function configures the event port id to be used by the event dispatcher service, if run on the specified lcore.</p>
<p>Multiple event device ports may be bound to the same lcore. A particular port must not be bound to more than one lcore.</p>
<p>If the dispatcher service is mapped (with <a class="el" href="rte__service_8h.html#abd84092ba697aaf2bfeb414b80b72076">rte_service_map_lcore_set()</a>) to a lcore to which no ports are bound, the service function will be a no-operation.</p>
<p>This function may be called by any thread (including unregistered non-EAL threads), but not while the dispatcher is running on lcore specified by <code>lcore_id</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dispatcher</td><td>The dispatcher instance.</td></tr>
    <tr><td class="paramname">event_port_id</td><td>The event device port identifier.</td></tr>
    <tr><td class="paramname">batch_size</td><td>The batch size to use in <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a>, for the configured event device port and lcore.</td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout parameter to use in <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a>, for the configured event device port and lcore.</td></tr>
    <tr><td class="paramname">lcore_id</td><td>The lcore by which this event port will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success</li>
<li>-ENOMEM: Unable to allocate sufficient resources.</li>
<li>-EEXISTS: Event port is already configured.</li>
<li>-EINVAL: Invalid arguments. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="acd16c8e9cdd904af149a55b5543599fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd16c8e9cdd904af149a55b5543599fb">&#9670;&nbsp;</a></span>rte_dispatcher_unbind_port_from_lcore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_dispatcher_unbind_port_from_lcore </td>
          <td>(</td>
          <td class="paramtype">struct rte_dispatcher *&#160;</td>
          <td class="paramname"><em>dispatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>event_port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>lcore_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unbind an event device port from a specific lcore.</p>
<p>This function may be called by any thread (including unregistered non-EAL threads), but not while the dispatcher is running on lcore specified by <code>lcore_id</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dispatcher</td><td>The dispatcher instance.</td></tr>
    <tr><td class="paramname">event_port_id</td><td>The event device port identifier.</td></tr>
    <tr><td class="paramname">lcore_id</td><td>The lcore which was using this event port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success</li>
<li>-ENOENT: Event port id not bound to this <code>lcore_id</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8d14a11b866a6789ee254f1a669e76f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d14a11b866a6789ee254f1a669e76f1">&#9670;&nbsp;</a></span>rte_dispatcher_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_dispatcher_register </td>
          <td>(</td>
          <td class="paramtype">struct rte_dispatcher *&#160;</td>
          <td class="paramname"><em>dispatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__dispatcher_8h.html#aba25c12261c64ad469b090604e8c17dc">rte_dispatcher_match_t</a>&#160;</td>
          <td class="paramname"><em>match_fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>match_cb_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__dispatcher_8h.html#a3fade430d231b403c449d44d58b23152">rte_dispatcher_process_t</a>&#160;</td>
          <td class="paramname"><em>process_fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>process_cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register an event handler.</p>
<p>The match callback function is used to select if a particular event should be delivered, using the corresponding process callback function.</p>
<p>The reason for having two distinct steps is to allow the dispatcher to deliver all events as a batch. This in turn will cause processing of a particular kind of events to happen in a back-to-back manner, improving cache locality.</p>
<p>The list of handler callback functions is shared among all lcores, but will only be executed on lcores which has an eventdev port bound to them, and which are running the dispatcher service.</p>
<p>An event is delivered to at most one handler. Events where no handler is found are dropped.</p>
<p>The application must not depend on the order of which the match functions are invoked.</p>
<p>Ordering of events is not guaranteed to be maintained between different deliver callbacks. For example, suppose there are two callbacks registered, matching different subsets of events arriving on an atomic queue. A batch of events [ev0, ev1, ev2] are dequeued on a particular port, all pertaining to the same flow. The match callback for registration A returns true for ev0 and ev2, and the matching function for registration B for ev1. In that scenario, the dispatcher may choose to deliver first [ev0, ev2] using A's deliver function, and then [ev1] to B - or vice versa.</p>
<p><a class="el" href="rte__dispatcher_8h.html#a8d14a11b866a6789ee254f1a669e76f1">rte_dispatcher_register()</a> may be called by any thread (including unregistered non-EAL threads), but not while the event dispatcher is running on any service lcore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dispatcher</td><td>The dispatcher instance.</td></tr>
    <tr><td class="paramname">match_fun</td><td>The match callback function.</td></tr>
    <tr><td class="paramname">match_cb_data</td><td>A pointer to some application-specific opaque data (or NULL), which is supplied back to the application when match_fun is called.</td></tr>
    <tr><td class="paramname">process_fun</td><td>The process callback function.</td></tr>
    <tr><td class="paramname">process_cb_data</td><td>A pointer to some application-specific opaque data (or NULL), which is supplied back to the application when process_fun is called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>&gt;= 0: The identifier for this registration.</li>
<li>-ENOMEM: Unable to allocate sufficient resources. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a14b7da467194d352b9b0c25b73c82cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b7da467194d352b9b0c25b73c82cdc">&#9670;&nbsp;</a></span>rte_dispatcher_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_dispatcher_unregister </td>
          <td>(</td>
          <td class="paramtype">struct rte_dispatcher *&#160;</td>
          <td class="paramname"><em>dispatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>handler_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister an event handler.</p>
<p>This function may be called by any thread (including unregistered non-EAL threads), but not while the dispatcher is running on any service lcore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dispatcher</td><td>The dispatcher instance.</td></tr>
    <tr><td class="paramname">handler_id</td><td>The handler registration id returned by the original <a class="el" href="rte__dispatcher_8h.html#a8d14a11b866a6789ee254f1a669e76f1">rte_dispatcher_register()</a> call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success</li>
<li>-EINVAL: The <code>handler_id</code> parameter was invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a104b5aa5f22090c0836aa0bf073cd381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104b5aa5f22090c0836aa0bf073cd381">&#9670;&nbsp;</a></span>rte_dispatcher_finalize_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_dispatcher_finalize_register </td>
          <td>(</td>
          <td class="paramtype">struct rte_dispatcher *&#160;</td>
          <td class="paramname"><em>dispatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__dispatcher_8h.html#a6bfd336227e5ece42ef6891dc7190d70">rte_dispatcher_finalize_t</a>&#160;</td>
          <td class="paramname"><em>finalize_fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>finalize_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a finalize callback function.</p>
<p>An application may optionally install one or more finalize callbacks.</p>
<p>All finalize callbacks are invoked by the dispatcher when a complete batch of events (retrieve using <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a>) have been delivered to the application (or have been dropped).</p>
<p>The finalize callback is not tied to any particular handler.</p>
<p>The finalize callback provides an opportunity for the application to do per-batch processing. One case where this may be useful is if an event output buffer is used, and is shared among several handlers. In such a case, proper output buffer flushing may be assured using a finalize callback.</p>
<p><a class="el" href="rte__dispatcher_8h.html#a104b5aa5f22090c0836aa0bf073cd381">rte_dispatcher_finalize_register()</a> may be called by any thread (including unregistered non-EAL threads), but not while the dispatcher is running on any service lcore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dispatcher</td><td>The dispatcher instance.</td></tr>
    <tr><td class="paramname">finalize_fun</td><td>The function called after completing the processing of a dequeue batch.</td></tr>
    <tr><td class="paramname">finalize_data</td><td>A pointer to some application-specific opaque data (or NULL), which is supplied back to the application when <code>finalize_fun</code> is called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>&gt;= 0: The identifier for this registration.</li>
<li>-ENOMEM: Unable to allocate sufficient resources. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8d22e9a2e22afe858698178e458272cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d22e9a2e22afe858698178e458272cc">&#9670;&nbsp;</a></span>rte_dispatcher_finalize_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_dispatcher_finalize_unregister </td>
          <td>(</td>
          <td class="paramtype">struct rte_dispatcher *&#160;</td>
          <td class="paramname"><em>dispatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reg_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a finalize callback.</p>
<p>This function may be called by any thread (including unregistered non-EAL threads), but not while the dispatcher is running on any service lcore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dispatcher</td><td>The dispatcher instance.</td></tr>
    <tr><td class="paramname">reg_id</td><td>The finalize registration id returned by the original <a class="el" href="rte__dispatcher_8h.html#a104b5aa5f22090c0836aa0bf073cd381">rte_dispatcher_finalize_register()</a> call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success</li>
<li>-EINVAL: The <code>reg_id</code> parameter was invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0631f2348e4f7cd3c22b88d191dda9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0631f2348e4f7cd3c22b88d191dda9e9">&#9670;&nbsp;</a></span>rte_dispatcher_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental void rte_dispatcher_start </td>
          <td>(</td>
          <td class="paramtype">struct rte_dispatcher *&#160;</td>
          <td class="paramname"><em>dispatcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start a dispatcher instance.</p>
<p>Enables the dispatcher service.</p>
<p>The underlying event device must have been started prior to calling <a class="el" href="rte__dispatcher_8h.html#a0631f2348e4f7cd3c22b88d191dda9e9">rte_dispatcher_start()</a>.</p>
<p>For the dispatcher to actually perform work (i.e., dispatch events), its service must have been mapped to one or more service lcores, and its service run state set to '1'. A dispatcher's service is retrieved using <a class="el" href="rte__dispatcher_8h.html#a6be807f6d35c132801adb3eaaf4775e6">rte_dispatcher_service_id_get()</a>.</p>
<p>Each service lcore to which the dispatcher is mapped should have at least one event port configured. Such configuration is performed by calling <a class="el" href="rte__dispatcher_8h.html#af9507dc31fdf4b5ac2e64ada76f80602">rte_dispatcher_bind_port_to_lcore()</a>, prior to starting the dispatcher.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dispatcher</td><td>The dispatcher instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bade1d29fde4ff436c1aba45c29107e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bade1d29fde4ff436c1aba45c29107e">&#9670;&nbsp;</a></span>rte_dispatcher_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental void rte_dispatcher_stop </td>
          <td>(</td>
          <td class="paramtype">struct rte_dispatcher *&#160;</td>
          <td class="paramname"><em>dispatcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop a running dispatcher instance.</p>
<p>Disables the dispatcher service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dispatcher</td><td>The dispatcher instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01118e760f004bf45858624fdeed98ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01118e760f004bf45858624fdeed98ea">&#9670;&nbsp;</a></span>rte_dispatcher_stats_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental void rte_dispatcher_stats_get </td>
          <td>(</td>
          <td class="paramtype">const struct rte_dispatcher *&#160;</td>
          <td class="paramname"><em>dispatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__dispatcher__stats.html">rte_dispatcher_stats</a> *&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve statistics for a dispatcher instance.</p>
<p>This function is MT safe and may be called by any thread (including unregistered non-EAL threads).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dispatcher</td><td>The dispatcher instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stats</td><td>A pointer to a structure to fill with statistics. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54fbce3a3f5625d1ec2e22675c173c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fbce3a3f5625d1ec2e22675c173c7e">&#9670;&nbsp;</a></span>rte_dispatcher_stats_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental void rte_dispatcher_stats_reset </td>
          <td>(</td>
          <td class="paramtype">struct rte_dispatcher *&#160;</td>
          <td class="paramname"><em>dispatcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset statistics for a dispatcher instance.</p>
<p>This function may be called by any thread (including unregistered non-EAL threads), but may not produce the correct result if the dispatcher is running on any service lcore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dispatcher</td><td>The dispatcher instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
