<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/eal/include/rte_interrupts.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">23.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_128b0d86a58fb45249214ca3dc74cbc9.html">eal</a></li><li class="navelem"><a class="el" href="dir_ae2f63391bb292b7e8558f7d4adaae63.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_interrupts.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__bitops_8h_source.html">rte_bitops.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__common_8h_source.html">rte_common.h</a>&gt;</code><br />
<code>#include &lt;rte_compat.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__epoll_8h_source.html">rte_epoll.h</a>&gt;</code><br />
</div>
<p><a href="rte__interrupts_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a644f5ead3e7a3168c97ee47e0e1ade0f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__interrupts_8h.html#a644f5ead3e7a3168c97ee47e0e1ade0f">RTE_INTR_INSTANCE_F_PRIVATE</a>&#160;&#160;&#160;UINT32_C(0)</td></tr>
<tr class="separator:a644f5ead3e7a3168c97ee47e0e1ade0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d960aa74420287c04dfdca367a8ab2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__interrupts_8h.html#a12d960aa74420287c04dfdca367a8ab2">RTE_INTR_INSTANCE_F_SHARED</a>&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(0)</td></tr>
<tr class="separator:a12d960aa74420287c04dfdca367a8ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a31bb1d98300a1c14cf799f8a5059781f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__interrupts_8h.html#a31bb1d98300a1c14cf799f8a5059781f">rte_intr_callback_fn</a>) (void *cb_arg)</td></tr>
<tr class="separator:a31bb1d98300a1c14cf799f8a5059781f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac213deb8ff03ccb7250ab1c9b7b6ac7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__interrupts_8h.html#ac213deb8ff03ccb7250ab1c9b7b6ac7f">rte_intr_unregister_callback_fn</a>) (struct rte_intr_handle *intr_handle, void *cb_arg)</td></tr>
<tr class="separator:ac213deb8ff03ccb7250ab1c9b7b6ac7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a860581f3cd6203dc5a4b06635f010352"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__interrupts_8h.html#a860581f3cd6203dc5a4b06635f010352">rte_intr_handle_type</a> { <br />
&#160;&#160;<a class="el" href="rte__interrupts_8h.html#a860581f3cd6203dc5a4b06635f010352a5101fe8c5ad1848291a68cf72f405fe5">RTE_INTR_HANDLE_UNKNOWN</a> = 0
, <a class="el" href="rte__interrupts_8h.html#a860581f3cd6203dc5a4b06635f010352a942f6695c70f130a4a489ef044e127cb">RTE_INTR_HANDLE_UIO</a>
, <a class="el" href="rte__interrupts_8h.html#a860581f3cd6203dc5a4b06635f010352a8482f5a61f915061287d9579eed4708e">RTE_INTR_HANDLE_UIO_INTX</a>
, <a class="el" href="rte__interrupts_8h.html#a860581f3cd6203dc5a4b06635f010352a72fb5662a6a24aa16e74c783b578b266">RTE_INTR_HANDLE_VFIO_LEGACY</a>
, <br />
&#160;&#160;<a class="el" href="rte__interrupts_8h.html#a860581f3cd6203dc5a4b06635f010352ab4a778174cfe395c89e8d8b3c4676c44">RTE_INTR_HANDLE_VFIO_MSI</a>
, <a class="el" href="rte__interrupts_8h.html#a860581f3cd6203dc5a4b06635f010352ac66a19a8904e839e51f2849963b8ba53">RTE_INTR_HANDLE_VFIO_MSIX</a>
, <a class="el" href="rte__interrupts_8h.html#a860581f3cd6203dc5a4b06635f010352af46d6c801008eb8c7840ff5c47983dfb">RTE_INTR_HANDLE_ALARM</a>
, <a class="el" href="rte__interrupts_8h.html#a860581f3cd6203dc5a4b06635f010352a4414e83b1ef139eba09514ed32360df1">RTE_INTR_HANDLE_EXT</a>
, <br />
&#160;&#160;<a class="el" href="rte__interrupts_8h.html#a860581f3cd6203dc5a4b06635f010352ac3cd0adb9cdc11c5af64f91b7227ab73">RTE_INTR_HANDLE_VDEV</a>
, <a class="el" href="rte__interrupts_8h.html#a860581f3cd6203dc5a4b06635f010352a845a90c15820229c62e2934bd07bba18">RTE_INTR_HANDLE_DEV_EVENT</a>
, <a class="el" href="rte__interrupts_8h.html#a860581f3cd6203dc5a4b06635f010352ae611c202db41745942372a9b2c304d63">RTE_INTR_HANDLE_VFIO_REQ</a>
, <a class="el" href="rte__interrupts_8h.html#a860581f3cd6203dc5a4b06635f010352a56c83e50ccb1ae026a00d529104a7858">RTE_INTR_HANDLE_MAX</a>
<br />
 }</td></tr>
<tr class="separator:a860581f3cd6203dc5a4b06635f010352"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aad9b0f7aba69737aeaf5f027ff346760"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__interrupts_8h.html#aad9b0f7aba69737aeaf5f027ff346760">rte_intr_callback_register</a> (const struct rte_intr_handle *intr_handle, <a class="el" href="rte__interrupts_8h.html#a31bb1d98300a1c14cf799f8a5059781f">rte_intr_callback_fn</a> cb, void *cb_arg)</td></tr>
<tr class="separator:aad9b0f7aba69737aeaf5f027ff346760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e40f28b2609ed59ea5e2e49d98cc5d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__interrupts_8h.html#a6e40f28b2609ed59ea5e2e49d98cc5d1">rte_intr_callback_unregister</a> (const struct rte_intr_handle *intr_handle, <a class="el" href="rte__interrupts_8h.html#a31bb1d98300a1c14cf799f8a5059781f">rte_intr_callback_fn</a> cb, void *cb_arg)</td></tr>
<tr class="separator:a6e40f28b2609ed59ea5e2e49d98cc5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552a2bad6b523feba0df851aa377afaf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__interrupts_8h.html#a552a2bad6b523feba0df851aa377afaf">rte_intr_callback_unregister_pending</a> (const struct rte_intr_handle *intr_handle, <a class="el" href="rte__interrupts_8h.html#a31bb1d98300a1c14cf799f8a5059781f">rte_intr_callback_fn</a> cb_fn, void *cb_arg, <a class="el" href="rte__interrupts_8h.html#ac213deb8ff03ccb7250ab1c9b7b6ac7f">rte_intr_unregister_callback_fn</a> ucb_fn)</td></tr>
<tr class="separator:a552a2bad6b523feba0df851aa377afaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8ce8ea116075eaf07e8e275d639d5a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__interrupts_8h.html#a7a8ce8ea116075eaf07e8e275d639d5a">rte_intr_callback_unregister_sync</a> (const struct rte_intr_handle *intr_handle, <a class="el" href="rte__interrupts_8h.html#a31bb1d98300a1c14cf799f8a5059781f">rte_intr_callback_fn</a> cb, void *cb_arg)</td></tr>
<tr class="separator:a7a8ce8ea116075eaf07e8e275d639d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f9d7120379660720e6a214ad8ed727"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__interrupts_8h.html#af7f9d7120379660720e6a214ad8ed727">rte_intr_enable</a> (const struct rte_intr_handle *intr_handle)</td></tr>
<tr class="separator:af7f9d7120379660720e6a214ad8ed727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffea470eecb509794b313564fc1129f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__interrupts_8h.html#a0ffea470eecb509794b313564fc1129f">rte_intr_disable</a> (const struct rte_intr_handle *intr_handle)</td></tr>
<tr class="separator:a0ffea470eecb509794b313564fc1129f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9c8017ce9a4975c847eda98dc0eb61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__interrupts_8h.html#aec9c8017ce9a4975c847eda98dc0eb61">rte_intr_ack</a> (const struct rte_intr_handle *intr_handle)</td></tr>
<tr class="separator:aec9c8017ce9a4975c847eda98dc0eb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad979acf202481bcc69adf7a29e7976ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__interrupts_8h.html#ad979acf202481bcc69adf7a29e7976ab">rte_thread_is_intr</a> (void)</td></tr>
<tr class="separator:ad979acf202481bcc69adf7a29e7976ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71bcbafc9f44674d15aa51a3b76f452"><td class="memItemLeft" align="right" valign="top">struct rte_intr_handle *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__interrupts_8h.html#ad71bcbafc9f44674d15aa51a3b76f452">rte_intr_instance_alloc</a> (uint32_t flags)</td></tr>
<tr class="separator:ad71bcbafc9f44674d15aa51a3b76f452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1856d1eb2cbd17f1ae06bf49cd146a32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__interrupts_8h.html#a1856d1eb2cbd17f1ae06bf49cd146a32">rte_intr_instance_free</a> (struct rte_intr_handle *intr_handle)</td></tr>
<tr class="separator:a1856d1eb2cbd17f1ae06bf49cd146a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2cac5de7485e8a2d75ef1c65e13e1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__interrupts_8h.html#a3b2cac5de7485e8a2d75ef1c65e13e1b">rte_intr_fd_set</a> (struct rte_intr_handle *intr_handle, int fd)</td></tr>
<tr class="separator:a3b2cac5de7485e8a2d75ef1c65e13e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bb99a9cda11f323604a9bb1f2916dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__interrupts_8h.html#aa7bb99a9cda11f323604a9bb1f2916dd">rte_intr_fd_get</a> (const struct rte_intr_handle *intr_handle)</td></tr>
<tr class="separator:aa7bb99a9cda11f323604a9bb1f2916dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667539655330facabc457adfe80dd4ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__interrupts_8h.html#a667539655330facabc457adfe80dd4ba">rte_intr_type_set</a> (struct rte_intr_handle *intr_handle, enum <a class="el" href="rte__interrupts_8h.html#a860581f3cd6203dc5a4b06635f010352">rte_intr_handle_type</a> type)</td></tr>
<tr class="separator:a667539655330facabc457adfe80dd4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db3ed1b6908dc19c1a2ccf672cd41f4"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="rte__interrupts_8h.html#a860581f3cd6203dc5a4b06635f010352">rte_intr_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__interrupts_8h.html#a1db3ed1b6908dc19c1a2ccf672cd41f4">rte_intr_type_get</a> (const struct rte_intr_handle *intr_handle)</td></tr>
<tr class="separator:a1db3ed1b6908dc19c1a2ccf672cd41f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The RTE interrupt interface provides functions to register/unregister callbacks for a specific interrupt. </p>

<p class="definition">Definition in file <a class="el" href="rte__interrupts_8h_source.html">rte_interrupts.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a644f5ead3e7a3168c97ee47e0e1ade0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644f5ead3e7a3168c97ee47e0e1ade0f">&#9670;&nbsp;</a></span>RTE_INTR_INSTANCE_F_PRIVATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_INTR_INSTANCE_F_PRIVATE&#160;&#160;&#160;UINT32_C(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interrupt instance allocation flags </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__interrupts_8h.html#ad71bcbafc9f44674d15aa51a3b76f452">rte_intr_instance_alloc</a> Interrupt instance will not be shared between primary and secondary processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__interrupts_8h_source.html#l00034">34</a> of file <a class="el" href="rte__interrupts_8h_source.html">rte_interrupts.h</a>.</p>

</div>
</div>
<a id="a12d960aa74420287c04dfdca367a8ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d960aa74420287c04dfdca367a8ab2">&#9670;&nbsp;</a></span>RTE_INTR_INSTANCE_F_SHARED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_INTR_INSTANCE_F_SHARED&#160;&#160;&#160;<a class="el" href="rte__bitops_8h.html#a37f9af72fe78df9da448d9ded7b051c0">RTE_BIT32</a>(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interrupt instance will be shared between primary and secondary processes. </p>

<p class="definition">Definition at line <a class="el" href="rte__interrupts_8h_source.html#l00036">36</a> of file <a class="el" href="rte__interrupts_8h_source.html">rte_interrupts.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a31bb1d98300a1c14cf799f8a5059781f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31bb1d98300a1c14cf799f8a5059781f">&#9670;&nbsp;</a></span>rte_intr_callback_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void(* rte_intr_callback_fn) (void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to be registered for the specific interrupt </p>

<p class="definition">Definition at line <a class="el" href="rte__interrupts_8h_source.html#l00061">61</a> of file <a class="el" href="rte__interrupts_8h_source.html">rte_interrupts.h</a>.</p>

</div>
</div>
<a id="ac213deb8ff03ccb7250ab1c9b7b6ac7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac213deb8ff03ccb7250ab1c9b7b6ac7f">&#9670;&nbsp;</a></span>rte_intr_unregister_callback_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void(* rte_intr_unregister_callback_fn) (struct rte_intr_handle *intr_handle, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to call after a callback is unregistered. Can be used to close fd and free cb_arg. </p>

<p class="definition">Definition at line <a class="el" href="rte__interrupts_8h_source.html#l00067">67</a> of file <a class="el" href="rte__interrupts_8h_source.html">rte_interrupts.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a860581f3cd6203dc5a4b06635f010352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860581f3cd6203dc5a4b06635f010352">&#9670;&nbsp;</a></span>rte_intr_handle_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__interrupts_8h.html#a860581f3cd6203dc5a4b06635f010352">rte_intr_handle_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The interrupt source type, e.g. UIO, VFIO, ALARM etc. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a860581f3cd6203dc5a4b06635f010352a5101fe8c5ad1848291a68cf72f405fe5"></a>RTE_INTR_HANDLE_UNKNOWN&#160;</td><td class="fielddoc"><p>generic unknown handle </p>
</td></tr>
<tr><td class="fieldname"><a id="a860581f3cd6203dc5a4b06635f010352a942f6695c70f130a4a489ef044e127cb"></a>RTE_INTR_HANDLE_UIO&#160;</td><td class="fielddoc"><p>uio device handle </p>
</td></tr>
<tr><td class="fieldname"><a id="a860581f3cd6203dc5a4b06635f010352a8482f5a61f915061287d9579eed4708e"></a>RTE_INTR_HANDLE_UIO_INTX&#160;</td><td class="fielddoc"><p>uio generic handle </p>
</td></tr>
<tr><td class="fieldname"><a id="a860581f3cd6203dc5a4b06635f010352a72fb5662a6a24aa16e74c783b578b266"></a>RTE_INTR_HANDLE_VFIO_LEGACY&#160;</td><td class="fielddoc"><p>vfio device handle (legacy) </p>
</td></tr>
<tr><td class="fieldname"><a id="a860581f3cd6203dc5a4b06635f010352ab4a778174cfe395c89e8d8b3c4676c44"></a>RTE_INTR_HANDLE_VFIO_MSI&#160;</td><td class="fielddoc"><p>vfio device handle (MSI) </p>
</td></tr>
<tr><td class="fieldname"><a id="a860581f3cd6203dc5a4b06635f010352ac66a19a8904e839e51f2849963b8ba53"></a>RTE_INTR_HANDLE_VFIO_MSIX&#160;</td><td class="fielddoc"><p>vfio device handle (MSIX) </p>
</td></tr>
<tr><td class="fieldname"><a id="a860581f3cd6203dc5a4b06635f010352af46d6c801008eb8c7840ff5c47983dfb"></a>RTE_INTR_HANDLE_ALARM&#160;</td><td class="fielddoc"><p>alarm handle </p>
</td></tr>
<tr><td class="fieldname"><a id="a860581f3cd6203dc5a4b06635f010352a4414e83b1ef139eba09514ed32360df1"></a>RTE_INTR_HANDLE_EXT&#160;</td><td class="fielddoc"><p>external handler </p>
</td></tr>
<tr><td class="fieldname"><a id="a860581f3cd6203dc5a4b06635f010352ac3cd0adb9cdc11c5af64f91b7227ab73"></a>RTE_INTR_HANDLE_VDEV&#160;</td><td class="fielddoc"><p>virtual device </p>
</td></tr>
<tr><td class="fieldname"><a id="a860581f3cd6203dc5a4b06635f010352a845a90c15820229c62e2934bd07bba18"></a>RTE_INTR_HANDLE_DEV_EVENT&#160;</td><td class="fielddoc"><p>device event handle </p>
</td></tr>
<tr><td class="fieldname"><a id="a860581f3cd6203dc5a4b06635f010352ae611c202db41745942372a9b2c304d63"></a>RTE_INTR_HANDLE_VFIO_REQ&#160;</td><td class="fielddoc"><p>VFIO request handle </p>
</td></tr>
<tr><td class="fieldname"><a id="a860581f3cd6203dc5a4b06635f010352a56c83e50ccb1ae026a00d529104a7858"></a>RTE_INTR_HANDLE_MAX&#160;</td><td class="fielddoc"><p>count of elements </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__interrupts_8h_source.html#l00045">45</a> of file <a class="el" href="rte__interrupts_8h_source.html">rte_interrupts.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aad9b0f7aba69737aeaf5f027ff346760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9b0f7aba69737aeaf5f027ff346760">&#9670;&nbsp;</a></span>rte_intr_callback_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_intr_callback_register </td>
          <td>(</td>
          <td class="paramtype">const struct rte_intr_handle *&#160;</td>
          <td class="paramname"><em>intr_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__interrupts_8h.html#a31bb1d98300a1c14cf799f8a5059781f">rte_intr_callback_fn</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It registers the callback for the specific interrupt. Multiple callbacks can be registered at the same time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr_handle</td><td>Pointer to the interrupt handle. </td></tr>
    <tr><td class="paramname">cb</td><td>callback address. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>address of parameter for callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, zero.</li>
<li>On failure, a negative value. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6e40f28b2609ed59ea5e2e49d98cc5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e40f28b2609ed59ea5e2e49d98cc5d1">&#9670;&nbsp;</a></span>rte_intr_callback_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_intr_callback_unregister </td>
          <td>(</td>
          <td class="paramtype">const struct rte_intr_handle *&#160;</td>
          <td class="paramname"><em>intr_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__interrupts_8h.html#a31bb1d98300a1c14cf799f8a5059781f">rte_intr_callback_fn</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It unregisters the callback according to the specified interrupt handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr_handle</td><td>pointer to the interrupt handle. </td></tr>
    <tr><td class="paramname">cb</td><td>callback address. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>address of parameter for callback, (void *)-1 means to remove all registered which has the same callback address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, return the number of callback entities removed.</li>
<li>On failure, a negative value. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a552a2bad6b523feba0df851aa377afaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a552a2bad6b523feba0df851aa377afaf">&#9670;&nbsp;</a></span>rte_intr_callback_unregister_pending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_intr_callback_unregister_pending </td>
          <td>(</td>
          <td class="paramtype">const struct rte_intr_handle *&#160;</td>
          <td class="paramname"><em>intr_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__interrupts_8h.html#a31bb1d98300a1c14cf799f8a5059781f">rte_intr_callback_fn</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__interrupts_8h.html#ac213deb8ff03ccb7250ab1c9b7b6ac7f">rte_intr_unregister_callback_fn</a>&#160;</td>
          <td class="paramname"><em>ucb_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister the callback according to the specified interrupt handle, after it's no longer active. Fail if source is not active.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr_handle</td><td>pointer to the interrupt handle. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback address. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>address of parameter for callback, (void *)-1 means to remove all registered which has the same callback address. </td></tr>
    <tr><td class="paramname">ucb_fn</td><td>callback to call before cb is unregistered (optional). can be used to close fd and free cb_arg.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, return the number of callback entities marked for remove.</li>
<li>On failure, a negative value. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7a8ce8ea116075eaf07e8e275d639d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8ce8ea116075eaf07e8e275d639d5a">&#9670;&nbsp;</a></span>rte_intr_callback_unregister_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_intr_callback_unregister_sync </td>
          <td>(</td>
          <td class="paramtype">const struct rte_intr_handle *&#160;</td>
          <td class="paramname"><em>intr_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__interrupts_8h.html#a31bb1d98300a1c14cf799f8a5059781f">rte_intr_callback_fn</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loop until <a class="el" href="rte__interrupts_8h.html#a6e40f28b2609ed59ea5e2e49d98cc5d1">rte_intr_callback_unregister()</a> succeeds. After a call to this function, the callback provided by the specified interrupt handle is unregistered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr_handle</td><td>pointer to the interrupt handle. </td></tr>
    <tr><td class="paramname">cb</td><td>callback address. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>address of parameter for callback, (void *)-1 means to remove all registered which has the same callback address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, return the number of callback entities removed.</li>
<li>On failure, a negative value. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af7f9d7120379660720e6a214ad8ed727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f9d7120379660720e6a214ad8ed727">&#9670;&nbsp;</a></span>rte_intr_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_intr_enable </td>
          <td>(</td>
          <td class="paramtype">const struct rte_intr_handle *&#160;</td>
          <td class="paramname"><em>intr_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It enables the interrupt for the specified handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr_handle</td><td>pointer to the interrupt handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, zero.</li>
<li>On failure, a negative value. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0ffea470eecb509794b313564fc1129f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ffea470eecb509794b313564fc1129f">&#9670;&nbsp;</a></span>rte_intr_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_intr_disable </td>
          <td>(</td>
          <td class="paramtype">const struct rte_intr_handle *&#160;</td>
          <td class="paramname"><em>intr_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It disables the interrupt for the specified handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr_handle</td><td>pointer to the interrupt handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, zero.</li>
<li>On failure, a negative value. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aec9c8017ce9a4975c847eda98dc0eb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9c8017ce9a4975c847eda98dc0eb61">&#9670;&nbsp;</a></span>rte_intr_ack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_intr_ack </td>
          <td>(</td>
          <td class="paramtype">const struct rte_intr_handle *&#160;</td>
          <td class="paramname"><em>intr_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It acknowledges an interrupt raised for the specified handle.</p>
<p>This function should be called at the end of each interrupt handler either from application or driver, so that currently raised interrupt is acked and further new interrupts are raised.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr_handle</td><td>pointer to the interrupt handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, zero.</li>
<li>On failure, a negative value. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad979acf202481bcc69adf7a29e7976ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad979acf202481bcc69adf7a29e7976ab">&#9670;&nbsp;</a></span>rte_thread_is_intr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_thread_is_intr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if currently executing in interrupt context</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>non zero in case of interrupt context</li>
<li>zero in case of process context </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad71bcbafc9f44674d15aa51a3b76f452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad71bcbafc9f44674d15aa51a3b76f452">&#9670;&nbsp;</a></span>rte_intr_instance_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rte_intr_handle* rte_intr_instance_alloc </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It allocates memory for interrupt instance. API takes flag as an argument which define from where memory should be allocated i.e. using DPDK memory management library APIs or normal heap allocation. Default memory allocation for event fds and event list array is done which can be realloced later based on size of MSIX interrupts supported by a PCI device.</p>
<p>This function should be called from application or driver, before calling any of the interrupt APIs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>See RTE_INTR_INSTANCE_F_* flags definitions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, address of interrupt handle.</li>
<li>On failure, NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1856d1eb2cbd17f1ae06bf49cd146a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1856d1eb2cbd17f1ae06bf49cd146a32">&#9670;&nbsp;</a></span>rte_intr_instance_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_intr_instance_free </td>
          <td>(</td>
          <td class="paramtype">struct rte_intr_handle *&#160;</td>
          <td class="paramname"><em>intr_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free the memory allocated for interrupt handle resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr_handle</td><td>Interrupt handle allocated with <a class="el" href="rte__interrupts_8h.html#ad71bcbafc9f44674d15aa51a3b76f452">rte_intr_instance_alloc()</a>. If intr_handle is NULL, no operation is performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b2cac5de7485e8a2d75ef1c65e13e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2cac5de7485e8a2d75ef1c65e13e1b">&#9670;&nbsp;</a></span>rte_intr_fd_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_intr_fd_set </td>
          <td>(</td>
          <td class="paramtype">struct rte_intr_handle *&#160;</td>
          <td class="paramname"><em>intr_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the fd field of interrupt handle with user provided file descriptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr_handle</td><td>pointer to the interrupt handle. </td></tr>
    <tr><td class="paramname">fd</td><td>file descriptor value provided by user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, zero.</li>
<li>On failure, a negative value and rte_errno is set. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa7bb99a9cda11f323604a9bb1f2916dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7bb99a9cda11f323604a9bb1f2916dd">&#9670;&nbsp;</a></span>rte_intr_fd_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_intr_fd_get </td>
          <td>(</td>
          <td class="paramtype">const struct rte_intr_handle *&#160;</td>
          <td class="paramname"><em>intr_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the fd field of the given interrupt handle instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr_handle</td><td>pointer to the interrupt handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, fd field.</li>
<li>On failure, a negative value. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a667539655330facabc457adfe80dd4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667539655330facabc457adfe80dd4ba">&#9670;&nbsp;</a></span>rte_intr_type_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_intr_type_set </td>
          <td>(</td>
          <td class="paramtype">struct rte_intr_handle *&#160;</td>
          <td class="paramname"><em>intr_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__interrupts_8h.html#a860581f3cd6203dc5a4b06635f010352">rte_intr_handle_type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the type field of interrupt handle with user provided interrupt type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr_handle</td><td>pointer to the interrupt handle. </td></tr>
    <tr><td class="paramname">type</td><td>interrupt type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, zero.</li>
<li>On failure, a negative value and rte_errno is set. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1db3ed1b6908dc19c1a2ccf672cd41f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db3ed1b6908dc19c1a2ccf672cd41f4">&#9670;&nbsp;</a></span>rte_intr_type_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__interrupts_8h.html#a860581f3cd6203dc5a4b06635f010352">rte_intr_handle_type</a> rte_intr_type_get </td>
          <td>(</td>
          <td class="paramtype">const struct rte_intr_handle *&#160;</td>
          <td class="paramname"><em>intr_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the type field of the given interrupt handle instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr_handle</td><td>pointer to the interrupt handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, interrupt type</li>
<li>On failure, RTE_INTR_HANDLE_UNKNOWN. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
