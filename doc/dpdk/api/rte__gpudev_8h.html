<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/gpudev/rte_gpudev.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">23.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_ee4e60a3821e66a7ae93e419bf4e05e5.html">gpudev</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_gpudev.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__bitops_8h_source.html">rte_bitops.h</a>&gt;</code><br />
<code>#include &lt;rte_compat.h&gt;</code><br />
</div>
<p><a href="rte__gpudev_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__gpu__info.html">rte_gpu_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__gpu__comm__flag.html">rte_gpu_comm_flag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__gpu__comm__pkt.html">rte_gpu_comm_pkt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__gpu__comm__list.html">rte_gpu_comm_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac93ba505005e5c8a4930a919b4a61972"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#ac93ba505005e5c8a4930a919b4a61972">RTE_GPU_DEFAULT_MAX</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:ac93ba505005e5c8a4930a919b4a61972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f8ea7e364a058e87d4bee1e958a8c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#ae3f8ea7e364a058e87d4bee1e958a8c1">RTE_GPU_ID_NONE</a>&#160;&#160;&#160;-1</td></tr>
<tr class="separator:ae3f8ea7e364a058e87d4bee1e958a8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202e55e0113371d0d31063b7aad84f3f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a202e55e0113371d0d31063b7aad84f3f">RTE_GPU_ID_ANY</a>&#160;&#160;&#160;INT16_MIN</td></tr>
<tr class="separator:a202e55e0113371d0d31063b7aad84f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9f015f02015a26640177ae011e426a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#abb9f015f02015a26640177ae011e426a">RTE_GPU_CALLBACK_ANY_DATA</a>&#160;&#160;&#160;((void *)-1)</td></tr>
<tr class="separator:abb9f015f02015a26640177ae011e426a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59cb28bed87c5809b3e6b0206bf6cd6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#ab59cb28bed87c5809b3e6b0206bf6cd6">RTE_GPU_VOLATILE</a>(x)&#160;&#160;&#160;(*(volatile typeof(x) *)&amp;(x))</td></tr>
<tr class="separator:ab59cb28bed87c5809b3e6b0206bf6cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaefb43cb63dddf4ff97a91cd3dcd3c14"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#aaefb43cb63dddf4ff97a91cd3dcd3c14">RTE_GPU_COMM_LIST_PKTS_MAX</a>&#160;&#160;&#160;1024</td></tr>
<tr class="separator:aaefb43cb63dddf4ff97a91cd3dcd3c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a342e044a45fae87a7b039db28f00d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a9a342e044a45fae87a7b039db28f00d2">RTE_GPU_FOREACH</a>(dev_id)&#160;&#160;&#160;	<a class="el" href="rte__gpudev_8h.html#a6a8a39a42bde79fe67bbdb38af7e9a94">RTE_GPU_FOREACH_CHILD</a>(dev_id, <a class="el" href="rte__gpudev_8h.html#a202e55e0113371d0d31063b7aad84f3f">RTE_GPU_ID_ANY</a>)</td></tr>
<tr class="separator:a9a342e044a45fae87a7b039db28f00d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49afeb3b0c7b81949b7e62070571df3c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a49afeb3b0c7b81949b7e62070571df3c">RTE_GPU_FOREACH_PARENT</a>(dev_id)&#160;&#160;&#160;	<a class="el" href="rte__gpudev_8h.html#a6a8a39a42bde79fe67bbdb38af7e9a94">RTE_GPU_FOREACH_CHILD</a>(dev_id, <a class="el" href="rte__gpudev_8h.html#ae3f8ea7e364a058e87d4bee1e958a8c1">RTE_GPU_ID_NONE</a>)</td></tr>
<tr class="separator:a49afeb3b0c7b81949b7e62070571df3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8a39a42bde79fe67bbdb38af7e9a94"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a6a8a39a42bde79fe67bbdb38af7e9a94">RTE_GPU_FOREACH_CHILD</a>(dev_id,  parent)</td></tr>
<tr class="separator:a6a8a39a42bde79fe67bbdb38af7e9a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a86c70a8e6c0b04ed39810aa47396ecea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a86c70a8e6c0b04ed39810aa47396ecea">rte_gpu_callback_t</a>(int16_t dev_id, enum <a class="el" href="rte__gpudev_8h.html#a8099534c829d51b4146a734ea0d5ecf6">rte_gpu_event</a> event, void *user_data)</td></tr>
<tr class="separator:a86c70a8e6c0b04ed39810aa47396ecea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8099534c829d51b4146a734ea0d5ecf6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a8099534c829d51b4146a734ea0d5ecf6">rte_gpu_event</a> { <a class="el" href="rte__gpudev_8h.html#a8099534c829d51b4146a734ea0d5ecf6a591c6a2c2f0938d36aa20d6f6c8add38">RTE_GPU_EVENT_NEW</a>
, <a class="el" href="rte__gpudev_8h.html#a8099534c829d51b4146a734ea0d5ecf6a843a9ecfd4d21104b9584e3cea405fcf">RTE_GPU_EVENT_DEL</a>
 }</td></tr>
<tr class="separator:a8099534c829d51b4146a734ea0d5ecf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79aed58229841b5da6942a173764d7ee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a79aed58229841b5da6942a173764d7ee">rte_gpu_comm_flag_type</a> { <a class="el" href="rte__gpudev_8h.html#a79aed58229841b5da6942a173764d7eea2ecce6dcec7d936cb583ea7b7f723dbf">RTE_GPU_COMM_FLAG_CPU</a> = 0
 }</td></tr>
<tr class="separator:a79aed58229841b5da6942a173764d7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5756c5111b975bc9003d6980e64591"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a0c5756c5111b975bc9003d6980e64591">rte_gpu_comm_list_status</a> { <a class="el" href="rte__gpudev_8h.html#a0c5756c5111b975bc9003d6980e64591a61875609783f33160b991372e105b66a">RTE_GPU_COMM_LIST_FREE</a> = 0
, <a class="el" href="rte__gpudev_8h.html#a0c5756c5111b975bc9003d6980e64591a2754294338a68a3b7639e9c80a9c6e4c">RTE_GPU_COMM_LIST_READY</a>
, <a class="el" href="rte__gpudev_8h.html#a0c5756c5111b975bc9003d6980e64591ae05bcd015e83631730bdb1e23c5e8458">RTE_GPU_COMM_LIST_DONE</a>
, <a class="el" href="rte__gpudev_8h.html#a0c5756c5111b975bc9003d6980e64591ae7e8a75bec0aee8c03fef69501e88f03">RTE_GPU_COMM_LIST_ERROR</a>
 }</td></tr>
<tr class="separator:a0c5756c5111b975bc9003d6980e64591"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a99b5c19def9042c1fb6450c8e721e7bc"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a99b5c19def9042c1fb6450c8e721e7bc">rte_gpu_init</a> (size_t dev_max)</td></tr>
<tr class="separator:a99b5c19def9042c1fb6450c8e721e7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17288187c9c8e9f1455e10a816546f9f"><td class="memItemLeft" align="right" valign="top">__rte_experimental uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a17288187c9c8e9f1455e10a816546f9f">rte_gpu_count_avail</a> (void)</td></tr>
<tr class="separator:a17288187c9c8e9f1455e10a816546f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7e2df6495d9a97475662ef3af3c36a"><td class="memItemLeft" align="right" valign="top">__rte_experimental bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#acd7e2df6495d9a97475662ef3af3c36a">rte_gpu_is_valid</a> (int16_t dev_id)</td></tr>
<tr class="separator:acd7e2df6495d9a97475662ef3af3c36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af330208ca6f69692971f1d98318e1117"><td class="memItemLeft" align="right" valign="top">__rte_experimental int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#af330208ca6f69692971f1d98318e1117">rte_gpu_add_child</a> (const char *name, int16_t parent, uint64_t child_context)</td></tr>
<tr class="separator:af330208ca6f69692971f1d98318e1117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e9588ebb8c38ca25ca958ecc043cef"><td class="memItemLeft" align="right" valign="top">__rte_experimental int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#ac8e9588ebb8c38ca25ca958ecc043cef">rte_gpu_find_next</a> (int16_t dev_id, int16_t parent)</td></tr>
<tr class="separator:ac8e9588ebb8c38ca25ca958ecc043cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddf61f52bb63d3b76406cf723bd7688"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a4ddf61f52bb63d3b76406cf723bd7688">rte_gpu_close</a> (int16_t dev_id)</td></tr>
<tr class="separator:a4ddf61f52bb63d3b76406cf723bd7688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b589cff0a96d43798fea9a3c1c63ba"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a97b589cff0a96d43798fea9a3c1c63ba">rte_gpu_callback_register</a> (int16_t dev_id, enum <a class="el" href="rte__gpudev_8h.html#a8099534c829d51b4146a734ea0d5ecf6">rte_gpu_event</a> event, <a class="el" href="rte__gpudev_8h.html#a86c70a8e6c0b04ed39810aa47396ecea">rte_gpu_callback_t</a> *function, void *user_data)</td></tr>
<tr class="separator:a97b589cff0a96d43798fea9a3c1c63ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033849516e9be33677f80046d2f9081b"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a033849516e9be33677f80046d2f9081b">rte_gpu_callback_unregister</a> (int16_t dev_id, enum <a class="el" href="rte__gpudev_8h.html#a8099534c829d51b4146a734ea0d5ecf6">rte_gpu_event</a> event, <a class="el" href="rte__gpudev_8h.html#a86c70a8e6c0b04ed39810aa47396ecea">rte_gpu_callback_t</a> *function, void *user_data)</td></tr>
<tr class="separator:a033849516e9be33677f80046d2f9081b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bbe445907a1759430035a6c3f3fdc1"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a76bbe445907a1759430035a6c3f3fdc1">rte_gpu_info_get</a> (int16_t dev_id, struct <a class="el" href="structrte__gpu__info.html">rte_gpu_info</a> *info)</td></tr>
<tr class="separator:a76bbe445907a1759430035a6c3f3fdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc9365f41eaac02fb2ce0896cdece97"><td class="memItemLeft" align="right" valign="top">__rte_experimental void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a0dc9365f41eaac02fb2ce0896cdece97">rte_gpu_mem_alloc</a> (int16_t dev_id, size_t size, unsigned int align) <a class="el" href="rte__common_8h.html#a84949e2354508073273ca32a7e5e54ac">__rte_alloc_size</a>(2)</td></tr>
<tr class="separator:a0dc9365f41eaac02fb2ce0896cdece97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e573aa461287bb869e5902067e2636"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#ac1e573aa461287bb869e5902067e2636">rte_gpu_mem_free</a> (int16_t dev_id, void *ptr)</td></tr>
<tr class="separator:ac1e573aa461287bb869e5902067e2636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b98ce3fa7660416c21af1d40601e66f"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a7b98ce3fa7660416c21af1d40601e66f">rte_gpu_mem_register</a> (int16_t dev_id, size_t size, void *ptr)</td></tr>
<tr class="separator:a7b98ce3fa7660416c21af1d40601e66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb22407897828aa43d949c34e145388a"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#adb22407897828aa43d949c34e145388a">rte_gpu_mem_unregister</a> (int16_t dev_id, void *ptr)</td></tr>
<tr class="separator:adb22407897828aa43d949c34e145388a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3366088a7e05d1c275896bb320b515"><td class="memItemLeft" align="right" valign="top">__rte_experimental void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#aea3366088a7e05d1c275896bb320b515">rte_gpu_mem_cpu_map</a> (int16_t dev_id, size_t size, void *ptr)</td></tr>
<tr class="separator:aea3366088a7e05d1c275896bb320b515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2bf213a51724bd90ff6712b4ca8a671"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#ae2bf213a51724bd90ff6712b4ca8a671">rte_gpu_mem_cpu_unmap</a> (int16_t dev_id, void *ptr)</td></tr>
<tr class="separator:ae2bf213a51724bd90ff6712b4ca8a671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4e71cd8a14b581681d6a7f6baedda2"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a4b4e71cd8a14b581681d6a7f6baedda2">rte_gpu_wmb</a> (int16_t dev_id)</td></tr>
<tr class="separator:a4b4e71cd8a14b581681d6a7f6baedda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc3712216d7ce2180eb176d7718ff0e"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a4cc3712216d7ce2180eb176d7718ff0e">rte_gpu_comm_create_flag</a> (uint16_t dev_id, struct <a class="el" href="structrte__gpu__comm__flag.html">rte_gpu_comm_flag</a> *devflag, enum <a class="el" href="rte__gpudev_8h.html#a79aed58229841b5da6942a173764d7ee">rte_gpu_comm_flag_type</a> mtype)</td></tr>
<tr class="separator:a4cc3712216d7ce2180eb176d7718ff0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5a4babfa02efca92bde8de222134aa"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a3b5a4babfa02efca92bde8de222134aa">rte_gpu_comm_destroy_flag</a> (struct <a class="el" href="structrte__gpu__comm__flag.html">rte_gpu_comm_flag</a> *devflag)</td></tr>
<tr class="separator:a3b5a4babfa02efca92bde8de222134aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2aac705463e50f24696d1027ab77f1"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#ade2aac705463e50f24696d1027ab77f1">rte_gpu_comm_set_flag</a> (struct <a class="el" href="structrte__gpu__comm__flag.html">rte_gpu_comm_flag</a> *devflag, uint32_t val)</td></tr>
<tr class="separator:ade2aac705463e50f24696d1027ab77f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3169b1c2b28bf9290cdb6006564be55"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#ad3169b1c2b28bf9290cdb6006564be55">rte_gpu_comm_get_flag_value</a> (struct <a class="el" href="structrte__gpu__comm__flag.html">rte_gpu_comm_flag</a> *devflag, uint32_t *val)</td></tr>
<tr class="separator:ad3169b1c2b28bf9290cdb6006564be55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad518978430c101e45bdcd441cc388e24"><td class="memItemLeft" align="right" valign="top">__rte_experimental struct <a class="el" href="structrte__gpu__comm__list.html">rte_gpu_comm_list</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#ad518978430c101e45bdcd441cc388e24">rte_gpu_comm_create_list</a> (uint16_t dev_id, uint32_t num_comm_items)</td></tr>
<tr class="separator:ad518978430c101e45bdcd441cc388e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3515a0aab0ff230c8c24be87f4ca62"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a6e3515a0aab0ff230c8c24be87f4ca62">rte_gpu_comm_destroy_list</a> (struct <a class="el" href="structrte__gpu__comm__list.html">rte_gpu_comm_list</a> *comm_list, uint32_t num_comm_items)</td></tr>
<tr class="separator:a6e3515a0aab0ff230c8c24be87f4ca62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a2e8749d930bcb19db2acac28d25b6"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a60a2e8749d930bcb19db2acac28d25b6">rte_gpu_comm_populate_list_pkts</a> (struct <a class="el" href="structrte__gpu__comm__list.html">rte_gpu_comm_list</a> *comm_list_item, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **mbufs, uint32_t num_mbufs)</td></tr>
<tr class="separator:a60a2e8749d930bcb19db2acac28d25b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a24ebbbc053d01d0da24ccf6716d96"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a68a24ebbbc053d01d0da24ccf6716d96">rte_gpu_comm_set_status</a> (struct <a class="el" href="structrte__gpu__comm__list.html">rte_gpu_comm_list</a> *comm_list_item, enum <a class="el" href="rte__gpudev_8h.html#a0c5756c5111b975bc9003d6980e64591">rte_gpu_comm_list_status</a> status)</td></tr>
<tr class="separator:a68a24ebbbc053d01d0da24ccf6716d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f286b7f9881fc79dd4de512355b79c"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a07f286b7f9881fc79dd4de512355b79c">rte_gpu_comm_get_status</a> (struct <a class="el" href="structrte__gpu__comm__list.html">rte_gpu_comm_list</a> *comm_list_item, enum <a class="el" href="rte__gpudev_8h.html#a0c5756c5111b975bc9003d6980e64591">rte_gpu_comm_list_status</a> *status)</td></tr>
<tr class="separator:a07f286b7f9881fc79dd4de512355b79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924f28741cb5ffd648dec36b7f94330f"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__gpudev_8h.html#a924f28741cb5ffd648dec36b7f94330f">rte_gpu_comm_cleanup_list</a> (struct <a class="el" href="structrte__gpu__comm__list.html">rte_gpu_comm_list</a> *comm_list_item)</td></tr>
<tr class="separator:a924f28741cb5ffd648dec36b7f94330f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generic library to interact with GPU computing device.</p>
<p>The API is not thread-safe. Device management must be done by a single thread.</p>
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice. </dd></dl>

<p class="definition">Definition in file <a class="el" href="rte__gpudev_8h_source.html">rte_gpudev.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ac93ba505005e5c8a4930a919b4a61972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93ba505005e5c8a4930a919b4a61972">&#9670;&nbsp;</a></span>RTE_GPU_DEFAULT_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_GPU_DEFAULT_MAX&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of devices if <a class="el" href="rte__gpudev_8h.html#a99b5c19def9042c1fb6450c8e721e7bc">rte_gpu_init()</a> is not called. </p>

<p class="definition">Definition at line <a class="el" href="rte__gpudev_8h_source.html#l00032">32</a> of file <a class="el" href="rte__gpudev_8h_source.html">rte_gpudev.h</a>.</p>

</div>
</div>
<a id="ae3f8ea7e364a058e87d4bee1e958a8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f8ea7e364a058e87d4bee1e958a8c1">&#9670;&nbsp;</a></span>RTE_GPU_ID_NONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_GPU_ID_NONE&#160;&#160;&#160;-1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empty device ID. </p>

<p class="definition">Definition at line <a class="el" href="rte__gpudev_8h_source.html#l00035">35</a> of file <a class="el" href="rte__gpudev_8h_source.html">rte_gpudev.h</a>.</p>

</div>
</div>
<a id="a202e55e0113371d0d31063b7aad84f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202e55e0113371d0d31063b7aad84f3f">&#9670;&nbsp;</a></span>RTE_GPU_ID_ANY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_GPU_ID_ANY&#160;&#160;&#160;INT16_MIN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Catch-all device ID. </p>

<p class="definition">Definition at line <a class="el" href="rte__gpudev_8h_source.html#l00037">37</a> of file <a class="el" href="rte__gpudev_8h_source.html">rte_gpudev.h</a>.</p>

</div>
</div>
<a id="abb9f015f02015a26640177ae011e426a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9f015f02015a26640177ae011e426a">&#9670;&nbsp;</a></span>RTE_GPU_CALLBACK_ANY_DATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_GPU_CALLBACK_ANY_DATA&#160;&#160;&#160;((void *)-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Catch-all callback data. </p>

<p class="definition">Definition at line <a class="el" href="rte__gpudev_8h_source.html#l00040">40</a> of file <a class="el" href="rte__gpudev_8h_source.html">rte_gpudev.h</a>.</p>

</div>
</div>
<a id="ab59cb28bed87c5809b3e6b0206bf6cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59cb28bed87c5809b3e6b0206bf6cd6">&#9670;&nbsp;</a></span>RTE_GPU_VOLATILE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_GPU_VOLATILE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(*(volatile typeof(x) *)&amp;(x))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access variable as volatile. </p>

<p class="definition">Definition at line <a class="el" href="rte__gpudev_8h_source.html#l00043">43</a> of file <a class="el" href="rte__gpudev_8h_source.html">rte_gpudev.h</a>.</p>

</div>
</div>
<a id="aaefb43cb63dddf4ff97a91cd3dcd3c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaefb43cb63dddf4ff97a91cd3dcd3c14">&#9670;&nbsp;</a></span>RTE_GPU_COMM_LIST_PKTS_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_GPU_COMM_LIST_PKTS_MAX&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max number of packets per communication list. </p>

<p class="definition">Definition at line <a class="el" href="rte__gpudev_8h_source.html#l00046">46</a> of file <a class="el" href="rte__gpudev_8h_source.html">rte_gpudev.h</a>.</p>

</div>
</div>
<a id="a9a342e044a45fae87a7b039db28f00d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a342e044a45fae87a7b039db28f00d2">&#9670;&nbsp;</a></span>RTE_GPU_FOREACH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_GPU_FOREACH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dev_id</td><td>)</td>
          <td>&#160;&#160;&#160;	<a class="el" href="rte__gpudev_8h.html#a6a8a39a42bde79fe67bbdb38af7e9a94">RTE_GPU_FOREACH_CHILD</a>(dev_id, <a class="el" href="rte__gpudev_8h.html#a202e55e0113371d0d31063b7aad84f3f">RTE_GPU_ID_ANY</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Macro to iterate over all valid GPU devices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The ID of the next possible valid device, usually 0 to iterate all. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__gpudev_8h_source.html#l00238">238</a> of file <a class="el" href="rte__gpudev_8h_source.html">rte_gpudev.h</a>.</p>

</div>
</div>
<a id="a49afeb3b0c7b81949b7e62070571df3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49afeb3b0c7b81949b7e62070571df3c">&#9670;&nbsp;</a></span>RTE_GPU_FOREACH_PARENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_GPU_FOREACH_PARENT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dev_id</td><td>)</td>
          <td>&#160;&#160;&#160;	<a class="el" href="rte__gpudev_8h.html#a6a8a39a42bde79fe67bbdb38af7e9a94">RTE_GPU_FOREACH_CHILD</a>(dev_id, <a class="el" href="rte__gpudev_8h.html#ae3f8ea7e364a058e87d4bee1e958a8c1">RTE_GPU_ID_NONE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Macro to iterate over all valid computing devices having no parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The ID of the next possible valid device, usually 0 to iterate all. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__gpudev_8h_source.html#l00250">250</a> of file <a class="el" href="rte__gpudev_8h_source.html">rte_gpudev.h</a>.</p>

</div>
</div>
<a id="a6a8a39a42bde79fe67bbdb38af7e9a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8a39a42bde79fe67bbdb38af7e9a94">&#9670;&nbsp;</a></span>RTE_GPU_FOREACH_CHILD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_GPU_FOREACH_CHILD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dev_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">parent&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">for</span> (dev_id = <a class="code" href="rte__gpudev_8h.html#ac8e9588ebb8c38ca25ca958ecc043cef">rte_gpu_find_next</a>(0, parent); \</div>
<div class="line">         dev_id &gt;= 0; \</div>
<div class="line">         dev_id = <a class="code" href="rte__gpudev_8h.html#ac8e9588ebb8c38ca25ca958ecc043cef">rte_gpu_find_next</a>(dev_id + 1, parent))</div>
<div class="ttc" id="arte__gpudev_8h_html_ac8e9588ebb8c38ca25ca958ecc043cef"><div class="ttname"><a href="rte__gpudev_8h.html#ac8e9588ebb8c38ca25ca958ecc043cef">rte_gpu_find_next</a></div><div class="ttdeci">__rte_experimental int16_t rte_gpu_find_next(int16_t dev_id, int16_t parent)</div></div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Macro to iterate over all valid children of a computing device parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The ID of the next possible valid device, usually 0 to iterate all. </td></tr>
    <tr><td class="paramname">parent</td><td>The device ID of the parent. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__gpudev_8h_source.html#l00264">264</a> of file <a class="el" href="rte__gpudev_8h_source.html">rte_gpudev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a86c70a8e6c0b04ed39810aa47396ecea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c70a8e6c0b04ed39810aa47396ecea">&#9670;&nbsp;</a></span>rte_gpu_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rte__trace__point_8h.html#a70b6efc30c60e969d7684445cde97b50">typedef</a> void() rte_gpu_callback_t(int16_t dev_id, enum <a class="el" href="rte__gpudev_8h.html#a8099534c829d51b4146a734ea0d5ecf6">rte_gpu_event</a> event, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prototype of event callback function. </p>

<p class="definition">Definition at line <a class="el" href="rte__gpudev_8h_source.html#l00077">77</a> of file <a class="el" href="rte__gpudev_8h_source.html">rte_gpudev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a8099534c829d51b4146a734ea0d5ecf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8099534c829d51b4146a734ea0d5ecf6">&#9670;&nbsp;</a></span>rte_gpu_event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__gpudev_8h.html#a8099534c829d51b4146a734ea0d5ecf6">rte_gpu_event</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags passed in notification callback. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8099534c829d51b4146a734ea0d5ecf6a591c6a2c2f0938d36aa20d6f6c8add38"></a>RTE_GPU_EVENT_NEW&#160;</td><td class="fielddoc"><p>Device is just initialized. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8099534c829d51b4146a734ea0d5ecf6a843a9ecfd4d21104b9584e3cea405fcf"></a>RTE_GPU_EVENT_DEL&#160;</td><td class="fielddoc"><p>Device is going to be released. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__gpudev_8h_source.html#l00069">69</a> of file <a class="el" href="rte__gpudev_8h_source.html">rte_gpudev.h</a>.</p>

</div>
</div>
<a id="a79aed58229841b5da6942a173764d7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79aed58229841b5da6942a173764d7ee">&#9670;&nbsp;</a></span>rte_gpu_comm_flag_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__gpudev_8h.html#a79aed58229841b5da6942a173764d7ee">rte_gpu_comm_flag_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Memory where communication flag is allocated. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a79aed58229841b5da6942a173764d7eea2ecce6dcec7d936cb583ea7b7f723dbf"></a>RTE_GPU_COMM_FLAG_CPU&#160;</td><td class="fielddoc"><p>Allocate flag on CPU memory visible from device. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__gpudev_8h_source.html#l00081">81</a> of file <a class="el" href="rte__gpudev_8h_source.html">rte_gpudev.h</a>.</p>

</div>
</div>
<a id="a0c5756c5111b975bc9003d6980e64591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5756c5111b975bc9003d6980e64591">&#9670;&nbsp;</a></span>rte_gpu_comm_list_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__gpudev_8h.html#a0c5756c5111b975bc9003d6980e64591">rte_gpu_comm_list_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible status for the list of packets shared among CPU and device. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0c5756c5111b975bc9003d6980e64591a61875609783f33160b991372e105b66a"></a>RTE_GPU_COMM_LIST_FREE&#160;</td><td class="fielddoc"><p>Packet list can be filled with new mbufs, no one is using it. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0c5756c5111b975bc9003d6980e64591a2754294338a68a3b7639e9c80a9c6e4c"></a>RTE_GPU_COMM_LIST_READY&#160;</td><td class="fielddoc"><p>Packet list has been filled with new mbufs and it's ready to be used . </p>
</td></tr>
<tr><td class="fieldname"><a id="a0c5756c5111b975bc9003d6980e64591ae05bcd015e83631730bdb1e23c5e8458"></a>RTE_GPU_COMM_LIST_DONE&#160;</td><td class="fielddoc"><p>Packet list has been processed, it's ready to be freed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0c5756c5111b975bc9003d6980e64591ae7e8a75bec0aee8c03fef69501e88f03"></a>RTE_GPU_COMM_LIST_ERROR&#160;</td><td class="fielddoc"><p>Some error occurred during packet list processing. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__gpudev_8h_source.html#l00105">105</a> of file <a class="el" href="rte__gpudev_8h_source.html">rte_gpudev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a99b5c19def9042c1fb6450c8e721e7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b5c19def9042c1fb6450c8e721e7bc">&#9670;&nbsp;</a></span>rte_gpu_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_gpu_init </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dev_max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Initialize the device array before probing devices. If not called, the maximum of probed devices is RTE_GPU_DEFAULT_MAX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_max</td><td>Maximum number of devices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -rte_errno otherwise:<ul>
<li>ENOMEM if out of memory</li>
<li>EINVAL if 0 size</li>
<li>EBUSY if already initialized </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a17288187c9c8e9f1455e10a816546f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17288187c9c8e9f1455e10a816546f9f">&#9670;&nbsp;</a></span>rte_gpu_count_avail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental uint16_t rte_gpu_count_avail </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Return the number of GPU detected and associated to DPDK.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of available computing devices. </dd></dl>

</div>
</div>
<a id="acd7e2df6495d9a97475662ef3af3c36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7e2df6495d9a97475662ef3af3c36a">&#9670;&nbsp;</a></span>rte_gpu_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental bool rte_gpu_is_valid </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Check if the device is valid and initialized in DPDK.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The input device ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True if dev_id is a valid and initialized computing device.</li>
<li>False otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af330208ca6f69692971f1d98318e1117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af330208ca6f69692971f1d98318e1117">&#9670;&nbsp;</a></span>rte_gpu_add_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int16_t rte_gpu_add_child </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>child_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Create a virtual device representing a context in the parent device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Unique string to identify the device. </td></tr>
    <tr><td class="paramname">parent</td><td>Device ID of the parent. </td></tr>
    <tr><td class="paramname">child_context</td><td>Opaque context handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Device ID of the new created child, -rte_errno otherwise:<ul>
<li>EINVAL if empty name</li>
<li>ENAMETOOLONG if long name</li>
<li>EEXIST if existing device name</li>
<li>ENODEV if invalid parent</li>
<li>EPERM if secondary process</li>
<li>ENOENT if too many devices</li>
<li>ENOMEM if out of space </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac8e9588ebb8c38ca25ca958ecc043cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e9588ebb8c38ca25ca958ecc043cef">&#9670;&nbsp;</a></span>rte_gpu_find_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int16_t rte_gpu_find_next </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Get the ID of the next valid GPU initialized in DPDK.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The initial device ID to start the research. </td></tr>
    <tr><td class="paramname">parent</td><td>The device ID of the parent. RTE_GPU_ID_NONE means no parent. RTE_GPU_ID_ANY means no or any parent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next device ID corresponding to a valid and initialized computing device, RTE_GPU_ID_NONE if there is none. </dd></dl>

</div>
</div>
<a id="a4ddf61f52bb63d3b76406cf723bd7688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddf61f52bb63d3b76406cf723bd7688">&#9670;&nbsp;</a></span>rte_gpu_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_gpu_close </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Close device or child context. All resources are released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Device ID to close.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -rte_errno otherwise:<ul>
<li>ENODEV if invalid dev_id</li>
<li>EPERM if driver error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a97b589cff0a96d43798fea9a3c1c63ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b589cff0a96d43798fea9a3c1c63ba">&#9670;&nbsp;</a></span>rte_gpu_callback_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_gpu_callback_register </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__gpudev_8h.html#a8099534c829d51b4146a734ea0d5ecf6">rte_gpu_event</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__gpudev_8h.html#a86c70a8e6c0b04ed39810aa47396ecea">rte_gpu_callback_t</a> *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Register a function as event callback. A function may be registered multiple times for different events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Device ID to get notified about. RTE_GPU_ID_ANY means all devices. </td></tr>
    <tr><td class="paramname">event</td><td>Device event to be registered for. </td></tr>
    <tr><td class="paramname">function</td><td>Callback function to be called on event. </td></tr>
    <tr><td class="paramname">user_data</td><td>Optional parameter passed in the callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -rte_errno otherwise:<ul>
<li>ENODEV if invalid dev_id</li>
<li>EINVAL if NULL function</li>
<li>ENOMEM if out of memory </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a033849516e9be33677f80046d2f9081b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033849516e9be33677f80046d2f9081b">&#9670;&nbsp;</a></span>rte_gpu_callback_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_gpu_callback_unregister </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__gpudev_8h.html#a8099534c829d51b4146a734ea0d5ecf6">rte_gpu_event</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__gpudev_8h.html#a86c70a8e6c0b04ed39810aa47396ecea">rte_gpu_callback_t</a> *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Unregister for an event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Device ID to be silenced. RTE_GPU_ID_ANY means all devices. </td></tr>
    <tr><td class="paramname">event</td><td>Registered event. </td></tr>
    <tr><td class="paramname">function</td><td>Registered function. </td></tr>
    <tr><td class="paramname">user_data</td><td>Optional parameter as registered. RTE_GPU_CALLBACK_ANY_DATA is a catch-all.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -rte_errno otherwise:<ul>
<li>ENODEV if invalid dev_id</li>
<li>EINVAL if NULL function </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a76bbe445907a1759430035a6c3f3fdc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76bbe445907a1759430035a6c3f3fdc1">&#9670;&nbsp;</a></span>rte_gpu_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_gpu_info_get </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__gpu__info.html">rte_gpu_info</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Return device specific info.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Device ID to get info. </td></tr>
    <tr><td class="paramname">info</td><td>Memory structure to fill with the info.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -rte_errno otherwise:<ul>
<li>ENODEV if invalid dev_id</li>
<li>EINVAL if NULL info</li>
<li>EPERM if driver error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0dc9365f41eaac02fb2ce0896cdece97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc9365f41eaac02fb2ce0896cdece97">&#9670;&nbsp;</a></span>rte_gpu_mem_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental void* rte_gpu_mem_alloc </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Allocate a chunk of memory in the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Device ID requiring allocated memory. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to allocate. Requesting 0 will do nothing. </td></tr>
    <tr><td class="paramname">align</td><td>If 0, the return is a pointer that is suitably aligned for any kind of variable (in the same manner as malloc()). Otherwise, the return is a pointer that is a multiple of <em>align</em>. In this case, it must obviously be a power of two.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the allocated memory, otherwise NULL and rte_errno is set:<ul>
<li>ENODEV if invalid dev_id</li>
<li>EINVAL if align is not a power of two</li>
<li>ENOTSUP if operation not supported by the driver</li>
<li>E2BIG if size is higher than limit</li>
<li>ENOMEM if out of space</li>
<li>EPERM if driver error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac1e573aa461287bb869e5902067e2636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e573aa461287bb869e5902067e2636">&#9670;&nbsp;</a></span>rte_gpu_mem_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_gpu_mem_free </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Deallocate a chunk of memory allocated with <a class="el" href="rte__gpudev_8h.html#a0dc9365f41eaac02fb2ce0896cdece97">rte_gpu_mem_alloc()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Reference device ID. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to the memory area to be deallocated. NULL is a no-op accepted value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -rte_errno otherwise:<ul>
<li>ENODEV if invalid dev_id</li>
<li>ENOTSUP if operation not supported by the driver</li>
<li>EPERM if driver error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7b98ce3fa7660416c21af1d40601e66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b98ce3fa7660416c21af1d40601e66f">&#9670;&nbsp;</a></span>rte_gpu_mem_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_gpu_mem_register </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Register a chunk of memory on the CPU usable by the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Device ID requiring allocated memory. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to allocate. Requesting 0 will do nothing. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to the memory area to be registered. NULL is a no-op accepted value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the allocated memory, otherwise NULL and rte_errno is set:<ul>
<li>ENODEV if invalid dev_id</li>
<li>EINVAL if reserved flags</li>
<li>ENOTSUP if operation not supported by the driver</li>
<li>E2BIG if size is higher than limit</li>
<li>ENOMEM if out of space</li>
<li>EPERM if driver error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="adb22407897828aa43d949c34e145388a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb22407897828aa43d949c34e145388a">&#9670;&nbsp;</a></span>rte_gpu_mem_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_gpu_mem_unregister </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Deregister a chunk of memory previously registered with <a class="el" href="rte__gpudev_8h.html#a7b98ce3fa7660416c21af1d40601e66f">rte_gpu_mem_register()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Reference device ID. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to the memory area to be unregistered. NULL is a no-op accepted value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -rte_errno otherwise:<ul>
<li>ENODEV if invalid dev_id</li>
<li>ENOTSUP if operation not supported by the driver</li>
<li>EPERM if driver error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aea3366088a7e05d1c275896bb320b515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3366088a7e05d1c275896bb320b515">&#9670;&nbsp;</a></span>rte_gpu_mem_cpu_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental void* rte_gpu_mem_cpu_map </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Map a chunk of GPU memory to make it accessible from the CPU using the memory pointer returned by the function. GPU memory has to be allocated via <a class="el" href="rte__gpudev_8h.html#a0dc9365f41eaac02fb2ce0896cdece97">rte_gpu_mem_alloc()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Device ID requiring mapped memory. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to map. Requesting 0 will do nothing. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to the GPU memory area to be mapped. NULL is a no-op accepted value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the mapped GPU memory usable by the CPU, otherwise NULL and rte_errno is set:<ul>
<li>ENODEV if invalid dev_id</li>
<li>ENOTSUP if operation not supported by the driver</li>
<li>E2BIG if size is higher than limit</li>
<li>ENOMEM if out of space</li>
<li>EPERM if driver error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae2bf213a51724bd90ff6712b4ca8a671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2bf213a51724bd90ff6712b4ca8a671">&#9670;&nbsp;</a></span>rte_gpu_mem_cpu_unmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_gpu_mem_cpu_unmap </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Unmap a chunk of GPU memory previously mapped with <a class="el" href="rte__gpudev_8h.html#aea3366088a7e05d1c275896bb320b515">rte_gpu_mem_cpu_map()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Reference device ID. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to the GPU memory area to be unmapped. NULL is a no-op accepted value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -rte_errno otherwise:<ul>
<li>ENODEV if invalid dev_id</li>
<li>ENOTSUP if operation not supported by the driver</li>
<li>EPERM if driver error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4b4e71cd8a14b581681d6a7f6baedda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4e71cd8a14b581681d6a7f6baedda2">&#9670;&nbsp;</a></span>rte_gpu_wmb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_gpu_wmb </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Enforce a GPU write memory barrier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Reference device ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -rte_errno otherwise:<ul>
<li>ENODEV if invalid dev_id</li>
<li>ENOTSUP if operation not supported by the driver</li>
<li>EPERM if driver error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4cc3712216d7ce2180eb176d7718ff0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc3712216d7ce2180eb176d7718ff0e">&#9670;&nbsp;</a></span>rte_gpu_comm_create_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_gpu_comm_create_flag </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__gpu__comm__flag.html">rte_gpu_comm_flag</a> *&#160;</td>
          <td class="paramname"><em>devflag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__gpudev_8h.html#a79aed58229841b5da6942a173764d7ee">rte_gpu_comm_flag_type</a>&#160;</td>
          <td class="paramname"><em>mtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Create a communication flag that can be shared between CPU threads and device workload to exchange some status info (e.g. work is done, processing can start, etc..).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Reference device ID. </td></tr>
    <tr><td class="paramname">devflag</td><td>Pointer to the memory area of the devflag structure. </td></tr>
    <tr><td class="paramname">mtype</td><td>Type of memory to allocate the communication flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -rte_errno otherwise:<ul>
<li>ENODEV if invalid dev_id</li>
<li>EINVAL if invalid inputs</li>
<li>ENOTSUP if operation not supported by the driver</li>
<li>ENOMEM if out of space</li>
<li>EPERM if driver error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a3b5a4babfa02efca92bde8de222134aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5a4babfa02efca92bde8de222134aa">&#9670;&nbsp;</a></span>rte_gpu_comm_destroy_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_gpu_comm_destroy_flag </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__gpu__comm__flag.html">rte_gpu_comm_flag</a> *&#160;</td>
          <td class="paramname"><em>devflag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Deallocate a communication flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devflag</td><td>Pointer to the memory area of the devflag structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -rte_errno otherwise:<ul>
<li>ENODEV if invalid dev_id</li>
<li>EINVAL if NULL devflag</li>
<li>ENOTSUP if operation not supported by the driver</li>
<li>EPERM if driver error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ade2aac705463e50f24696d1027ab77f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2aac705463e50f24696d1027ab77f1">&#9670;&nbsp;</a></span>rte_gpu_comm_set_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_gpu_comm_set_flag </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__gpu__comm__flag.html">rte_gpu_comm_flag</a> *&#160;</td>
          <td class="paramname"><em>devflag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Set the value of a communication flag as the input value. Flag memory area is treated as volatile. The flag must have been allocated with RTE_GPU_COMM_FLAG_CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devflag</td><td>Pointer to the memory area of the devflag structure. </td></tr>
    <tr><td class="paramname">val</td><td>Value to set in the flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -rte_errno otherwise:<ul>
<li>EINVAL if invalid input params </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad3169b1c2b28bf9290cdb6006564be55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3169b1c2b28bf9290cdb6006564be55">&#9670;&nbsp;</a></span>rte_gpu_comm_get_flag_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_gpu_comm_get_flag_value </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__gpu__comm__flag.html">rte_gpu_comm_flag</a> *&#160;</td>
          <td class="paramname"><em>devflag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Get the value of the communication flag. Flag memory area is treated as volatile. The flag must have been allocated with RTE_GPU_COMM_FLAG_CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devflag</td><td>Pointer to the memory area of the devflag structure. </td></tr>
    <tr><td class="paramname">val</td><td>Flag output value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -rte_errno otherwise:<ul>
<li>EINVAL if invalid input params </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad518978430c101e45bdcd441cc388e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad518978430c101e45bdcd441cc388e24">&#9670;&nbsp;</a></span>rte_gpu_comm_create_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental struct <a class="el" href="structrte__gpu__comm__list.html">rte_gpu_comm_list</a>* rte_gpu_comm_create_list </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_comm_items</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Create a communication list that can be used to share packets between CPU and device. Each element of the list contains:</p><ul>
<li>a packet list of RTE_GPU_COMM_LIST_PKTS_MAX elements</li>
<li>number of packets in the list</li>
<li>a status flag to communicate if the packet list is FREE, READY to be processed, DONE with processing.</li>
</ul>
<p>The list is allocated in CPU-visible memory. At creation time, every list is in FREE state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Reference device ID. </td></tr>
    <tr><td class="paramname">num_comm_items</td><td>Number of items in the communication list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the allocated list, otherwise NULL and rte_errno is set:<ul>
<li>EINVAL if invalid input params </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6e3515a0aab0ff230c8c24be87f4ca62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3515a0aab0ff230c8c24be87f4ca62">&#9670;&nbsp;</a></span>rte_gpu_comm_destroy_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_gpu_comm_destroy_list </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__gpu__comm__list.html">rte_gpu_comm_list</a> *&#160;</td>
          <td class="paramname"><em>comm_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_comm_items</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Destroy a communication list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm_list</td><td>Communication list to be destroyed. </td></tr>
    <tr><td class="paramname">num_comm_items</td><td>Number of items in the communication list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -rte_errno otherwise:<ul>
<li>EINVAL if invalid input params </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a60a2e8749d930bcb19db2acac28d25b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a2e8749d930bcb19db2acac28d25b6">&#9670;&nbsp;</a></span>rte_gpu_comm_populate_list_pkts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_gpu_comm_populate_list_pkts </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__gpu__comm__list.html">rte_gpu_comm_list</a> *&#160;</td>
          <td class="paramname"><em>comm_list_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **&#160;</td>
          <td class="paramname"><em>mbufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_mbufs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Populate the packets list of the communication item with info from a list of mbufs. Status flag of that packet list is set to READY.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm_list_item</td><td>Communication list item to fill. </td></tr>
    <tr><td class="paramname">mbufs</td><td>List of mbufs. </td></tr>
    <tr><td class="paramname">num_mbufs</td><td>Number of mbufs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -rte_errno otherwise:<ul>
<li>EINVAL if invalid input params</li>
<li>ENOTSUP if mbufs are chained (multiple segments) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a68a24ebbbc053d01d0da24ccf6716d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a24ebbbc053d01d0da24ccf6716d96">&#9670;&nbsp;</a></span>rte_gpu_comm_set_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_gpu_comm_set_status </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__gpu__comm__list.html">rte_gpu_comm_list</a> *&#160;</td>
          <td class="paramname"><em>comm_list_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__gpudev_8h.html#a0c5756c5111b975bc9003d6980e64591">rte_gpu_comm_list_status</a>&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Set status flag value of a communication list item.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm_list_item</td><td>Communication list item to query. </td></tr>
    <tr><td class="paramname">status</td><td>Status value to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -rte_errno otherwise:<ul>
<li>EINVAL if invalid input params </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a07f286b7f9881fc79dd4de512355b79c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f286b7f9881fc79dd4de512355b79c">&#9670;&nbsp;</a></span>rte_gpu_comm_get_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_gpu_comm_get_status </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__gpu__comm__list.html">rte_gpu_comm_list</a> *&#160;</td>
          <td class="paramname"><em>comm_list_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__gpudev_8h.html#a0c5756c5111b975bc9003d6980e64591">rte_gpu_comm_list_status</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Get status flag value of a communication list item.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm_list_item</td><td>Communication list item to query. Input parameter. </td></tr>
    <tr><td class="paramname">status</td><td>Communication list item status flag value. Output parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -rte_errno otherwise:<ul>
<li>EINVAL if invalid input params </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a924f28741cb5ffd648dec36b7f94330f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924f28741cb5ffd648dec36b7f94330f">&#9670;&nbsp;</a></span>rte_gpu_comm_cleanup_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_gpu_comm_cleanup_list </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__gpu__comm__list.html">rte_gpu_comm_list</a> *&#160;</td>
          <td class="paramname"><em>comm_list_item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Reset a communication list item to the original state. The status flag set to FREE and mbufs are returned to the pool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm_list_item</td><td>Communication list item to reset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -rte_errno otherwise:<ul>
<li>EINVAL if invalid input params </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
