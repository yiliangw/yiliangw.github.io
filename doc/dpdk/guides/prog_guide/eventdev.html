
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>49. Event Device Library &#8212; Data Plane Development Kit 23.11.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="50. Event Ethernet Rx Adapter Library" href="event_ethernet_rx_adapter.html" />
    <link rel="prev" title="48. Thread Safety of DPDK Functions" href="thread_safety_dpdk_functions.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="event-device-library">
<h1><span class="section-number">49. </span>Event Device Library</h1>
<p>The DPDK Event device library is an abstraction that provides the application
with features to schedule events. This is achieved using the PMD architecture
similar to the ethdev or cryptodev APIs, which may already be familiar to the
reader.</p>
<p>The eventdev framework introduces the event driven programming model. In a
polling model, lcores poll ethdev ports and associated Rx queues directly
to look for a packet. By contrast in an event driven model, lcores call the
scheduler that selects packets for them based on programmer-specified criteria.
The Eventdev library adds support for an event driven programming model, which
offers applications automatic multicore scaling, dynamic load balancing,
pipelining, packet ingress order maintenance and synchronization services to
simplify application packet processing.</p>
<p>By introducing an event driven programming model, DPDK can support both polling
and event driven programming models for packet processing, and applications are
free to choose whatever model (or combination of the two) best suits their
needs.</p>
<p>Step-by-step instructions of the eventdev design is available in the <a class="reference internal" href="#api-walk-through">API
Walk-through</a> section later in this document.</p>
<section id="event-struct">
<h2><span class="section-number">49.1. </span>Event struct</h2>
<p>The eventdev API represents each event with a generic struct, which contains a
payload and metadata required for scheduling by an eventdev.  The
<code class="docutils literal notranslate"><span class="pre">rte_event</span></code> struct is a 16 byte C structure, defined in
<code class="docutils literal notranslate"><span class="pre">libs/librte_eventdev/rte_eventdev.h</span></code>.</p>
<section id="event-metadata">
<h3><span class="section-number">49.1.1. </span>Event Metadata</h3>
<p>The rte_event structure contains the following metadata fields, which the
application fills in to have the event scheduled as required:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">flow_id</span></code> - The targeted flow identifier for the enq/deq operation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">event_type</span></code> - The source of this event, e.g. RTE_EVENT_TYPE_ETHDEV or CPU.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sub_event_type</span></code> - Distinguishes events inside the application, that have
the same event_type (see above)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">op</span></code> - This field takes one of the RTE_EVENT_OP_* values, and tells the
eventdev about the status of the event - valid values are NEW, FORWARD or
RELEASE.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sched_type</span></code> - Represents the type of scheduling that should be performed
on this event, valid values are the RTE_SCHED_TYPE_ORDERED, ATOMIC and
PARALLEL.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">queue_id</span></code> - The identifier for the event queue that the event is sent to.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">priority</span></code> - The priority of this event, see RTE_EVENT_DEV_PRIORITY.</p></li>
</ul>
</section>
<section id="event-payload">
<h3><span class="section-number">49.1.2. </span>Event Payload</h3>
<p>The rte_event struct contains a union for payload, allowing flexibility in what
the actual event being scheduled is. The payload is a union of the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">u64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*event_ptr</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rte_mbuf</span> <span class="pre">*mbuf</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rte_event_vector</span> <span class="pre">*vec</span></code></p></li>
</ul>
<p>These four items in a union occupy the same 64 bits at the end of the rte_event
structure. The application can utilize the 64 bits directly by accessing the
u64 variable, while the event_ptr, mbuf, vec are provided as a convenience
variables.  For example the mbuf pointer in the union can used to schedule a
DPDK packet.</p>
</section>
<section id="event-vector">
<h3><span class="section-number">49.1.3. </span>Event Vector</h3>
<p>The rte_event_vector struct contains a vector of elements defined by the event
type specified in the <code class="docutils literal notranslate"><span class="pre">rte_event</span></code>. The event_vector structure contains the
following data:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nb_elem</span></code> - The number of elements held within the vector.</p></li>
</ul>
<p>Similar to <code class="docutils literal notranslate"><span class="pre">rte_event</span></code> the payload of event vector is also a union, allowing
flexibility in what the actual vector is.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rte_mbuf</span> <span class="pre">*mbufs[0]</span></code> - An array of mbufs.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ptrs[0]</span></code> - An array of pointers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">u64s[0]</span></code> - An array of uint64_t elements.</p></li>
</ul>
<p>The size of the event vector is related to the total number of elements it is
configured to hold, this is achieved by making <cite>rte_event_vector</cite> a variable
length structure.
A helper function is provided to create a mempool that holds event vector, which
takes name of the pool, total number of required <code class="docutils literal notranslate"><span class="pre">rte_event_vector</span></code>,
cache size, number of elements in each <code class="docutils literal notranslate"><span class="pre">rte_event_vector</span></code> and socket id.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">rte_event_vector_pool_create</span><span class="p">(</span><span class="s">&quot;vector_pool&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">nb_event_vectors</span><span class="p">,</span><span class="w"> </span><span class="n">cache_sz</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="n">nb_elements_per_vector</span><span class="p">,</span><span class="w"> </span><span class="n">socket_id</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">rte_event_vector_pool_create</span></code> creates mempool with the best
platform mempool ops.</p>
</section>
<section id="queues">
<h3><span class="section-number">49.1.4. </span>Queues</h3>
<p>An event queue is a queue containing events that are scheduled by the event
device. An event queue contains events of different flows associated with
scheduling types, such as atomic, ordered, or parallel.</p>
<section id="queue-all-types-capable">
<h4><span class="section-number">49.1.4.1. </span>Queue All Types Capable</h4>
<p>If RTE_EVENT_DEV_CAP_QUEUE_ALL_TYPES capability bit is set in the event device,
then events of any type may be sent to any queue. Otherwise, the queues only
support events of the type that it was created with.</p>
</section>
<section id="queue-all-types-incapable">
<h4><span class="section-number">49.1.4.2. </span>Queue All Types Incapable</h4>
<p>In this case, each stage has a specified scheduling type.  The application
configures each queue for a specific type of scheduling, and just enqueues all
events to the eventdev. An example of a PMD of this type is the eventdev
software PMD.</p>
<p>The Eventdev API supports the following scheduling types per queue:</p>
<ul class="simple">
<li><p>Atomic</p></li>
<li><p>Ordered</p></li>
<li><p>Parallel</p></li>
</ul>
<p>Atomic, Ordered and Parallel are load-balanced scheduling types: the output
of the queue can be spread out over multiple CPU cores.</p>
<p>Atomic scheduling on a queue ensures that a single flow is not present on two
different CPU cores at the same time. Ordered allows sending all flows to any
core, but the scheduler must ensure that on egress the packets are returned to
ingress order on downstream queue enqueue. Parallel allows sending all flows
to all CPU cores, without any re-ordering guarantees.</p>
</section>
<section id="single-link-flag">
<h4><span class="section-number">49.1.4.3. </span>Single Link Flag</h4>
<p>There is a SINGLE_LINK flag which allows an application to indicate that only
one port will be connected to a queue.  Queues configured with the single-link
flag follow a FIFO like structure, maintaining ordering but it is only capable
of being linked to a single port (see below for port and queue linking details).</p>
</section>
</section>
<section id="ports">
<h3><span class="section-number">49.1.5. </span>Ports</h3>
<p>Ports are the points of contact between worker cores and the eventdev. The
general use case will see one CPU core using one port to enqueue and dequeue
events from an eventdev. Ports are linked to queues in order to retrieve events
from those queues (more details in <a class="reference internal" href="#linking-queues-and-ports">Linking Queues and Ports</a> below).</p>
</section>
</section>
<section id="api-walk-through">
<h2><span class="section-number">49.2. </span>API Walk-through</h2>
<p>This section will introduce the reader to the eventdev API, showing how to
create and configure an eventdev and use it for a two-stage atomic pipeline
with one core each for RX and TX. RX and TX cores are shown here for
illustration, refer to Eventdev Adapter documentation for further details.
The diagram below shows the final state of the application after this
walk-through:</p>
<figure class="align-default" id="id1">
<span id="figure-eventdev-usage1"></span><img alt="../_images/eventdev_usage.svg" src="../_images/eventdev_usage.svg" /><figcaption>
<p><span class="caption-number">Fig. 49.1 </span><span class="caption-text">Sample eventdev usage, with RX, two atomic stages and a single-link to TX.</span></p>
</figcaption>
</figure>
<p>A high level overview of the setup steps are:</p>
<ul class="simple">
<li><p>rte_event_dev_configure()</p></li>
<li><p>rte_event_queue_setup()</p></li>
<li><p>rte_event_port_setup()</p></li>
<li><p>rte_event_port_link()</p></li>
<li><p>rte_event_dev_start()</p></li>
</ul>
<section id="init-and-config">
<h3><span class="section-number">49.2.1. </span>Init and Config</h3>
<p>The eventdev library uses vdev options to add devices to the DPDK application.
The <code class="docutils literal notranslate"><span class="pre">--vdev</span></code> EAL option allows adding eventdev instances to your DPDK
application, using the name of the eventdev PMD as an argument.</p>
<p>For example, to create an instance of the software eventdev scheduler, the
following vdev arguments should be provided to the application EAL command line:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">./dpdk_application --vdev=&quot;event_sw0&quot;</span>
</pre></div>
</div>
<p>In the following code, we configure eventdev instance with 3 queues
and 6 ports as follows. The 3 queues consist of 2 Atomic and 1 Single-Link,
while the 6 ports consist of 4 workers, 1 RX and 1 TX.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">rte_event_dev_config</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">nb_event_queues</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">nb_event_ports</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">nb_events_limit</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">4096</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">nb_event_queue_flows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">nb_event_port_dequeue_depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">nb_event_port_enqueue_depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_event_dev_configure</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">config</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The remainder of this walk-through assumes that dev_id is 0.</p>
</section>
<section id="setting-up-queues">
<h3><span class="section-number">49.2.2. </span>Setting up Queues</h3>
<p>Once the eventdev itself is configured, the next step is to configure queues.
This is done by setting the appropriate values in a queue_conf structure, and
calling the setup function. Repeat this step for each queue, starting from
0 and ending at <code class="docutils literal notranslate"><span class="pre">nb_event_queues</span> <span class="pre">-</span> <span class="pre">1</span></code> from the event_dev config above.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">rte_event_queue_conf</span><span class="w"> </span><span class="n">atomic_conf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">schedule_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RTE_SCHED_TYPE_ATOMIC</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RTE_EVENT_DEV_PRIORITY_NORMAL</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">nb_atomic_flows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">nb_atomic_order_sequences</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">rte_event_queue_conf</span><span class="w"> </span><span class="n">single_link_conf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">event_queue_cfg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RTE_EVENT_QUEUE_CFG_SINGLE_LINK</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">dev_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">atomic_q_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">atomic_q_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">single_link_q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_event_queue_setup</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span><span class="w"> </span><span class="n">atomic_q_1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">atomic_conf</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_event_queue_setup</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span><span class="w"> </span><span class="n">atomic_q_2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">atomic_conf</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_event_queue_setup</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span><span class="w"> </span><span class="n">single_link_q</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">single_link_conf</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>As shown above, queue IDs are as follows:</p>
<blockquote>
<div><ul class="simple">
<li><p>id 0, atomic queue #1</p></li>
<li><p>id 1, atomic queue #2</p></li>
<li><p>id 2, single-link queue</p></li>
</ul>
</div></blockquote>
<p>These queues are used for the remainder of this walk-through.</p>
</section>
<section id="setting-up-ports">
<h3><span class="section-number">49.2.3. </span>Setting up Ports</h3>
<p>Once queues are set up successfully, create the ports as required.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">rte_event_port_conf</span><span class="w"> </span><span class="n">rx_conf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">dequeue_depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">enqueue_depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">new_event_threshold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">rte_event_port_conf</span><span class="w"> </span><span class="n">worker_conf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">dequeue_depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">enqueue_depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">new_event_threshold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4096</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">rte_event_port_conf</span><span class="w"> </span><span class="n">tx_conf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">dequeue_depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">enqueue_depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">new_event_threshold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4096</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">dev_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">rx_port_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">worker_port_id</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_event_port_setup</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span><span class="w"> </span><span class="n">rx_port_id</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rx_conf</span><span class="p">);</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">worker_port_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">worker_port_id</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">worker_port_id</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_event_port_setup</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span><span class="w"> </span><span class="n">worker_port_id</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">worker_conf</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">tx_port_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_event_port_setup</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span><span class="w"> </span><span class="n">tx_port_id</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tx_conf</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>As shown above:</p>
<blockquote>
<div><ul class="simple">
<li><p>port 0: RX core</p></li>
<li><p>ports 1,2,3,4: Workers</p></li>
<li><p>port 5: TX core</p></li>
</ul>
</div></blockquote>
<p>These ports are used for the remainder of this walk-through.</p>
</section>
<section id="linking-queues-and-ports">
<h3><span class="section-number">49.2.4. </span>Linking Queues and Ports</h3>
<p>The final step is to “wire up” the ports to the queues. After this, the
eventdev is capable of scheduling events, and when cores request work to do,
the correct events are provided to that core. Note that the RX core takes input
from e.g.: a NIC so it is not linked to any eventdev queues.</p>
<p>Linking all workers to atomic queues, and the TX core to the single-link queue
can be achieved like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">rx_port_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">tx_port_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">atomic_qs</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">};</span><span class="w"></span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">single_link_q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RTE_EVENT_DEV_PRIORITY_NORMAL</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">worker_port_id</span><span class="p">;</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">worker_port_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">worker_port_id</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">worker_port_id</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">links_made</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_event_port_link</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span><span class="w"> </span><span class="n">worker_port_id</span><span class="p">,</span><span class="w"> </span><span class="n">atomic_qs</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">links_made</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_event_port_link</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span><span class="w"> </span><span class="n">tx_port_id</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">single_link_q</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">priority</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="linking-queues-to-ports-with-link-profiles">
<h3><span class="section-number">49.2.5. </span>Linking Queues to Ports with link profiles</h3>
<p>An application can use link profiles if supported by the underlying event device to setup up
multiple link profile per port and change them run time depending up on heuristic data.
Using Link profiles can reduce the overhead of linking/unlinking and wait for unlinks in progress
in fast-path and gives applications the ability to switch between preset profiles on the fly.</p>
<p>An example use case could be as follows.</p>
<p>Config path:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">lq</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">};</span><span class="w"></span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">hq</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rte_event_dev_info</span><span class="p">.</span><span class="n">max_profiles_per_port</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOTSUP</span><span class="p">;</span><span class="w"></span>

<span class="n">rte_event_port_profile_links_set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">hq</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">rte_event_port_profile_links_set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">lq</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Worker path:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">profile_id_to_switch</span><span class="p">;</span><span class="w"></span>

<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">deq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_event_dequeue_burst</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ev</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">deq</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">profile_id_to_switch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">app_find_profile_id_to_switch</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">rte_event_port_profile_switch</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">profile_id_to_switch</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Process the event received.</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="starting-the-eventdev">
<h3><span class="section-number">49.2.6. </span>Starting the EventDev</h3>
<p>A single function call tells the eventdev instance to start processing
events. Note that all queues must be linked to for the instance to start, as
if any queue is not linked to, enqueuing to that queue will cause the
application to backpressure and eventually stall due to no space in the
eventdev.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_event_dev_start</span><span class="p">(</span><span class="n">dev_id</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>EventDev needs to be started before starting the event producers such
as event_eth_rx_adapter, event_timer_adapter, event_crypto_adapter and
event_dma_adapter.</p>
</div>
</section>
<section id="ingress-of-new-events">
<h3><span class="section-number">49.2.7. </span>Ingress of New Events</h3>
<p>Now that the eventdev is set up, and ready to receive events, the RX core must
enqueue some events into the system for it to schedule. The events to be
scheduled are ordinary DPDK packets, received from an eth_rx_burst() as normal.
The following code shows how those packets can be enqueued into the eventdev:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">nb_rx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_eth_rx_burst</span><span class="p">(</span><span class="n">eth_port</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">mbufs</span><span class="p">,</span><span class="w"> </span><span class="n">BATCH_SIZE</span><span class="p">);</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nb_rx</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">ev</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flow_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mbufs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">.</span><span class="n">rss</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">ev</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RTE_EVENT_OP_NEW</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">ev</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sched_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RTE_SCHED_TYPE_ATOMIC</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">ev</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">queue_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atomic_q_1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">ev</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">event_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RTE_EVENT_TYPE_ETHDEV</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">ev</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sub_event_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">ev</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RTE_EVENT_DEV_PRIORITY_NORMAL</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">ev</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mbuf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mbufs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">nb_tx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_event_enqueue_burst</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span><span class="w"> </span><span class="n">rx_port_id</span><span class="p">,</span><span class="w"> </span><span class="n">ev</span><span class="p">,</span><span class="w"> </span><span class="n">nb_rx</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nb_tx</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">nb_rx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nb_tx</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nb_rx</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="n">rte_pktmbuf_free</span><span class="p">(</span><span class="n">mbufs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="forwarding-of-events">
<h3><span class="section-number">49.2.8. </span>Forwarding of Events</h3>
<p>Now that the RX core has injected events, there is work to be done by the
workers. Note that each worker will dequeue as many events as it can in a burst,
process each one individually, and then burst the packets back into the
eventdev.</p>
<p>The worker can lookup the events source from <code class="docutils literal notranslate"><span class="pre">event.queue_id</span></code>, which should
indicate to the worker what workload needs to be performed on the event.
Once done, the worker can update the <code class="docutils literal notranslate"><span class="pre">event.queue_id</span></code> to a new value, to send
the event to the next stage in the pipeline.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">rte_event</span><span class="w"> </span><span class="n">events</span><span class="p">[</span><span class="n">BATCH_SIZE</span><span class="p">];</span><span class="w"></span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="n">nb_rx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_event_dequeue_burst</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span><span class="w"> </span><span class="n">worker_port_id</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="n">BATCH_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">timeout</span><span class="p">);</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nb_rx</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* process mbuf using events[i].queue_id as pipeline stage */</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">rte_mbuf</span><span class="w"> </span><span class="o">*</span><span class="n">mbuf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mbuf</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* Send event to next stage in pipeline */</span><span class="w"></span>
<span class="w">        </span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">queue_id</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">uint16_t</span><span class="w"> </span><span class="n">nb_tx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_event_enqueue_burst</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span><span class="w"> </span><span class="n">worker_port_id</span><span class="p">,</span><span class="w"> </span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="n">nb_rx</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="egress-of-events">
<h3><span class="section-number">49.2.9. </span>Egress of Events</h3>
<p>Finally, when the packet is ready for egress or needs to be dropped, we need
to inform the eventdev that the packet is no longer being handled by the
application. This can be done by calling dequeue() or dequeue_burst(), which
indicates that the previous burst of packets is no longer in use by the
application.</p>
<p>An event driven worker thread has following typical workflow on fastpath:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">rte_event_dequeue_burst</span><span class="p">(...);</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="n">event</span><span class="w"> </span><span class="n">processing</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">rte_event_enqueue_burst</span><span class="p">(...);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="quiescing-event-ports">
<h3><span class="section-number">49.2.10. </span>Quiescing Event Ports</h3>
<p>To migrate the event port to another lcore
or while tearing down a worker core using an event port,
<code class="docutils literal notranslate"><span class="pre">rte_event_port_quiesce()</span></code> can be invoked to make sure that all the data
associated with the event port are released from the worker core,
this might also include any prefetched events.</p>
<p>A flush callback can be passed to the function to handle any outstanding events.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">rte_event_port_quiesce</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span><span class="w"> </span><span class="n">port_id</span><span class="p">,</span><span class="w"> </span><span class="n">release_cb</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Invocation of this API does not affect the existing port configuration.</p>
</div>
</section>
<section id="stopping-the-eventdev">
<h3><span class="section-number">49.2.11. </span>Stopping the EventDev</h3>
<p>A single function call tells the eventdev instance to stop processing events.
A flush callback can be registered to free any inflight events
using <code class="docutils literal notranslate"><span class="pre">rte_event_dev_stop_flush_callback_register()</span></code> function.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_event_dev_stop</span><span class="p">(</span><span class="n">dev_id</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The event producers such as <code class="docutils literal notranslate"><span class="pre">event_eth_rx_adapter</span></code>,
<code class="docutils literal notranslate"><span class="pre">event_timer_adapter</span></code>, <code class="docutils literal notranslate"><span class="pre">event_crypto_adapter</span></code> and
<code class="docutils literal notranslate"><span class="pre">event_dma_adapter</span></code> need to be stopped before stopping
the event device.</p>
</div>
</section>
</section>
<section id="summary">
<h2><span class="section-number">49.3. </span>Summary</h2>
<p>The eventdev library allows an application to easily schedule events as it
requires, either using a run-to-completion or pipeline processing model.  The
queues and ports abstract the logical functionality of an eventdev, providing
the application with a generic method to schedule events.  With the flexible
PMD infrastructure applications benefit of improvements in existing eventdevs
and additions of new ones without modification.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/DPDK_logo_vertical_rev_small.png" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">Data Plane Development Kit</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../linux_gsg/index.html">Getting Started Guide for Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../freebsd_gsg/index.html">Getting Started Guide for FreeBSD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../windows_gsg/index.html">Getting Started Guide for Windows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sample_app_ug/index.html">Sample Applications User Guides</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Programmer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../howto/index.html">HowTo Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">DPDK Tools User Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testpmd_app_ug/index.html">Testpmd Application User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nics/index.html">Network Interface Controller Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bbdevs/index.html">Baseband Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cryptodevs/index.html">Crypto Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../compressdevs/index.html">Compression Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vdpadevs/index.html">vDPA Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../regexdevs/index.html">REGEX Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mldevs/index.html">Machine Learning Device Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dmadevs/index.html">DMA Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpus/index.html">General-Purpose Graphics Processing Unit Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventdevs/index.html">Event Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rawdevs/index.html">Rawdev Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mempool/index.html">Mempool Device Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../platform/index.html">Platform Specific Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">Contributor’s Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rel_notes/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Programmer’s Guide</a><ul>
      <li>Previous: <a href="thread_safety_dpdk_functions.html" title="previous chapter"><span class="section-number">48. </span>Thread Safety of DPDK Functions</a></li>
      <li>Next: <a href="event_ethernet_rx_adapter.html" title="next chapter"><span class="section-number">50. </span>Event Ethernet Rx Adapter Library</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      
      
      
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.3.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/prog_guide/eventdev.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>