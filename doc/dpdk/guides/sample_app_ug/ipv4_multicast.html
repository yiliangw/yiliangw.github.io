
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>10. IPv4 Multicast Sample Application &#8212; Data Plane Development Kit 23.11.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="11. IP Reassembly Sample Application" href="ip_reassembly.html" />
    <link rel="prev" title="9. IP Fragmentation Sample Application" href="ip_frag.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="ipv4-multicast-sample-application">
<h1><span class="section-number">10. </span>IPv4 Multicast Sample Application</h1>
<p>The IPv4 Multicast application is a simple example of packet processing
using the Data Plane Development Kit (DPDK).
The application performs L3 multicasting.</p>
<section id="overview">
<h2><span class="section-number">10.1. </span>Overview</h2>
<p>The application demonstrates the use of zero-copy buffers for packet forwarding.
The initialization and run-time paths are very similar to those of the <a class="reference internal" href="l2_forward_real_virtual.html"><span class="doc">L2 Forwarding Sample Application (in Real and Virtualized Environments)</span></a>.
This guide highlights the differences between the two applications.
There are two key differences from the L2 Forwarding sample application:</p>
<ul class="simple">
<li><p>The IPv4 Multicast sample application makes use of indirect buffers.</p></li>
<li><p>The forwarding decision is taken based on information read from the input packet’s IPv4 header.</p></li>
</ul>
<p>The lookup method is the Four-byte Key (FBK) hash-based method.
The lookup table is composed of pairs of destination IPv4 address (the FBK)
and a port mask associated with that IPv4 address.
By default, the following IP addresses and their respective port masks are added:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="w">		</span><span class="p">{</span><span class="n">RTE_IPV4</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">101</span><span class="p">),</span><span class="w"> </span><span class="mh">0x1</span><span class="p">},</span><span class="w"></span>
<span class="w">		</span><span class="p">{</span><span class="n">RTE_IPV4</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">102</span><span class="p">),</span><span class="w"> </span><span class="mh">0x2</span><span class="p">},</span><span class="w"></span>
<span class="w">		</span><span class="p">{</span><span class="n">RTE_IPV4</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">103</span><span class="p">),</span><span class="w"> </span><span class="mh">0x3</span><span class="p">},</span><span class="w"></span>
<span class="w">		</span><span class="p">{</span><span class="n">RTE_IPV4</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">104</span><span class="p">),</span><span class="w"> </span><span class="mh">0x4</span><span class="p">},</span><span class="w"></span>
<span class="w">		</span><span class="p">{</span><span class="n">RTE_IPV4</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">105</span><span class="p">),</span><span class="w"> </span><span class="mh">0x5</span><span class="p">},</span><span class="w"></span>
<span class="w">		</span><span class="p">{</span><span class="n">RTE_IPV4</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">106</span><span class="p">),</span><span class="w"> </span><span class="mh">0x6</span><span class="p">},</span><span class="w"></span>
<span class="w">		</span><span class="p">{</span><span class="n">RTE_IPV4</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">107</span><span class="p">),</span><span class="w"> </span><span class="mh">0x7</span><span class="p">},</span><span class="w"></span>
<span class="w">		</span><span class="p">{</span><span class="n">RTE_IPV4</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">108</span><span class="p">),</span><span class="w"> </span><span class="mh">0x8</span><span class="p">},</span><span class="w"></span>
<span class="w">		</span><span class="p">{</span><span class="n">RTE_IPV4</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">109</span><span class="p">),</span><span class="w"> </span><span class="mh">0x9</span><span class="p">},</span><span class="w"></span>
<span class="w">		</span><span class="p">{</span><span class="n">RTE_IPV4</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">110</span><span class="p">),</span><span class="w"> </span><span class="mh">0xA</span><span class="p">},</span><span class="w"></span>
<span class="w">		</span><span class="p">{</span><span class="n">RTE_IPV4</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">111</span><span class="p">),</span><span class="w"> </span><span class="mh">0xB</span><span class="p">},</span><span class="w"></span>
<span class="w">		</span><span class="p">{</span><span class="n">RTE_IPV4</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">112</span><span class="p">),</span><span class="w"> </span><span class="mh">0xC</span><span class="p">},</span><span class="w"></span>
<span class="w">		</span><span class="p">{</span><span class="n">RTE_IPV4</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">113</span><span class="p">),</span><span class="w"> </span><span class="mh">0xD</span><span class="p">},</span><span class="w"></span>
<span class="w">		</span><span class="p">{</span><span class="n">RTE_IPV4</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">114</span><span class="p">),</span><span class="w"> </span><span class="mh">0xE</span><span class="p">},</span><span class="w"></span>
<span class="w">		</span><span class="p">{</span><span class="n">RTE_IPV4</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">115</span><span class="p">),</span><span class="w"> </span><span class="mh">0xF</span><span class="p">},</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The max port mask supported in the given hash table is 0xf, so only first
four ports can be supported.
If using non-consecutive ports, use the destination IPv4 address accordingly.</p>
</div>
<p>For convenience and simplicity, this sample application does not take IANA-assigned multicast addresses into account,
but instead equates the last four bytes of the multicast group (that is, the last four bytes of the destination IP address)
with the mask of ports to multicast packets to.
Also, the application does not consider the Ethernet addresses;
it looks only at the IPv4 destination address for any given packet.</p>
</section>
<section id="compiling-the-application">
<h2><span class="section-number">10.2. </span>Compiling the Application</h2>
<p>To compile the sample application see <a class="reference internal" href="compiling.html"><span class="doc">Compiling the Sample Applications</span></a>.</p>
<p>The application is located in the <code class="docutils literal notranslate"><span class="pre">ipv4_multicast</span></code> sub-directory.</p>
</section>
<section id="running-the-application">
<h2><span class="section-number">10.3. </span>Running the Application</h2>
<p>The application has a number of command line options:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">./&lt;build_dir&gt;/examples/dpdk-ipv4_multicast [EAL options] -- -p PORTMASK [-q NQ]</span>
</pre></div>
</div>
<p>where,</p>
<ul class="simple">
<li><p>-p PORTMASK: Hexadecimal bitmask of ports to configure</p></li>
<li><p>-q NQ: determines the number of queues per lcore</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unlike the basic L2/L3 Forwarding sample applications,
NUMA support is not provided in the IPv4 Multicast sample application.</p>
</div>
<p>Typically, to run the IPv4 Multicast sample application, issue the following command (as root):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">./&lt;build_dir&gt;/examples/dpdk-ipv4_multicast -l 0-3 -n 3 -- -p 0x3 -q 1</span>
</pre></div>
</div>
<p>In this command:</p>
<ul class="simple">
<li><p>The -l option enables cores 0, 1, 2 and 3</p></li>
<li><p>The -n option specifies 3 memory channels</p></li>
<li><p>The -p option enables ports 0 and 1</p></li>
<li><p>The -q option assigns 1 queue to each lcore</p></li>
</ul>
<p>Refer to the <em>DPDK Getting Started Guide</em> for general information on running applications
and the Environment Abstraction Layer (EAL) options.</p>
</section>
<section id="explanation">
<h2><span class="section-number">10.4. </span>Explanation</h2>
<p>The following sections provide some explanation of the code.
As mentioned in the overview section,
the initialization and run-time paths are very similar to those of the <a class="reference internal" href="l2_forward_real_virtual.html"><span class="doc">L2 Forwarding Sample Application (in Real and Virtualized Environments)</span></a>.
The following sections describe aspects that are specific to the IPv4 Multicast sample application.</p>
<section id="memory-pool-initialization">
<h3><span class="section-number">10.4.1. </span>Memory Pool Initialization</h3>
<p>The IPv4 Multicast sample application uses three memory pools.
Two of the pools are for indirect buffers used for packet duplication purposes.
Memory pools for indirect buffers are initialized differently from the memory pool for direct buffers:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">packet_pool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_pktmbuf_pool_create</span><span class="p">(</span><span class="s">&quot;packet_pool&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">NB_PKT_MBUF</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">PKT_MBUF_DATA_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">rte_socket_id</span><span class="p">());</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">packet_pool</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
<span class="w">	</span><span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Cannot init packet mbuf pool</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>

<span class="n">header_pool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_pktmbuf_pool_create</span><span class="p">(</span><span class="s">&quot;header_pool&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">NB_HDR_MBUF</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">HDR_MBUF_DATA_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">rte_socket_id</span><span class="p">());</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">header_pool</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
<span class="w">	</span><span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Cannot init header mbuf pool</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>

<span class="n">clone_pool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_pktmbuf_pool_create</span><span class="p">(</span><span class="s">&quot;clone_pool&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">NB_CLONE_MBUF</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"></span>
<span class="w">	</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">rte_socket_id</span><span class="p">());</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">clone_pool</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
<span class="w">	</span><span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Cannot init clone mbuf pool</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The reason for this is because indirect buffers are not supposed to hold any packet data and
therefore can be initialized with lower amount of reserved memory for each buffer.</p>
</section>
<section id="hash-initialization">
<h3><span class="section-number">10.4.2. </span>Hash Initialization</h3>
<p>The hash object is created and loaded with the pre-configured entries read from a global array:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"></span>
<span class="nf">init_mcast_hash</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">mcast_hash_params</span><span class="p">.</span><span class="n">socket_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_socket_id</span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="n">mcast_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_fbk_hash_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcast_hash_params</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mcast_hash</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">){</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">RTE_DIM</span><span class="p">(</span><span class="n">mcast_group_table</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rte_fbk_hash_add_key</span><span class="p">(</span><span class="n">mcast_hash</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">mcast_group_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ip</span><span class="p">,</span><span class="w"></span>
<span class="w">			</span><span class="n">mcast_group_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">port_mask</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="forwarding">
<h3><span class="section-number">10.4.3. </span>Forwarding</h3>
<p>All forwarding is done inside the mcast_forward() function.
Firstly, the Ethernet* header is removed from the packet and the IPv4 address is extracted from the IPv4 header:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">iphdr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rte_ipv4_hdr</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"></span>
<span class="w">	</span><span class="n">rte_pktmbuf_adj</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rte_ether_hdr</span><span class="p">));</span><span class="w"></span>
<span class="n">RTE_ASSERT</span><span class="p">(</span><span class="n">iphdr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>

<span class="n">dest_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_be_to_cpu_32</span><span class="p">(</span><span class="n">iphdr</span><span class="o">-&gt;</span><span class="n">dst_addr</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Then, the packet is checked to see if it has a multicast destination address and
if the routing table has any ports assigned to the destination address:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">RTE_IS_IPV4_MCAST</span><span class="p">(</span><span class="n">dest_addr</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="n">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_fbk_hash_lookup</span><span class="p">(</span><span class="n">mcast_hash</span><span class="p">,</span><span class="w"> </span><span class="n">dest_addr</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="n">port_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">enabled_port_mask</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">rte_pktmbuf_free</span><span class="p">(</span><span class="n">m</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Then, the number of ports in the destination portmask is calculated with the help of the bitcnt() function:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"></span>
<span class="nf">bitcnt</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This is done to determine which forwarding algorithm to use.
This is explained in more detail in the next section.</p>
<p>Thereafter, a destination Ethernet address is constructed:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">dst_eth_addr</span><span class="p">.</span><span class="n">as_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ETHER_ADDR_FOR_IPV4_MCAST</span><span class="p">(</span><span class="n">dest_addr</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Since Ethernet addresses are also part of the multicast process, each outgoing packet carries the same destination Ethernet address.
The destination Ethernet address is constructed from the lower 23 bits of the multicast group OR-ed
with the Ethernet address 01:00:5e:00:00:00, as per RFC 1112:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define	ETHER_ADDR_FOR_IPV4_MCAST(x)	\</span>
<span class="cp">	(rte_cpu_to_be_64(0x01005e000000ULL | ((x) &amp; 0x7fffff)) &gt;&gt; 16)</span>
</pre></div>
</div>
<p>Then, packets are dispatched to the destination ports according to the portmask associated with a multicast group:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">use_clone</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">port_mask</span><span class="p">;</span><span class="w"> </span><span class="n">port_mask</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">port</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* Prepare output packet and send it out. */</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">port_mask</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">likely</span><span class="w"> </span><span class="p">((</span><span class="n">mc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mcast_out_pkt</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">use_clone</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">))</span><span class="w"></span>
<span class="w">			</span><span class="n">mcast_send_pkt</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dst_eth_addr</span><span class="p">.</span><span class="n">as_addr</span><span class="p">,</span><span class="w"></span>
<span class="w">					</span><span class="n">qconf</span><span class="p">,</span><span class="w"> </span><span class="n">port</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">use_clone</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">			</span><span class="n">rte_pktmbuf_free</span><span class="p">(</span><span class="n">m</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The actual packet transmission is done in the mcast_send_pkt() function:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"></span>
<span class="nf">mcast_send_pkt</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rte_mbuf</span><span class="w"> </span><span class="o">*</span><span class="n">pkt</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">rte_ether_addr</span><span class="w"> </span><span class="o">*</span><span class="n">dest_addr</span><span class="p">,</span><span class="w"></span>
<span class="w">		</span><span class="k">struct</span><span class="w"> </span><span class="nc">lcore_queue_conf</span><span class="w"> </span><span class="o">*</span><span class="n">qconf</span><span class="p">,</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">port</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">rte_ether_hdr</span><span class="w"> </span><span class="o">*</span><span class="n">ethdr</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* Construct Ethernet header. */</span><span class="w"></span>
<span class="w">	</span><span class="n">ethdr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rte_ether_hdr</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"></span>
<span class="w">		</span><span class="n">rte_pktmbuf_prepend</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ethdr</span><span class="p">));</span><span class="w"></span>
<span class="w">	</span><span class="n">RTE_ASSERT</span><span class="p">(</span><span class="n">ethdr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="n">rte_ether_addr_copy</span><span class="p">(</span><span class="n">dest_addr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ethdr</span><span class="o">-&gt;</span><span class="n">dst_addr</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">rte_ether_addr_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ports_eth_addr</span><span class="p">[</span><span class="n">port</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ethdr</span><span class="o">-&gt;</span><span class="n">src_addr</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">ethdr</span><span class="o">-&gt;</span><span class="n">ether_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_be_to_cpu_16</span><span class="p">(</span><span class="n">RTE_ETHER_TYPE_IPV4</span><span class="p">);</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* Put new packet into the output queue */</span><span class="w"></span>
<span class="w">	</span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">qconf</span><span class="o">-&gt;</span><span class="n">tx_mbufs</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">len</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">qconf</span><span class="o">-&gt;</span><span class="n">tx_mbufs</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">m_table</span><span class="p">[</span><span class="n">len</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pkt</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">qconf</span><span class="o">-&gt;</span><span class="n">tx_mbufs</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="n">len</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* Transmit packets */</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">MAX_PKT_BURST</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">len</span><span class="p">))</span><span class="w"></span>
<span class="w">		</span><span class="n">send_burst</span><span class="p">(</span><span class="n">qconf</span><span class="p">,</span><span class="w"> </span><span class="n">port</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="buffer-cloning">
<h3><span class="section-number">10.4.4. </span>Buffer Cloning</h3>
<p>This is the most important part of the application since it demonstrates the use of zero- copy buffer cloning.
There are two approaches for creating the outgoing packet and although both are based on the data zero-copy idea,
there are some differences in the detail.</p>
<p>The first approach creates a clone of the input packet, for example,
walk though all segments of the input packet and for each of segment,
create a new buffer and attach that new buffer to the segment
(refer to rte_pktmbuf_clone() in the rte_mbuf library for more details).
A new buffer is then allocated for the packet header and is prepended to the cloned buffer.</p>
<p>The second approach does not make a clone, it just increments the reference counter for all input packet segment,
allocates a new buffer for the packet header and prepends it to the input packet.</p>
<p>Basically, the first approach reuses only the input packet’s data, but creates its own copy of packet’s metadata.
The second approach reuses both input packet’s data and metadata.</p>
<p>The advantage of first approach is that each outgoing packet has its own copy of the metadata,
so we can safely modify the data pointer of the input packet.
That allows us to skip creation if the output packet is for the last destination port
and instead modify input packet’s header in place.
For example, for N destination ports, we need to invoke mcast_out_pkt() (N-1) times.</p>
<p>The advantage of the second approach is that there is less work to be done for each outgoing packet,
that is, the “clone” operation is skipped completely.
However, there is a price to pay.
The input packet’s metadata must remain intact, so for N destination ports,
we need to invoke mcast_out_pkt() (N) times.</p>
<p>Therefore, for a small number of outgoing ports (and segments in the input packet),
first approach is faster.
As the number of outgoing ports (and/or input segments) grows, the second approach becomes more preferable.</p>
<p>Depending on the number of segments or the number of ports in the outgoing portmask,
either the first (with cloning) or the second (without cloning) approach is taken:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">use_clone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">port_num</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">MCAST_CLONE_PORTS</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nb_segs</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">MCAST_CLONE_SEGS</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>It is the mcast_out_pkt() function that performs the packet duplication (either with or without actually cloning the buffers):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">rte_mbuf</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="n">mcast_out_pkt</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rte_mbuf</span><span class="w"> </span><span class="o">*</span><span class="n">pkt</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">use_clone</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">rte_mbuf</span><span class="w"> </span><span class="o">*</span><span class="n">hdr</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* Create new mbuf for the header. */</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="w"> </span><span class="p">((</span><span class="n">hdr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_pktmbuf_alloc</span><span class="p">(</span><span class="n">header_pool</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">))</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* If requested, then make a new clone packet. */</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">use_clone</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">	    </span><span class="n">unlikely</span><span class="w"> </span><span class="p">((</span><span class="n">pkt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rte_pktmbuf_clone</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span><span class="w"> </span><span class="n">clone_pool</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">rte_pktmbuf_free</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* prepend new header */</span><span class="w"></span>
<span class="w">	</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pkt</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="cm">/* update header&#39;s fields */</span><span class="w"></span>
<span class="w">	</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">pkt_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">)(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">pkt_len</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">nb_segs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">nb_segs</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">__rte_mbuf_sanity_check</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">hdr</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/DPDK_logo_vertical_rev_small.png" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">Data Plane Development Kit</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../linux_gsg/index.html">Getting Started Guide for Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../freebsd_gsg/index.html">Getting Started Guide for FreeBSD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../windows_gsg/index.html">Getting Started Guide for Windows</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Sample Applications User Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../prog_guide/index.html">Programmer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../howto/index.html">HowTo Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">DPDK Tools User Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testpmd_app_ug/index.html">Testpmd Application User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nics/index.html">Network Interface Controller Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bbdevs/index.html">Baseband Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cryptodevs/index.html">Crypto Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../compressdevs/index.html">Compression Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vdpadevs/index.html">vDPA Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../regexdevs/index.html">REGEX Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mldevs/index.html">Machine Learning Device Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dmadevs/index.html">DMA Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpus/index.html">General-Purpose Graphics Processing Unit Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventdevs/index.html">Event Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rawdevs/index.html">Rawdev Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mempool/index.html">Mempool Device Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../platform/index.html">Platform Specific Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">Contributor’s Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rel_notes/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Sample Applications User Guides</a><ul>
      <li>Previous: <a href="ip_frag.html" title="previous chapter"><span class="section-number">9. </span>IP Fragmentation Sample Application</a></li>
      <li>Next: <a href="ip_reassembly.html" title="next chapter"><span class="section-number">11. </span>IP Reassembly Sample Application</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      
      
      
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.3.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/sample_app_ug/ipv4_multicast.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>